-- author: 上帝之子(QQ:103260152)
-- date: 2015-03-27
-- version: cocos2dx-2.2.3

CCPoint = {x=0,y=0}
ccV2F_C4F_T2F_Quad = {}
ccV3F_C4B_T2F_Quad = {}
ccV2F_C4F_T2F = {}
ccPointSprite = {}
ccQuad3 = {bl={x=0,y=0,z=0}, br={x=0,y=0,z=0}, tl={x=0,y=0,z=0}, tr={x=0,y=0,z=0},}
ccColor4F = {r=0,g=0,b=0,a=0}
CCSize = {width=0,height=0}
ccVertex2F = {x=0,y=0}
ccColor4B = {r=0,g=0,b=0,a=0}
ccTex2F = {u=0,v=0}
ccV3F_C4B_T2F = {}
ccBezierConfig = {endPosition={x=0,y=0},controlPoint_1={x=0,y=0},controlPoint_2={x=0,y=0}}
CCAffineTransform = {a=0, b=0, c=0, d=0, tx=0, ty=0}
ccV2F_C4B_T2F_Quad = {}
ccTexParams = {minFilter=0, magFilter=0, wrapS=0, wrapT=0}
ccBlendFunc = {src=0,dst=0}
ccAnimationFrameData = {}
ccT2F_Quad = {}
ccColor3B = {r=0,g=0,b=0}
ccVertex3F = {x=0,y=0,z=0}
CCRect = {origin={x=0,y=0},size={width=0,height=0}}
ccV2F_C4B_T2F = {}
ccQuad2 = {tl={x=0,y=0}, tr={x=0,y=0}, bl={x=0,y=0}, br={x=0,y=0},}

kCCActionTagInvalid = nil
kLanguageEnglish = nil
kLanguageChinese = nil
kLanguageFrench = nil
kLanguageItalian = nil
kLanguageGerman = nil
kLanguageSpanish = nil
kLanguageRussian = nil
kLanguageKorean = nil
kLanguageJapanese = nil
kLanguageHungarian = nil
kLanguagePortuguese = nil
kLanguageArabic = nil
kTargetWindows = nil
kTargetLinux = nil
kTargetMacOS = nil
kTargetAndroid = nil
kTargetIphone = nil
kTargetIpad = nil
kTargetBlackBerry = nil
kTargetNaCl = nil
kTargetEmscripten = nil
kTargetTizen = nil
kTargetWinRT = nil
kTargetWP8 = nil
CCControlEventTouchDown = nil
CCControlEventTouchDragInside = nil
CCControlEventTouchDragOutside = nil
CCControlEventTouchDragEnter = nil
CCControlEventTouchDragExit = nil
CCControlEventTouchUpInside = nil
CCControlEventTouchUpOutside = nil
CCControlEventTouchCancel = nil
CCControlEventValueChanged = nil
CCControlStateNormal = nil
CCControlStateHighlighted = nil
CCControlStateDisabled = nil
CCControlStateSelected = nil
kCCControlStepperPartMinus = nil
kCCControlStepperPartPlus = nil
kCCControlStepperPartNone = nil
kCCDirectorProjection2D = nil
kCCDirectorProjection3D = nil
kCCDirectorProjectionCustom = nil
kCCDirectorProjectionDefault = nil
kResolutionExactFit = nil
kResolutionNoBorder = nil
kResolutionShowAll = nil
kResolutionUnKnown = nil
kKeyboardReturnTypeDefault = nil
kKeyboardReturnTypeDone = nil
kKeyboardReturnTypeSend = nil
kKeyboardReturnTypeSearch = nil
kKeyboardReturnTypeGo = nil
kEditBoxInputModeAny = nil
kEditBoxInputModeEmailAddr = nil
kEditBoxInputModeNumeric = nil
kEditBoxInputModePhoneNumber = nil
kEditBoxInputModeUrl = nil
kEditBoxInputModeDecimal = nil
kEditBoxInputModeSingleLine = nil
kEditBoxInputFlagPassword = nil
kEditBoxInputFlagSensitive = nil
kEditBoxInputFlagInitialCapsWord = nil
kEditBoxInputFlagInitialCapsSentence = nil
kEditBoxInputFlagInitialCapsAllCharacters = nil
kTypeBackClicked = nil
kTypeMenuClicked = nil
kCCLabelAutomaticWidth = nil
kCCTouchesAllAtOnce = nil
kCCTouchesOneByOne = nil
kCCMenuStateWaiting = nil
kCCMenuStateTrackingTouch = nil
kCCMenuHandlerPriority = nil
kCCNodeTagInvalid = nil
kCCNodeOnEnter = nil
kCCNodeOnExit = nil
CC_GL_ALL = nil
kCCParticleDurationInfinity = nil
kCCParticleStartSizeEqualToEndSize = nil
kCCParticleStartRadiusEqualToEndRadius = nil
kParticleStartSizeEqualToEndSize = nil
kParticleDurationInfinity = nil
kCCParticleModeGravity = nil
kCCParticleModeRadius = nil
kCCPositionTypeFree = nil
kCCPositionTypeRelative = nil
kCCPositionTypeGrouped = nil
kPositionTypeFree = nil
kPositionTypeGrouped = nil
kCCProgressTimerTypeRadial = nil
kCCProgressTimerTypeBar = nil
kCCImageFormatJPEG = nil
kCCImageFormatPNG = nil
kCCScrollViewDirectionNone = nil
kCCScrollViewDirectionHorizontal = nil
kCCScrollViewDirectionVertical = nil
kCCScrollViewDirectionBoth = nil
CC_HONOR_PARENT_TRANSFORM_TRANSLATE = nil
CC_HONOR_PARENT_TRANSFORM_ROTATE = nil
CC_HONOR_PARENT_TRANSFORM_SCALE = nil
CC_HONOR_PARENT_TRANSFORM_SKEW = nil
CC_HONOR_PARENT_TRANSFORM_ALL = nil
CCTMXOrientationOrtho = nil
CCTMXOrientationHex = nil
CCTMXOrientationIso = nil
TMXLayerAttribNone = nil
TMXLayerAttribBase64 = nil
TMXLayerAttribGzip = nil
TMXLayerAttribZlib = nil
TMXPropertyNone = nil
TMXPropertyMap = nil
TMXPropertyLayer = nil
TMXPropertyObjectGroup = nil
TMXPropertyObject = nil
TMXPropertyTile = nil
kCCTMXTileHorizontalFlag = nil
kCCTMXTileVerticalFlag = nil
kCCTMXTileDiagonalFlag = nil
kCCFlipedAll = nil
kCCFlippedMask = nil
kCCTableViewFillTopDown = nil
kCCTableViewFillBottomUp = nil
kCCTexture2DPixelFormat_RGBA8888 = nil
kCCTexture2DPixelFormat_RGB888 = nil
kCCTexture2DPixelFormat_RGB565 = nil
kCCTexture2DPixelFormat_A8 = nil
kCCTexture2DPixelFormat_I8 = nil
kCCTexture2DPixelFormat_AI88 = nil
kCCTexture2DPixelFormat_RGBA4444 = nil
kCCTexture2DPixelFormat_RGB5A1 = nil
kCCTexture2DPixelFormat_PVRTC4 = nil
kCCTexture2DPixelFormat_PVRTC2 = nil
kCCTexture2DPixelFormat_Default = nil
kTexture2DPixelFormat_RGBA8888 = nil
kTexture2DPixelFormat_RGB888 = nil
kTexture2DPixelFormat_RGB565 = nil
kTexture2DPixelFormat_A8 = nil
kTexture2DPixelFormat_RGBA4444 = nil
kTexture2DPixelFormat_RGB5A1 = nil
kTexture2DPixelFormat_Default = nil
kCCTransitionOrientationLeftOver = nil
kCCTransitionOrientationRightOver = nil
kCCTransitionOrientationUpOver = nil
kCCTransitionOrientationDownOver = nil
CHECKBOX_STATE_EVENT_SELECTED = nil
CHECKBOX_STATE_EVENT_UNSELECTED = nil
LAYOUT_COLOR_NONE = nil
LAYOUT_COLOR_SOLID = nil
LAYOUT_COLOR_GRADIENT = nil
LAYOUT_ABSOLUTE = nil
LAYOUT_LINEAR_VERTICAL = nil
LAYOUT_LINEAR_HORIZONTAL = nil
LAYOUT_RELATIVE = nil
LAYOUT_CLIPPING_STENCIL = nil
LAYOUT_CLIPPING_SCISSOR = nil
LINEAR_GRAVITY_NONE = nil
LINEAR_GRAVITY_LEFT = nil
LINEAR_GRAVITY_TOP = nil
LINEAR_GRAVITY_RIGHT = nil
LINEAR_GRAVITY_BOTTOM = nil
LINEAR_GRAVITY_CENTER_VERTICAL = nil
LINEAR_GRAVITY_CENTER_HORIZONTAL = nil
RELATIVE_ALIGN_NONE = nil
RELATIVE_ALIGN_PARENT_TOP_LEFT = nil
RELATIVE_ALIGN_PARENT_TOP_CENTER_HORIZONTAL = nil
RELATIVE_ALIGN_PARENT_TOP_RIGHT = nil
RELATIVE_ALIGN_PARENT_LEFT_CENTER_VERTICAL = nil
RELATIVE_CENTER_IN_PARENT = nil
RELATIVE_ALIGN_PARENT_RIGHT_CENTER_VERTICAL = nil
RELATIVE_ALIGN_PARENT_LEFT_BOTTOM = nil
RELATIVE_ALIGN_PARENT_BOTTOM_CENTER_HORIZONTAL = nil
RELATIVE_ALIGN_PARENT_RIGHT_BOTTOM = nil
RELATIVE_LOCATION_ABOVE_LEFTALIGN = nil
RELATIVE_LOCATION_ABOVE_CENTER = nil
RELATIVE_LOCATION_ABOVE_RIGHTALIGN = nil
RELATIVE_LOCATION_LEFT_OF_TOPALIGN = nil
RELATIVE_LOCATION_LEFT_OF_CENTER = nil
RELATIVE_LOCATION_LEFT_OF_BOTTOMALIGN = nil
RELATIVE_LOCATION_RIGHT_OF_TOPALIGN = nil
RELATIVE_LOCATION_RIGHT_OF_CENTER = nil
RELATIVE_LOCATION_RIGHT_OF_BOTTOMALIGN = nil
RELATIVE_LOCATION_BELOW_LEFTALIGN = nil
RELATIVE_LOCATION_BELOW_CENTER = nil
RELATIVE_LOCATION_BELOW_RIGHTALIGN = nil
LAYOUT_PARAMETER_NONE = nil
LAYOUT_PARAMETER_LINEAR = nil
LAYOUT_PARAMETER_RELATIVE = nil
LISTVIEW_GRAVITY_LEFT = nil
LISTVIEW_GRAVITY_RIGHT = nil
LISTVIEW_GRAVITY_CENTER_HORIZONTAL = nil
LISTVIEW_GRAVITY_TOP = nil
LISTVIEW_GRAVITY_BOTTOM = nil
LISTVIEW_GRAVITY_CENTER_VERTICAL = nil
LISTVIEW_ONSELECTEDITEM_START = nil
LISTVIEW_ONSELECTEDITEM_END = nil
LoadingBarTypeLeft = nil
LoadingBarTypeRight = nil
PAGEVIEW_EVENT_TURNING = nil
PAGEVIEW_TOUCHLEFT = nil
PAGEVIEW_TOUCHRIGHT = nil
RICH_TEXT = nil
RICH_IMAGE = nil
RICH_CUSTOM = nil
SCROLLVIEW_DIR_NONE = nil
SCROLLVIEW_DIR_VERTICAL = nil
SCROLLVIEW_DIR_HORIZONTAL = nil
SCROLLVIEW_DIR_BOTH = nil
SCROLLVIEW_EVENT_SCROLL_TO_TOP = nil
SCROLLVIEW_EVENT_SCROLL_TO_BOTTOM = nil
SCROLLVIEW_EVENT_SCROLL_TO_LEFT = nil
SCROLLVIEW_EVENT_SCROLL_TO_RIGHT = nil
SCROLLVIEW_EVENT_SCROLLING = nil
SCROLLVIEW_EVENT_BOUNCE_TOP = nil
SCROLLVIEW_EVENT_BOUNCE_BOTTOM = nil
SCROLLVIEW_EVENT_BOUNCE_LEFT = nil
SCROLLVIEW_EVENT_BOUNCE_RIGHT = nil
SLIDER_PERCENTCHANGED = nil
TEXTFIELD_EVENT_ATTACH_WITH_IME = nil
TEXTFIELD_EVENT_DETACH_WITH_IME = nil
TEXTFIELD_EVENT_INSERT_TEXT = nil
TEXTFIELD_EVENT_DELETE_BACKWARD = nil
BRIGHT_NONE = nil
BRIGHT_NORMAL = nil
BRIGHT_HIGHLIGHT = nil
WidgetTypeWidget = nil
WidgetTypeContainer = nil
UI_TEX_TYPE_LOCAL = nil
UI_TEX_TYPE_PLIST = nil
TOUCH_EVENT_BEGAN = nil
TOUCH_EVENT_MOVED = nil
TOUCH_EVENT_ENDED = nil
TOUCH_EVENT_CANCELED = nil
SIZE_ABSOLUTE = nil
SIZE_PERCENT = nil
POSITION_ABSOLUTE = nil
POSITION_PERCENT = nil
kCCVerticalTextAlignmentTop = nil
kCCVerticalTextAlignmentCenter = nil
kCCVerticalTextAlignmentBottom = nil
kCCTextAlignmentLeft = nil
kCCTextAlignmentCenter = nil
kCCTextAlignmentRight = nil

--- <summary>
--- CCAffineTransform __CCAffineTransformMake(float a, float b, float c, float d, float tx, float ty)
--- </summary>
--- <returns type="CCAffineTransform"></returns>
function __CCAffineTransformMake() end
--- <summary>
--- CCAffineTransform CCAffineTransformMake(float a, float b, float c, float d, float tx, float ty)
--- </summary>
--- <returns type="CCAffineTransform"></returns>
function CCAffineTransformMake() end
--- <summary>
--- CCPoint __CCPointApplyAffineTransform(CCPoint point, CCAffineTransform t)
--- </summary>
--- <returns type="CCPoint"></returns>
function __CCPointApplyAffineTransform() end
--- <summary>
--- CCPoint CCPointApplyAffineTransform(CCPoint point, CCAffineTransform t)
--- </summary>
--- <returns type="CCPoint"></returns>
function CCPointApplyAffineTransform() end
--- <summary>
--- CCSize CCSizeApplyAffineTransform(CCSize size, CCAffineTransform t)
--- </summary>
--- <returns type="CCSize"></returns>
function CCSizeApplyAffineTransform() end
--- <summary>
--- CCSize __CCSizeApplyAffineTransform(CCSize size, CCAffineTransform t)
--- </summary>
--- <returns type="CCSize"></returns>
function __CCSizeApplyAffineTransform() end
--- <summary>
--- CCAffineTransform CCAffineTransformMakeIdentity()
--- </summary>
--- <returns type="CCAffineTransform"></returns>
function CCAffineTransformMakeIdentity() end
--- <summary>
--- CCRect CCRectApplyAffineTransform(CCRect rect, CCAffineTransform anAffineTransform)
--- </summary>
--- <returns type="CCRect"></returns>
function CCRectApplyAffineTransform() end
--- <summary>
--- CCAffineTransform CCAffineTransformTranslate(CCAffineTransform t, float tx, float ty)
--- </summary>
--- <returns type="CCAffineTransform"></returns>
function CCAffineTransformTranslate() end
--- <summary>
--- CCAffineTransform CCAffineTransformRotate(CCAffineTransform aTransform, float anAngle)
--- </summary>
--- <returns type="CCAffineTransform"></returns>
function CCAffineTransformRotate() end
--- <summary>
--- CCAffineTransform CCAffineTransformScale(CCAffineTransform t, float sx, float sy)
--- </summary>
--- <returns type="CCAffineTransform"></returns>
function CCAffineTransformScale() end
--- <summary>
--- CCAffineTransform CCAffineTransformConcat(CCAffineTransform t1,CCAffineTransform t2)
--- </summary>
--- <returns type="CCAffineTransform"></returns>
function CCAffineTransformConcat() end
--- <summary>
--- bool CCAffineTransformEqualToTransform(CCAffineTransform t1,CCAffineTransform t2)
--- </summary>
function CCAffineTransformEqualToTransform() end
--- <summary>
--- CCAffineTransform CCAffineTransformInvert(CCAffineTransform t)
--- </summary>
--- <returns type="CCAffineTransform"></returns>
function CCAffineTransformInvert() end
--- <summary>
--- void CCLuaLog(const char * pszFormat)
--- </summary>
function CCLuaLog() end
--- <summary>
--- void CCMessageBox(const char * pszMsg, const char * pszTitle)
--- </summary>
function CCMessageBox() end
--- <summary>
--- void  ccDrawPoint(CCPoint point)
--- </summary>
function ccDrawPoint() end
--- <summary>
--- void  ccDrawPoints(const CCPoint *points, unsigned int numberOfPoints)
--- </summary>
function ccDrawPoints() end
--- <summary>
--- void  ccDrawLine(CCPoint origin, CCPoint destination)
--- </summary>
function ccDrawLine() end
--- <summary>
--- void  ccDrawRect(CCPoint origin, CCPoint destination)
--- </summary>
function ccDrawRect() end
--- <summary>
--- void  ccDrawSolidRect(CCPoint origin, CCPoint destination, ccColor4F color)
--- </summary>
function ccDrawSolidRect() end
--- <summary>
--- void  ccDrawPoly(const CCPoint *vertices, unsigned int numOfVertices, bool closePolygon)
--- </summary>
function ccDrawPoly() end
--- <summary>
--- void  ccDrawSolidPoly(const CCPoint* poli, unsigned int numberOfPoints, ccColor4F color)
--- </summary>
function ccDrawSolidPoly() end
--- <summary>
--- void  ccDrawCircle(const CCPoint&amp; center, float radius, float angle, unsigned int segments, bool drawLineToCenter, float xScale = 1.0f, float yScale = 1.0f)
--- </summary>
function ccDrawCircle() end
--- <summary>
--- void  ccDrawQuadBezier(CCPoint origin, CCPoint control, CCPoint destination, unsigned int segments)
--- </summary>
function ccDrawQuadBezier() end
--- <summary>
--- void  ccDrawCubicBezier(CCPoint origin, CCPoint control1, CCPoint control2, CCPoint destination, unsigned int segments)
--- </summary>
function ccDrawCubicBezier() end
--- <summary>
--- void  ccDrawCatmullRom(CCPointArray* arrayOfControlPoints, unsigned int segments)
--- </summary>
function ccDrawCatmullRom() end
--- <summary>
--- void  ccDrawCardinalSpline(CCPointArray* config, float tension, unsigned int segments)
--- </summary>
function ccDrawCardinalSpline() end
--- <summary>
--- void  ccDrawColor4B(GLubyte r, GLubyte g, GLubyte b, GLubyte a)
--- </summary>
function ccDrawColor4B() end
--- <summary>
--- void  ccDrawColor4F(GLubyte r, GLubyte g, GLubyte b, GLubyte a)
--- </summary>
function ccDrawColor4F() end
--- <summary>
--- void  ccPointSize(GLfloat pointSize)
--- </summary>
function ccPointSize() end
--- <summary>
--- CCPoint CCPointMake(float x, float y)
--- </summary>
--- <returns type="CCPoint"></returns>
function CCPointMake() end
--- <summary>
--- CCPoint CCPointMake @ ccp (float x, float y)
--- </summary>
--- <returns type="@"></returns>
function ccp() end
--- <summary>
--- CCSize  CCSizeMake(float width, float height)
--- </summary>
--- <returns type="CCSize"></returns>
function CCSizeMake() end
--- <summary>
--- CCRect  CCRectMake(float x, float y, float width,float height)
--- </summary>
--- <returns type="CCRect"></returns>
function CCRectMake() end
--- <summary>
--- static  CCPoint ccpNeg(const CCPoint&amp; v)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpNeg() end
--- <summary>
--- static  CCPoint ccpAdd(const CCPoint&amp; v1, const CCPoint&amp; v2)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpAdd() end
--- <summary>
--- static  CCPoint ccpSub(const CCPoint&amp; v1, const CCPoint&amp; v2)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpSub() end
--- <summary>
--- static  CCPoint ccpMult(const CCPoint&amp; v, const float s)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpMult() end
--- <summary>
--- static  CCPoint ccpMidpoint(const CCPoint&amp; v1, const CCPoint&amp; v2)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpMidpoint() end
--- <summary>
--- static  float ccpDot(const CCPoint&amp; v1, const CCPoint&amp; v2)
--- </summary>
function ccpDot() end
--- <summary>
--- static  float ccpCross(const CCPoint&amp; v1, const CCPoint&amp; v2)
--- </summary>
function ccpCross() end
--- <summary>
--- static  CCPoint ccpPerp(const CCPoint&amp; v)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpPerp() end
--- <summary>
--- static  CCPoint ccpRPerp(const CCPoint&amp; v)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpRPerp() end
--- <summary>
--- static  CCPoint ccpProject(const CCPoint&amp; v1, const CCPoint&amp; v2)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpProject() end
--- <summary>
--- static  CCPoint ccpRotate(const CCPoint&amp; v1, const CCPoint&amp; v2)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpRotate() end
--- <summary>
--- static  CCPoint ccpUnrotate(const CCPoint&amp; v1, const CCPoint&amp; v2)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpUnrotate() end
--- <summary>
--- static  float ccpLengthSQ(const CCPoint&amp; v)
--- </summary>
function ccpLengthSQ() end
--- <summary>
--- static  float ccpDistanceSQ(const CCPoint p1, const CCPoint p2)
--- </summary>
function ccpDistanceSQ() end
--- <summary>
--- float ccpLength(const CCPoint&amp; v)
--- </summary>
function ccpLength() end
--- <summary>
--- float ccpDistance(const CCPoint&amp; v1, const CCPoint&amp; v2)
--- </summary>
function ccpDistance() end
--- <summary>
--- CCPoint ccpNormalize(const CCPoint&amp; v)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpNormalize() end
--- <summary>
--- CCPoint ccpForAngle(const float a)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpForAngle() end
--- <summary>
--- float ccpToAngle(const CCPoint&amp; v)
--- </summary>
function ccpToAngle() end
--- <summary>
--- float   clampf(float value, float min_inclusive, float max_inclusive)
--- </summary>
function clampf() end
--- <summary>
--- CCPoint ccpClamp(const CCPoint&amp; p, const CCPoint&amp; from, const CCPoint&amp; to)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpClamp() end
--- <summary>
--- CCPoint ccpFromSize(const CCSize&amp; s)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpFromSize() end
--- <summary>
--- CCPoint  ccpLerp(const CCPoint&amp; a, const CCPoint&amp; b, float alpha)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpLerp() end
--- <summary>
--- bool  ccpFuzzyEqual(const CCPoint&amp; a, const CCPoint&amp; b, float variance)
--- </summary>
function ccpFuzzyEqual() end
--- <summary>
--- CCPoint  ccpCompMult(const CCPoint&amp; a, const CCPoint&amp; b)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpCompMult() end
--- <summary>
--- float  ccpAngleSigned(const CCPoint&amp; a, const CCPoint&amp; b)
--- </summary>
function ccpAngleSigned() end
--- <summary>
--- float  ccpAngle(const CCPoint&amp; a, const CCPoint&amp; b)
--- </summary>
function ccpAngle() end
--- <summary>
--- CCPoint  ccpRotateByAngle(const CCPoint&amp; v, const CCPoint&amp; pivot, float angle)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpRotateByAngle() end
--- <summary>
--- bool  ccpLineIntersect(const CCPoint&amp; p1, const CCPoint&amp; p2, const CCPoint&amp; p3, const CCPoint&amp; p4, float *s, float *t)
--- </summary>
function ccpLineIntersect() end
--- <summary>
--- bool ccpSegmentIntersect(const CCPoint&amp; A, const CCPoint&amp; B, const CCPoint&amp; C, const CCPoint&amp; D)
--- </summary>
function ccpSegmentIntersect() end
--- <summary>
--- CCPoint ccpIntersectPoint(const CCPoint&amp; A, const CCPoint&amp; B, const CCPoint&amp; C, const CCPoint&amp; D)
--- </summary>
--- <returns type="CCPoint"></returns>
function ccpIntersectPoint() end
--- <summary>
--- static ccColor3B ccc3(const GLubyte r, const GLubyte g, const GLubyte b)
--- </summary>
--- <returns type="ccColor3B"></returns>
function ccc3() end
--- <summary>
--- static ccColor4B ccc4(const GLubyte r, const GLubyte g, const GLubyte b, const GLubyte o)
--- </summary>
--- <returns type="ccColor4B"></returns>
function ccc4() end
--- <summary>
--- static ccColor4F ccc4FFromccc3B(ccColor3B c)
--- </summary>
--- <returns type="ccColor4F"></returns>
function ccc4FFromccc3B() end
--- <summary>
--- static ccColor4F ccc4f(const GLfloat r, const GLfloat g, const GLfloat b, const GLfloat a)
--- </summary>
--- <returns type="ccColor4F"></returns>
function ccc4f() end
--- <summary>
--- static ccColor4F ccc4FFromccc4B(ccColor4B c)
--- </summary>
--- <returns type="ccColor4F"></returns>
function ccc4FFromccc4B() end
--- <summary>
--- static bool ccc4FEqual(ccColor4F a, ccColor4F b)
--- </summary>
function ccc4FEqual() end
--- <summary>
--- static ccVertex2F vertex2(const float x, const float y)
--- </summary>
--- <returns type="ccVertex2F"></returns>
function vertex2() end
--- <summary>
--- static ccVertex3F vertex3(const float x, const float y, const float z)
--- </summary>
--- <returns type="ccVertex3F"></returns>
function vertex3() end
--- <summary>
--- static ccTex2F tex2(const float u, const float v)
--- </summary>
--- <returns type="ccTex2F"></returns>
function tex2() end
--- <summary>
--- void kmGLFreeAll(void)
--- </summary>
function kmGLFreeAll() end
--- <summary>
--- void kmGLPushMatrix(void)
--- </summary>
function kmGLPushMatrix() end
--- <summary>
--- void kmGLPopMatrix(void)
--- </summary>
function kmGLPopMatrix() end
--- <summary>
--- void kmGLMatrixMode(kmGLEnum mode)
--- </summary>
function kmGLMatrixMode() end
--- <summary>
--- void kmGLLoadIdentity(void)
--- </summary>
function kmGLLoadIdentity() end
--- <summary>
--- void kmGLLoadMatrix(const kmMat4* pIn)
--- </summary>
function kmGLLoadMatrix() end
--- <summary>
--- void kmGLMultMatrix(const kmMat4* pIn)
--- </summary>
function kmGLMultMatrix() end
--- <summary>
--- void kmGLTranslatef(float x, float y, float z)
--- </summary>
function kmGLTranslatef() end
--- <summary>
--- void kmGLRotatef(float angle, float x, float y, float z)
--- </summary>
function kmGLRotatef() end
--- <summary>
--- void kmGLScalef(float x, float y, float z)
--- </summary>
function kmGLScalef() end
--- <summary>
--- void kmGLGetMatrix(kmGLEnum mode, kmMat4* pOut)
--- </summary>
function kmGLGetMatrix() end

ActionManager = class(CCObject)
--- <summary>
--- ActionManager();
--- </summary>
function ActionManager:new() end
function ActionManager:new_local() end
--- <summary>
--- ActionObject* getActionByName(const char* jsonName,const char* actionName);
--- </summary>
--- <returns type="ActionObject"></returns>
function ActionManager:getActionByName() end
--- <summary>
--- ActionObject* playActionByName(const char* jsonName,const char* actionName);
--- </summary>
--- <returns type="ActionObject"></returns>
function ActionManager:playActionByName() end
--- <summary>
--- static void purge();
--- </summary>
function ActionManager:purge() end
--- <summary>
--- void releaseActions();
--- </summary>
function ActionManager:releaseActions() end
--- <summary>
--- static ActionManager* shareManager();
--- </summary>
--- <returns type="ActionManager"></returns>
function ActionManager:shareManager() end
--- <summary>
--- virtual ~ActionManager();
--- </summary>
function ActionManager:delete() end

ActionObject = class(CCObject)
--- <summary>
--- ActionObject();
--- </summary>
function ActionObject:new() end
function ActionObject:new_local() end
--- <summary>
--- void addActionNode(ActionNode* node);
--- </summary>
function ActionObject:addActionNode() end
--- <summary>
--- float getCurrentTime();
--- </summary>
function ActionObject:getCurrentTime() end
--- <summary>
--- bool getLoop();
--- </summary>
function ActionObject:getLoop() end
--- <summary>
--- const char* getName();
--- </summary>
function ActionObject:getName() end
--- <summary>
--- float getUnitTime();
--- </summary>
function ActionObject:getUnitTime() end
--- <summary>
--- void initWithDictionary(const rapidjson::Value&amp; dic,CCObject* root);
--- </summary>
function ActionObject:initWithDictionary() end
--- <summary>
--- bool isPlaying();
--- </summary>
function ActionObject:isPlaying() end
--- <summary>
--- void pause();
--- </summary>
function ActionObject:pause() end
--- <summary>
--- void play();
--- </summary>
function ActionObject:play() end
--- <summary>
--- void removeActionNode(ActionNode* node);
--- </summary>
function ActionObject:removeActionNode() end
--- <summary>
--- void setCurrentTime(float fTime);
--- </summary>
function ActionObject:setCurrentTime() end
--- <summary>
--- void setLoop(bool bLoop);
--- </summary>
function ActionObject:setLoop() end
--- <summary>
--- void setName(const char* name);
--- </summary>
function ActionObject:setName() end
--- <summary>
--- void setUnitTime(float fTime);
--- </summary>
function ActionObject:setUnitTime() end
--- <summary>
--- void simulationActionUpdate(float dt);
--- </summary>
function ActionObject:simulationActionUpdate() end
--- <summary>
--- void stop();
--- </summary>
function ActionObject:stop() end
--- <summary>
--- void updateToFrameByTime(float fTime);
--- </summary>
function ActionObject:updateToFrameByTime() end
--- <summary>
--- virtual ~ActionObject();
--- </summary>
function ActionObject:delete() end

CCAction = class(CCObject)
--- <summary>
--- CCNode* getOriginalTarget(void);
--- </summary>
--- <returns type="CCNode"></returns>
function CCAction:getOriginalTarget() end
--- <summary>
--- int getTag(void);
--- </summary>
function CCAction:getTag() end
--- <summary>
--- CCNode* getTarget(void);
--- </summary>
--- <returns type="CCNode"></returns>
function CCAction:getTarget() end
--- <summary>
--- bool isDone(void);
--- </summary>
function CCAction:isDone() end
--- <summary>
--- void setTag(int nTag);
--- </summary>
function CCAction:setTag() end

CCFiniteTimeAction = class(CCAction)
--- <summary>
--- float getDuration(void);
--- </summary>
function CCFiniteTimeAction:getDuration() end
--- <summary>
--- //returns a reversed action 
--- virtual CCFiniteTimeAction* reverse(void);
--- </summary>
--- <returns type="CCFiniteTimeAction"></returns>
function CCFiniteTimeAction:reverse() end
--- <summary>
--- void setDuration(float duration);
--- </summary>
function CCFiniteTimeAction:setDuration() end

CCActionInterval = class(CCFiniteTimeAction)
--- <summary>
--- //creates the action 
--- static CCActionInterval* create(float d);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCActionInterval:create() end
--- <summary>
--- float getAmplitudeRate(void);
--- </summary>
function CCActionInterval:getAmplitudeRate() end
--- <summary>
--- //how many seconds had elapsed since the actions started to run. 
--- inline float getElapsed(void);
--- </summary>
function CCActionInterval:getElapsed() end
--- <summary>
--- //returns true if the action has finished 
--- virtual bool isDone(void);
--- </summary>
function CCActionInterval:isDone() end
--- <summary>
--- //returns a reversed action 
--- virtual CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCActionInterval:reverse() end
--- <summary>
--- void setAmplitudeRate(float amp);
--- </summary>
function CCActionInterval:setAmplitudeRate() end

CCSpeed = class(CCAction)
--- <summary>
--- //create the action 
--- static CCSpeed* create(CCActionInterval* pAction, float fSpeed);
--- </summary>
--- <returns type="CCSpeed"></returns>
function CCSpeed:create() end
--- <summary>
--- float getSpeed(void);
--- </summary>
function CCSpeed:getSpeed() end
--- <summary>
--- bool isDone(void);
--- </summary>
function CCSpeed:isDone() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCSpeed:reverse() end
--- <summary>
--- //alter the speed of the inner function in runtime 
--- inline void setSpeed(float fSpeed);
--- </summary>
function CCSpeed:setSpeed() end

CCFollow = class(CCAction)
--- <summary>
--- //creates the action with a set boundary,
--- //It will work with no boundary if @param rect is equal to CCRectZero.
--- static CCFollow* create(CCNode *pFollowedNode, const CCRect&amp; rect = CCRectZero);
--- </summary>
--- <returns type="CCFollow"></returns>
function CCFollow:create() end
--- <summary>
--- bool isBoundarySet(void);
--- </summary>
function CCFollow:isBoundarySet() end
--- <summary>
--- bool isDone(void);
--- </summary>
function CCFollow:isDone() end
--- <summary>
--- //alter behavior - turn on/off boundary 
--- inline void setBoudarySet(bool bValue);
--- </summary>
function CCFollow:setBoudarySet() end

CCSequence = class(CCActionInterval)
--- <summary>
--- //helper constructor to create an array of sequenceable actions 
--- //@lua NA
--- static CCSequence* create(CCFiniteTimeAction *pAction1, ...);
--- 
--- //helper constructor to create an array of sequenceable actions given an array 
--- //@js NA
--- static CCSequence* create(CCArray *arrayOfActions);
--- </summary>
--- <returns type="CCSequence"></returns>
function CCSequence:create() end
--- <summary>
--- //creates the action 
--- //@js NA
--- static CCSequence* createWithTwoActions(CCFiniteTimeAction *pActionOne, CCFiniteTimeAction *pActionTwo);
--- </summary>
--- <returns type="CCSequence"></returns>
function CCSequence:createWithTwoActions() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCSequence:reverse() end

CCRepeat = class(CCActionInterval)
--- <summary>
--- //creates a CCRepeat action. Times is an unsigned integer between 1 and pow(2,30) 
--- static CCRepeat* create(CCFiniteTimeAction *pAction, unsigned int times);
--- </summary>
--- <returns type="CCRepeat"></returns>
function CCRepeat:create() end
--- <summary>
--- bool isDone(void);
--- </summary>
function CCRepeat:isDone() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCRepeat:reverse() end

CCRepeatForever = class(CCActionInterval)
--- <summary>
--- //creates the action 
--- static CCRepeatForever* create(CCActionInterval *pAction);
--- </summary>
--- <returns type="CCRepeatForever"></returns>
function CCRepeatForever:create() end
--- <summary>
--- bool isDone(void);
--- </summary>
function CCRepeatForever:isDone() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCRepeatForever:reverse() end

CCSpawn = class(CCActionInterval)
--- <summary>
--- //helper constructor to create an array of spawned actions 
--- //@lua NA
--- static CCSpawn* create(CCFiniteTimeAction *pAction1, ...);
--- 
--- //helper constructor to create an array of spawned actions given an array 
--- //@js NA
--- static CCSpawn* create(CCArray *arrayOfActions);
--- </summary>
--- <returns type="CCSpawn"></returns>
function CCSpawn:create() end
--- <summary>
--- //creates the Spawn action 
--- //@js NA
--- static CCSpawn* createWithTwoActions(CCFiniteTimeAction *pAction1, CCFiniteTimeAction *pAction2);
--- </summary>
--- <returns type="CCSpawn"></returns>
function CCSpawn:createWithTwoActions() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCSpawn:reverse() end

CCRotateTo = class(CCActionInterval)
--- <summary>
--- //creates the action 
--- static CCRotateTo* create(float fDuration, float fDeltaAngle);
--- 
--- //creates the action with separate rotation angles 
--- static CCRotateTo* create(float fDuration, float fDeltaAngleX, float fDeltaAngleY);
--- </summary>
--- <returns type="CCRotateTo"></returns>
function CCRotateTo:create() end

CCRotateBy = class(CCActionInterval)
--- <summary>
--- //creates the action 
--- static CCRotateBy* create(float fDuration, float fDeltaAngle);
--- </summary>
--- <returns type="CCRotateBy"></returns>
function CCRotateBy:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCRotateBy:reverse() end

CCMoveTo = class(CCActionInterval)
--- <summary>
--- //creates the action 
--- static CCMoveTo* create(float duration, const CCPoint&amp; position);
--- </summary>
--- <returns type="CCMoveTo"></returns>
function CCMoveTo:create() end

CCMoveBy = class(CCActionInterval)
--- <summary>
--- //creates the action 
--- static CCMoveBy* create(float duration, const CCPoint&amp; deltaPosition);
--- </summary>
--- <returns type="CCMoveBy"></returns>
function CCMoveBy:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCMoveBy:reverse() end

CCSkewTo = class(CCActionInterval)
--- <summary>
--- //creates the action 
--- static CCSkewTo* create(float t, float sx, float sy);
--- </summary>
--- <returns type="CCSkewTo"></returns>
function CCSkewTo:create() end

CCSkewBy = class(CCActionInterval)
--- <summary>
--- //creates the action 
--- static CCSkewBy* create(float t, float deltaSkewX, float deltaSkewY);
--- </summary>
--- <returns type="CCSkewBy"></returns>
function CCSkewBy:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCSkewBy:reverse() end

CCJumpBy = class(CCActionInterval)
--- <summary>
--- //creates the action 
--- static CCJumpBy* create(float duration, const CCPoint&amp; position, float height, unsigned int jumps);
--- </summary>
--- <returns type="CCJumpBy"></returns>
function CCJumpBy:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCJumpBy:reverse() end

CCJumpTo = class(CCActionInterval)
--- <summary>
--- //creates the action 
--- static CCJumpTo* create(float duration, const CCPoint&amp; position, float height, int jumps);
--- </summary>
--- <returns type="CCJumpTo"></returns>
function CCJumpTo:create() end

ccBezierConfig = {}
--- <summary>
--- ccBezierConfig(void);
--- </summary>
function ccBezierConfig:new() end
function ccBezierConfig:new_local() end

CCBezierBy = class(CCActionInterval)
--- <summary>
--- //creates the action with a duration and a bezier configuration 
--- //@code
--- //when this function bound to js,the input params are changed
--- //js: var create(var t, var pointTable)
--- //@endcode
--- static CCBezierBy* create(float t, const ccBezierConfig&amp; c);
--- </summary>
--- <returns type="CCBezierBy"></returns>
function CCBezierBy:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCBezierBy:reverse() end

CCBezierTo = class(CCActionInterval)
--- <summary>
--- //creates the action with a duration and a bezier configuration
--- //@code
--- //when this function bound to js,the input params are changed
--- //js: var create(var t, var pointTable)
--- //@endcode
--- static CCBezierTo* create(float t, const ccBezierConfig&amp; c);
--- </summary>
--- <returns type="CCBezierTo"></returns>
function CCBezierTo:create() end

CCScaleTo = class(CCActionInterval)
--- <summary>
--- //creates the action with the same scale factor for X and Y 
--- static CCScaleTo* create(float duration, float s);
--- 
--- //creates the action with and X factor and a Y factor 
--- static CCScaleTo* create(float duration, float sx, float sy);
--- </summary>
--- <returns type="CCScaleTo"></returns>
function CCScaleTo:create() end

CCScaleBy = class(CCActionInterval)
--- <summary>
--- //creates the action with the same scale factor for X and Y 
--- static CCScaleBy* create(float duration, float s);
--- 
--- //creates the action with and X factor and a Y factor 
--- static CCScaleBy* create(float duration, float sx, float sy);
--- </summary>
--- <returns type="CCScaleBy"></returns>
function CCScaleBy:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCScaleBy:reverse() end

CCBlink = class(CCActionInterval)
--- <summary>
--- //creates the action 
--- static CCBlink* create(float duration, unsigned int uBlinks);
--- </summary>
--- <returns type="CCBlink"></returns>
function CCBlink:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCBlink:reverse() end

CCFadeIn = class(CCActionInterval)
--- <summary>
--- //creates the action 
--- static CCFadeIn* create(float d);
--- </summary>
--- <returns type="CCFadeIn"></returns>
function CCFadeIn:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCFadeIn:reverse() end

CCFadeOut = class(CCActionInterval)
--- <summary>
--- //creates the action 
--- static CCFadeOut* create(float d);
--- </summary>
--- <returns type="CCFadeOut"></returns>
function CCFadeOut:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCFadeOut:reverse() end

CCFadeTo = class(CCActionInterval)
--- <summary>
--- //creates an action with duration and opacity 
--- static CCFadeTo* create(float duration, GLubyte opacity);
--- </summary>
--- <returns type="CCFadeTo"></returns>
function CCFadeTo:create() end

CCTintTo = class(CCActionInterval)
--- <summary>
--- //creates an action with duration and color 
--- static CCTintTo* create(float duration, GLubyte red, GLubyte green, GLubyte blue);
--- </summary>
--- <returns type="CCTintTo"></returns>
function CCTintTo:create() end

CCTintBy = class(CCActionInterval)
--- <summary>
--- //creates an action with duration and color 
--- static CCTintBy* create(float duration, GLshort deltaRed, GLshort deltaGreen, GLshort deltaBlue);
--- </summary>
--- <returns type="CCTintBy"></returns>
function CCTintBy:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCTintBy:reverse() end

CCDelayTime = class(CCActionInterval)
--- <summary>
--- //creates the action 
--- static CCDelayTime* create(float d);
--- </summary>
--- <returns type="CCDelayTime"></returns>
function CCDelayTime:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCDelayTime:reverse() end

CCReverseTime = class(CCActionInterval)
--- <summary>
--- //creates the action 
--- static CCReverseTime* create(CCFiniteTimeAction *pAction);
--- </summary>
--- <returns type="CCReverseTime"></returns>
function CCReverseTime:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCReverseTime:reverse() end

CCAnimate = class(CCActionInterval)
--- <summary>
--- //creates the action with an Animation and will restore the original frame when the animation is over 
--- static CCAnimate* create(CCAnimation *pAnimation);
--- </summary>
--- <returns type="CCAnimate"></returns>
function CCAnimate:create() end
--- <summary>
--- CCAnimation* getAnimation(void);
--- </summary>
--- <returns type="CCAnimation"></returns>
function CCAnimate:getAnimation() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCAnimate:reverse() end
--- <summary>
--- void setAnimation(CCAnimation *pAnimation);
--- </summary>
function CCAnimate:setAnimation() end

CCTargetedAction = class(CCActionInterval)
--- <summary>
--- //Create an action with the specified action and forced target 
--- static CCTargetedAction* create(CCNode* pTarget, CCFiniteTimeAction* pAction);
--- </summary>
--- <returns type="CCTargetedAction"></returns>
function CCTargetedAction:create() end
--- <summary>
--- CCNode* getForcedTarget(void);
--- </summary>
--- <returns type="CCNode"></returns>
function CCTargetedAction:getForcedTarget() end
--- <summary>
--- void setForcedTarget(CCNode* target);
--- </summary>
function CCTargetedAction:setForcedTarget() end

CCActionInstant = class(CCFiniteTimeAction)
--- <summary>
--- bool isDone(void);
--- </summary>
function CCActionInstant:isDone() end
--- <summary>
--- CCFiniteTimeAction* reverse(void);
--- </summary>
--- <returns type="CCFiniteTimeAction"></returns>
function CCActionInstant:reverse() end

CCShow = class(CCActionInstant)
--- <summary>
--- //Allocates and initializes the action 
--- static CCShow * create();
--- </summary>
--- <returns type="CCShow"></returns>
function CCShow:create() end
--- <summary>
--- CCFiniteTimeAction* reverse(void);
--- </summary>
--- <returns type="CCFiniteTimeAction"></returns>
function CCShow:reverse() end

CCHide = class(CCActionInstant)
--- <summary>
--- //Allocates and initializes the action 
--- static CCHide * create();
--- </summary>
--- <returns type="CCHide"></returns>
function CCHide:create() end
--- <summary>
--- CCFiniteTimeAction* reverse(void);
--- </summary>
--- <returns type="CCFiniteTimeAction"></returns>
function CCHide:reverse() end

CCToggleVisibility = class(CCActionInstant)
--- <summary>
--- //Allocates and initializes the action 
--- static CCToggleVisibility * create();
--- </summary>
--- <returns type="CCToggleVisibility"></returns>
function CCToggleVisibility:create() end

CCFlipX = class(CCActionInstant)
--- <summary>
--- //create the action 
--- static CCFlipX * create(bool x);
--- </summary>
--- <returns type="CCFlipX"></returns>
function CCFlipX:create() end
--- <summary>
--- CCFiniteTimeAction* reverse(void);
--- </summary>
--- <returns type="CCFiniteTimeAction"></returns>
function CCFlipX:reverse() end

CCFlipY = class(CCActionInstant)
--- <summary>
--- //create the action 
--- static CCFlipY * create(bool y);
--- </summary>
--- <returns type="CCFlipY"></returns>
function CCFlipY:create() end
--- <summary>
--- CCFiniteTimeAction* reverse(void);
--- </summary>
--- <returns type="CCFiniteTimeAction"></returns>
function CCFlipY:reverse() end

CCPlace = class(CCActionInstant)
--- <summary>
--- //creates a Place action with a position 
--- static CCPlace * create(const CCPoint&amp; pos);
--- </summary>
--- <returns type="CCPlace"></returns>
function CCPlace:create() end

CCCallFunc = class(CCActionInstant)
--- <summary>
--- //creates the action with the handler script function 
--- //@js NA
--- static CCCallFunc * create(int nHandler);
--- </summary>
--- <returns type="CCCallFunc"></returns>
function CCCallFunc:create() end

CCCallFuncN = class(CCCallFunc)
--- <summary>
--- //creates the action with the handler script function
--- static CCCallFuncN * create(int nHandler);
--- </summary>
--- <returns type="CCCallFuncN"></returns>
function CCCallFuncN:create() end

CCActionCamera = class(CCActionInterval)
--- <summary>
--- CCActionInterval* reverse();
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCActionCamera:reverse() end
--- <summary>
--- void startWithTarget(CCNode *pTarget);
--- </summary>
function CCActionCamera:startWithTarget() end

CCOrbitCamera = class(CCActionCamera)
--- <summary>
--- //creates a CCOrbitCamera action with radius, delta-radius,  z, deltaZ, x, deltaX 
--- static CCOrbitCamera* create(float t, float radius, float deltaRadius, float angleZ, float deltaAngleZ, float angleX, float deltaAngleX);
--- </summary>
--- <returns type="CCOrbitCamera"></returns>
function CCOrbitCamera:create() end
--- <summary>
--- //positions the camera according to spherical coordinates 
--- void sphericalRadius(float *r, float *zenith, float *azimuth);
--- </summary>
function CCOrbitCamera:sphericalRadius() end

CCPointArray = class(CCNode)
--- <summary>
--- //appends a control point 
--- void addControlPoint(CCPoint controlPoint);
--- </summary>
function CCPointArray:addControlPoint() end
--- <summary>
--- //returns the number of objects of the control point array 
--- unsigned int count();
--- </summary>
function CCPointArray:count() end
--- <summary>
--- //creates and initializes a Points array with capacity 
--- //@lua NA
--- static CCPointArray* create(unsigned int capacity);
--- </summary>
--- <returns type="CCPointArray"></returns>
function CCPointArray:create() end
--- <summary>
--- //get the value of a controlPoint at a given index 
--- CCPoint getControlPointAtIndex(unsigned int index);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCPointArray:getControlPointAtIndex() end
--- <summary>
--- const std::vector&lt;CCPoint*>* getControlPoints();
--- </summary>
--- <returns type="std::vector&lt;CCPoint*>"></returns>
function CCPointArray:getControlPoints() end
--- <summary>
--- //initializes a Catmull Rom config with a capacity hint 
--- bool initWithCapacity(unsigned int capacity);
--- </summary>
function CCPointArray:initWithCapacity() end
--- <summary>
--- //inserts a controlPoint at index 
--- void insertControlPoint(CCPoint &amp;controlPoint, unsigned int index);
--- </summary>
function CCPointArray:insertControlPoint() end
--- <summary>
--- //deletes a control point at a given index 
--- void removeControlPointAtIndex(unsigned int index);
--- </summary>
function CCPointArray:removeControlPointAtIndex() end
--- <summary>
--- //replaces an existing controlPoint at index 
--- void replaceControlPoint(CCPoint &amp;controlPoint, unsigned int index);
--- </summary>
function CCPointArray:replaceControlPoint() end
--- <summary>
--- //returns a new copy of the array reversed. User is responsible for releasing this copy 
--- CCPointArray* reverse();
--- </summary>
--- <returns type="CCPointArray"></returns>
function CCPointArray:reverse() end
--- <summary>
--- //reverse the current control point array inline, without generating a new one 
--- void reverseInline();
--- </summary>
function CCPointArray:reverseInline() end
--- <summary>
--- void setControlPoints(std::vector&lt;CCPoint*> *controlPoints);
--- </summary>
function CCPointArray:setControlPoints() end

CCCardinalSplineTo = class(CCActionInterval)
--- <summary>
--- //creates an action with a Cardinal Spline array of points and tension 
--- //@code
--- //when thie function bound to js,the input params are changed
--- //js:var create(var duration,var pointTable,var tension)
--- //@endcode
--- static CCCardinalSplineTo* create(float duration, CCPointArray* points, float tension);
--- </summary>
--- <returns type="CCCardinalSplineTo"></returns>
function CCCardinalSplineTo:create() end
--- <summary>
--- CCPointArray* getPoints();
--- </summary>
--- <returns type="CCPointArray"></returns>
function CCCardinalSplineTo:getPoints() end
--- <summary>
--- CCActionInterval* reverse();
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCCardinalSplineTo:reverse() end
--- <summary>
--- //@js NA
--- inline void setPoints(CCPointArray* points)
--- </summary>
function CCCardinalSplineTo:setPoints() end

CCCardinalSplineBy = class(CCCardinalSplineTo)
--- <summary>
--- //creates an action with a Cardinal Spline array of points and tension 
--- //@code
--- //when thie function bound to js,the input params are changed
--- //js:var create(var duration,var pointTable,var tension)
--- //@endcode
--- static CCCardinalSplineBy* create(float duration, CCPointArray* points, float tension);
--- </summary>
--- <returns type="CCCardinalSplineBy"></returns>
function CCCardinalSplineBy:create() end
--- <summary>
--- CCActionInterval* reverse();
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCCardinalSplineBy:reverse() end

CCCatmullRomTo = class(CCCardinalSplineTo)
--- <summary>
--- //creates an action with a Cardinal Spline array of points and tension 
--- //@code
--- //when this function bound to js,the input params are changed
--- //js:var create(var dt,var pointTable)
--- //@endcode
--- static CCCatmullRomTo* create(float dt, CCPointArray* points);
--- </summary>
--- <returns type="CCCatmullRomTo"></returns>
function CCCatmullRomTo:create() end

CCCatmullRomBy = class(CCCardinalSplineBy)
--- <summary>
--- //creates an action with a Cardinal Spline array of points and tension 
--- //@code
--- //when this function bound to js,the input params are changed
--- //js:var create(var dt,var pointTable)
--- //@endcode
--- static CCCatmullRomBy* create(float dt, CCPointArray* points);
--- </summary>
--- <returns type="CCCatmullRomBy"></returns>
function CCCatmullRomBy:create() end

CCActionEase = class(CCActionInterval)
--- <summary>
--- //creates the action 
--- static CCActionEase* create(CCActionInterval *pAction);
--- </summary>
--- <returns type="CCActionEase"></returns>
function CCActionEase:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCActionEase:reverse() end

CCEaseRateAction = class(CCActionEase)
--- <summary>
--- //Creates the action with the inner action and the rate parameter 
--- static CCEaseRateAction* create(CCActionInterval* pAction, float fRate);
--- </summary>
--- <returns type="CCEaseRateAction"></returns>
function CCEaseRateAction:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseRateAction:reverse() end

CCEaseIn = class(CCEaseRateAction)
--- <summary>
--- //Creates the action with the inner action and the rate parameter 
--- static CCEaseIn* create(CCActionInterval* pAction, float fRate);
--- </summary>
--- <returns type="CCEaseIn"></returns>
function CCEaseIn:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseIn:reverse() end

CCEaseOut = class(CCEaseRateAction)
--- <summary>
--- //Creates the action with the inner action and the rate parameter 
--- static CCEaseOut* create(CCActionInterval* pAction, float fRate);
--- </summary>
--- <returns type="CCEaseOut"></returns>
function CCEaseOut:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseOut:reverse() end

CCEaseInOut = class(CCEaseRateAction)
--- <summary>
--- //Creates the action with the inner action and the rate parameter 
--- static CCEaseInOut* create(CCActionInterval* pAction, float fRate);
--- </summary>
--- <returns type="CCEaseInOut"></returns>
function CCEaseInOut:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseInOut:reverse() end

CCEaseExponentialIn = class(CCActionEase)
--- <summary>
--- //creates the action 
--- static CCEaseExponentialIn* create(CCActionInterval* pAction);
--- </summary>
--- <returns type="CCEaseExponentialIn"></returns>
function CCEaseExponentialIn:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseExponentialIn:reverse() end

CCEaseExponentialOut = class(CCActionEase)
--- <summary>
--- //creates the action 
--- static CCEaseExponentialOut* create(CCActionInterval* pAction);
--- </summary>
--- <returns type="CCEaseExponentialOut"></returns>
function CCEaseExponentialOut:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseExponentialOut:reverse() end

CCEaseExponentialInOut = class(CCActionEase)
--- <summary>
--- //creates the action 
--- static CCEaseExponentialInOut* create(CCActionInterval* pAction);
--- </summary>
--- <returns type="CCEaseExponentialInOut"></returns>
function CCEaseExponentialInOut:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseExponentialInOut:reverse() end

CCEaseSineIn = class(CCActionEase)
--- <summary>
--- //creates the action 
--- static CCEaseSineIn* create(CCActionInterval* pAction);
--- </summary>
--- <returns type="CCEaseSineIn"></returns>
function CCEaseSineIn:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseSineIn:reverse() end

CCEaseSineOut = class(CCActionEase)
--- <summary>
--- //creates the action 
--- static CCEaseSineOut* create(CCActionInterval* pAction);
--- </summary>
--- <returns type="CCEaseSineOut"></returns>
function CCEaseSineOut:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseSineOut:reverse() end

CCEaseSineInOut = class(CCActionEase)
--- <summary>
--- //creates the action 
--- static CCEaseSineInOut* create(CCActionInterval* pAction);
--- </summary>
--- <returns type="CCEaseSineInOut"></returns>
function CCEaseSineInOut:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseSineInOut:reverse() end

CCEaseElastic = class(CCActionEase)
--- <summary>
--- //Creates the action with the inner action and the period in radians (default is 0.3) 
--- static CCEaseElastic* create(CCActionInterval *pAction, float fPeriod);
--- </summary>
--- <returns type="CCEaseElastic"></returns>
function CCEaseElastic:create() end
--- <summary>
--- //get period of the wave in radians. default is 0.3 
--- inline float getPeriod(void);
--- </summary>
function CCEaseElastic:getPeriod() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseElastic:reverse() end
--- <summary>
--- //set period of the wave in radians. 
--- inline void setPeriod(float fPeriod);
--- </summary>
function CCEaseElastic:setPeriod() end

CCEaseElasticIn = class(CCEaseElastic)
--- <summary>
--- //Creates the action with the inner action and the period in radians (default is 0.3) 
--- static CCEaseElasticIn* create(CCActionInterval *pAction, float fPeriod);
--- </summary>
--- <returns type="CCEaseElasticIn"></returns>
function CCEaseElasticIn:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseElasticIn:reverse() end

CCEaseElasticOut = class(CCEaseElastic)
--- <summary>
--- //Creates the action with the inner action and the period in radians (default is 0.3) 
--- static CCEaseElasticOut* create(CCActionInterval *pAction, float fPeriod);
--- </summary>
--- <returns type="CCEaseElasticOut"></returns>
function CCEaseElasticOut:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseElasticOut:reverse() end

CCEaseElasticInOut = class(CCEaseElastic)
--- <summary>
--- //Creates the action with the inner action and the period in radians (default is 0.3) 
--- static CCEaseElasticInOut* create(CCActionInterval *pAction, float fPeriod);
--- </summary>
--- <returns type="CCEaseElasticInOut"></returns>
function CCEaseElasticInOut:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseElasticInOut:reverse() end

CCEaseBounce = class(CCActionEase)
--- <summary>
--- //creates the action 
--- static CCEaseBounce* create(CCActionInterval* pAction);
--- </summary>
--- <returns type="CCEaseBounce"></returns>
function CCEaseBounce:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseBounce:reverse() end

CCEaseBounceIn = class(CCEaseBounce)
--- <summary>
--- //creates the action 
--- static CCEaseBounceIn* create(CCActionInterval* pAction);
--- </summary>
--- <returns type="CCEaseBounceIn"></returns>
function CCEaseBounceIn:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseBounceIn:reverse() end

CCEaseBounceOut = class(CCEaseBounce)
--- <summary>
--- //creates the action 
--- static CCEaseBounceOut* create(CCActionInterval* pAction);
--- </summary>
--- <returns type="CCEaseBounceOut"></returns>
function CCEaseBounceOut:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseBounceOut:reverse() end

CCEaseBounceInOut = class(CCEaseBounce)
--- <summary>
--- //creates the action 
--- static CCEaseBounceInOut* create(CCActionInterval* pAction);
--- </summary>
--- <returns type="CCEaseBounceInOut"></returns>
function CCEaseBounceInOut:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseBounceInOut:reverse() end

CCEaseBackIn = class(CCActionEase)
--- <summary>
--- //creates the action 
--- static CCEaseBackIn* create(CCActionInterval* pAction);
--- </summary>
--- <returns type="CCEaseBackIn"></returns>
function CCEaseBackIn:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseBackIn:reverse() end

CCEaseBackOut = class(CCActionEase)
--- <summary>
--- //creates the action 
--- static CCEaseBackOut* create(CCActionInterval* pAction);
--- </summary>
--- <returns type="CCEaseBackOut"></returns>
function CCEaseBackOut:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseBackOut:reverse() end

CCEaseBackInOut = class(CCActionEase)
--- <summary>
--- //creates the action 
--- static CCEaseBackInOut* create(CCActionInterval* pAction);
--- </summary>
--- <returns type="CCEaseBackInOut"></returns>
function CCEaseBackInOut:create() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCEaseBackInOut:reverse() end

CCGridAction = class(CCActionInterval)
--- <summary>
--- //creates the action with size and duration 
--- static CCGridAction* create(float duration, const CCSize&amp; gridSize);
--- </summary>
--- <returns type="CCGridAction"></returns>
function CCGridAction:create() end
--- <summary>
--- //returns the grid 
--- virtual CCGridBase* getGrid(void);
--- </summary>
--- <returns type="CCGridBase"></returns>
function CCGridAction:getGrid() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCGridAction:reverse() end

CCAccelDeccelAmplitude = class(CCActionInterval)
--- <summary>
--- //creates the action with an inner action that has the amplitude property, and a duration time 
--- static CCAccelDeccelAmplitude* create(CCAction *pAction, float duration);
--- </summary>
--- <returns type="CCAccelDeccelAmplitude"></returns>
function CCAccelDeccelAmplitude:create() end
--- <summary>
--- //get amplitude rate 
--- inline float getRate(void);
--- </summary>
function CCAccelDeccelAmplitude:getRate() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCAccelDeccelAmplitude:reverse() end
--- <summary>
--- //set amplitude rate 
--- inline void setRate(float fRate);
--- </summary>
function CCAccelDeccelAmplitude:setRate() end

CCGrid3DAction = class(CCGridAction)
--- <summary>
--- //returns the grid 
--- virtual CCGridBase* getGrid(void);
--- </summary>
--- <returns type="CCGridBase"></returns>
function CCGrid3DAction:getGrid() end
--- <summary>
--- //returns the non-transformed vertex than belongs to certain position in the grid 
--- ccVertex3F originalVertex(const CCPoint&amp; position);
--- </summary>
--- <returns type="ccVertex3F"></returns>
function CCGrid3DAction:originalVertex() end
--- <summary>
--- //sets a new vertex to a certain position of the grid 
--- void setVertex(const CCPoint&amp; position, const ccVertex3F&amp; vertex);
--- </summary>
function CCGrid3DAction:setVertex() end
--- <summary>
--- //returns the vertex than belongs to certain position in the grid 
--- ccVertex3F vertex(const CCPoint&amp; position);
--- </summary>
--- <returns type="ccVertex3F"></returns>
function CCGrid3DAction:vertex() end

CCTiledGrid3DAction = class(CCGridAction)
--- <summary>
--- //returns the grid 
--- virtual CCGridBase* getGrid(void);
--- </summary>
--- <returns type="CCGridBase"></returns>
function CCTiledGrid3DAction:getGrid() end
--- <summary>
--- //returns the non-transformed tile that belongs to a certain position of the grid 
--- ccQuad3 originalTile(const CCPoint&amp; position);
--- </summary>
--- <returns type="ccQuad3"></returns>
function CCTiledGrid3DAction:originalTile() end
--- <summary>
--- //sets a new tile to a certain position of the grid 
--- void setTile(const CCPoint&amp; position, const ccQuad3&amp; coords);
--- </summary>
function CCTiledGrid3DAction:setTile() end
--- <summary>
--- //returns the tile that belongs to a certain position of the grid 
--- ccQuad3 tile(const CCPoint&amp; position);
--- </summary>
--- <returns type="ccQuad3"></returns>
function CCTiledGrid3DAction:tile() end

CCAccelAmplitude = class(CCActionInterval)
--- <summary>
--- //creates the action with an inner action that has the amplitude property, and a duration time 
--- static CCAccelAmplitude* create(CCAction *pAction, float duration);
--- </summary>
--- <returns type="CCAccelAmplitude"></returns>
function CCAccelAmplitude:create() end
--- <summary>
--- //get amplitude rate 
--- inline float getRate(void);
--- </summary>
function CCAccelAmplitude:getRate() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCAccelAmplitude:reverse() end
--- <summary>
--- //set amplitude rate 
--- inline void setRate(float fRate);
--- </summary>
function CCAccelAmplitude:setRate() end

CCDeccelAmplitude = class(CCActionInterval)
--- <summary>
--- //creates the action with an inner action that has the amplitude property, and a duration time 
--- static CCDeccelAmplitude* create(CCAction *pAction, float duration);
--- </summary>
--- <returns type="CCDeccelAmplitude"></returns>
function CCDeccelAmplitude:create() end
--- <summary>
--- //get amplitude rate 
--- inline float getRate(void);
--- </summary>
function CCDeccelAmplitude:getRate() end
--- <summary>
--- CCActionInterval* reverse(void);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCDeccelAmplitude:reverse() end
--- <summary>
--- //set amplitude rate 
--- inline void setRate(float fRate);
--- </summary>
function CCDeccelAmplitude:setRate() end

CCStopGrid = class(CCActionInstant)
--- <summary>
--- //Allocates and initializes the action 
--- static CCStopGrid* create(void);
--- </summary>
--- <returns type="CCStopGrid"></returns>
function CCStopGrid:create() end

CCReuseGrid = class(CCActionInstant)
--- <summary>
--- //creates an action with the number of times that the current grid will be reused 
--- static CCReuseGrid* create(int times);
--- </summary>
--- <returns type="CCReuseGrid"></returns>
function CCReuseGrid:create() end

CCWaves3D = class(CCGrid3DAction)
--- <summary>
--- //creates an action with duration, grid size, waves and amplitude 
--- static CCWaves3D* create(float duration, const CCSize&amp; gridSize, unsigned int waves, float amplitude);
--- </summary>
--- <returns type="CCWaves3D"></returns>
function CCWaves3D:create() end
--- <summary>
--- float getAmplitude(void);
--- </summary>
function CCWaves3D:getAmplitude() end
--- <summary>
--- float getAmplitudeRate(void);
--- </summary>
function CCWaves3D:getAmplitudeRate() end
--- <summary>
--- void setAmplitude(float fAmplitude);
--- </summary>
function CCWaves3D:setAmplitude() end
--- <summary>
--- void setAmplitudeRate(float fAmplitudeRate);
--- </summary>
function CCWaves3D:setAmplitudeRate() end

CCFlipX3D = class(CCGrid3DAction)
--- <summary>
--- //creates the action with duration 
--- static CCFlipX3D* create(float duration);
--- </summary>
--- <returns type="CCFlipX3D"></returns>
function CCFlipX3D:create() end

CCFlipY3D = class(CCFlipX3D)
--- <summary>
--- //creates the action with duration 
--- static CCFlipY3D* create(float duration);
--- </summary>
--- <returns type="CCFlipY3D"></returns>
function CCFlipY3D:create() end

CCLens3D = class(CCGrid3DAction)
--- <summary>
--- //creates the action with center position, radius, a grid size and duration 
--- static CCLens3D* create(float duration, const CCSize&amp; gridSize, const CCPoint&amp; position, float radius);
--- </summary>
--- <returns type="CCLens3D"></returns>
function CCLens3D:create() end
--- <summary>
--- //Get lens center position 
--- inline float getLensEffect(void);
--- </summary>
function CCLens3D:getLensEffect() end
--- <summary>
--- CCPoint getPosition(void);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCLens3D:getPosition() end
--- <summary>
--- //Set lens center position 
--- inline void setLensEffect(float fLensEffect);
--- </summary>
function CCLens3D:setLensEffect() end
--- <summary>
--- setPosition
--- </summary>
function CCLens3D:setPosition() end

CCRipple3D = class(CCGrid3DAction)
--- <summary>
--- //creates the action with radius, number of waves, amplitude, a grid size and duration 
--- static CCRipple3D* create(float duration, const CCSize&amp; gridSize, const CCPoint&amp; position, float radius, unsigned int waves, float amplitude);
--- </summary>
--- <returns type="CCRipple3D"></returns>
function CCRipple3D:create() end
--- <summary>
--- float getAmplitude(void);
--- </summary>
function CCRipple3D:getAmplitude() end
--- <summary>
--- float getAmplitudeRate(void);
--- </summary>
function CCRipple3D:getAmplitudeRate() end
--- <summary>
--- //get center position 
--- inline const CCPoint&amp; getPosition(void);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCRipple3D:getPosition() end
--- <summary>
--- void setAmplitude(float fAmplitude);
--- </summary>
function CCRipple3D:setAmplitude() end
--- <summary>
--- void setAmplitudeRate(float fAmplitudeRate);
--- </summary>
function CCRipple3D:setAmplitudeRate() end
--- <summary>
--- //set center position 
--- void setPosition(const CCPoint&amp; position);
--- </summary>
function CCRipple3D:setPosition() end

CCShaky3D = class(CCGrid3DAction)
--- <summary>
--- //creates the action with a range, shake Z vertices, a grid and duration 
--- static CCShaky3D* create(float duration, const CCSize&amp; gridSize, int range, bool shakeZ);
--- </summary>
--- <returns type="CCShaky3D"></returns>
function CCShaky3D:create() end

CCLiquid = class(CCGrid3DAction)
--- <summary>
--- //creates the action with amplitude, a grid and duration 
--- static CCLiquid* create(float duration, const CCSize&amp; gridSize, unsigned int waves, float amplitude);
--- </summary>
--- <returns type="CCLiquid"></returns>
function CCLiquid:create() end
--- <summary>
--- float getAmplitude(void);
--- </summary>
function CCLiquid:getAmplitude() end
--- <summary>
--- float getAmplitudeRate(void);
--- </summary>
function CCLiquid:getAmplitudeRate() end
--- <summary>
--- void setAmplitude(float fAmplitude);
--- </summary>
function CCLiquid:setAmplitude() end
--- <summary>
--- void setAmplitudeRate(float fAmplitudeRate);
--- </summary>
function CCLiquid:setAmplitudeRate() end

CCWaves = class(CCGrid3DAction)
--- <summary>
--- //initializes the action with amplitude, horizontal sin, vertical sin, a grid and duration 
--- static CCWaves* create(float duration, const CCSize&amp; gridSize, unsigned int waves, float amplitude, bool horizontal, bool vertical);
--- </summary>
--- <returns type="CCWaves"></returns>
function CCWaves:create() end
--- <summary>
--- float getAmplitude(void);
--- </summary>
function CCWaves:getAmplitude() end
--- <summary>
--- float getAmplitudeRate(void);
--- </summary>
function CCWaves:getAmplitudeRate() end
--- <summary>
--- void setAmplitude(float fAmplitude);
--- </summary>
function CCWaves:setAmplitude() end
--- <summary>
--- void setAmplitudeRate(float fAmplitudeRate);
--- </summary>
function CCWaves:setAmplitudeRate() end

CCTwirl = class(CCGrid3DAction)
--- <summary>
--- //creates the action with center position, number of twirls, amplitude, a grid size and duration 
--- static CCTwirl* create(float duration, const CCSize&amp; gridSize, CCPoint position, unsigned int twirls, float amplitude);
--- </summary>
--- <returns type="CCTwirl"></returns>
function CCTwirl:create() end
--- <summary>
--- float getAmplitude(void);
--- </summary>
function CCTwirl:getAmplitude() end
--- <summary>
--- float getAmplitudeRate(void);
--- </summary>
function CCTwirl:getAmplitudeRate() end
--- <summary>
--- //get twirl center 
--- inline const CCPoint&amp; getPosition(void);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCTwirl:getPosition() end
--- <summary>
--- void setAmplitude(float fAmplitude);
--- </summary>
function CCTwirl:setAmplitude() end
--- <summary>
--- void setAmplitudeRate(float fAmplitudeRate);
--- </summary>
function CCTwirl:setAmplitudeRate() end
--- <summary>
--- //set twirl center 
--- void setPosition(const CCPoint&amp; position);
--- </summary>
function CCTwirl:setPosition() end

CCActionManager = class(CCObject)
--- <summary>
--- //Adds an action with a target. 
--- //If the target is already present, then the action will be added to the existing target.
--- //If the target is not present, a new instance of this target will be created either paused or not, and the action will be added to the newly created target.
--- //When the target is paused, the queued actions won't be 'ticked'.
--- void addAction(CCAction *pAction, CCNode *pTarget, bool paused);
--- </summary>
function CCActionManager:addAction() end
--- <summary>
--- //Gets an action given its tag an a target
--- //@return the Action the with the given tag
--- CCAction* getActionByTag(unsigned int tag, CCObject *pTarget);
--- </summary>
--- <returns type="CCAction"></returns>
function CCActionManager:getActionByTag() end
--- <summary>
--- //Returns the numbers of actions that are running in a certain target. 
--- //Composable actions are counted as 1 action. Example:
--- //- If you are running 1 Sequence of 7 actions, it will return 1.
--- //- If you are running 7 Sequences of 2 actions, it will return 7.
--- unsigned int numberOfRunningActionsInTarget(CCObject *pTarget);
--- </summary>
function CCActionManager:numberOfRunningActionsInTarget() end
--- <summary>
--- //Pauses all running actions, returning a list of targets whose actions were paused.
--- CCSet* pauseAllRunningActions();
--- </summary>
--- <returns type="CCSet"></returns>
function CCActionManager:pauseAllRunningActions() end
--- <summary>
--- //Pauses the target: all running actions and newly added actions will be paused.
--- void pauseTarget(CCObject *pTarget);
--- </summary>
function CCActionManager:pauseTarget() end
--- <summary>
--- //Removes an action given an action reference.
--- void removeAction(CCAction *pAction);
--- </summary>
function CCActionManager:removeAction() end
--- <summary>
--- //Removes an action given its tag and the target 
--- void removeActionByTag(unsigned int tag, CCObject *pTarget);
--- </summary>
function CCActionManager:removeActionByTag() end
--- <summary>
--- //Removes all actions from all the targets.
--- void removeAllActions(void);
--- </summary>
function CCActionManager:removeAllActions() end
--- <summary>
--- //Removes all actions from a certain target.
--- //All the actions that belongs to the target will be removed.
--- void removeAllActionsFromTarget(CCObject *pTarget);
--- </summary>
function CCActionManager:removeAllActionsFromTarget() end
--- <summary>
--- //Resumes the target. All queued actions will be resumed.
--- void resumeTarget(CCObject *pTarget);
--- </summary>
function CCActionManager:resumeTarget() end
--- <summary>
--- //Resume a set of targets (convenience function to reverse a pauseAllRunningActions call)
--- void resumeTargets(CCSet *targetsToResume);
--- </summary>
function CCActionManager:resumeTargets() end

CCPageTurn3D = class(CCGrid3DAction)
--- <summary>
--- //create the action 
--- static CCPageTurn3D* create(float duration, const CCSize&amp; gridSize);
--- </summary>
--- <returns type="CCPageTurn3D"></returns>
function CCPageTurn3D:create() end

CCProgressTo = class(CCActionInterval)
--- <summary>
--- //Creates and initializes with a duration and a percent 
--- static CCProgressTo* create(float duration, float fPercent);
--- </summary>
--- <returns type="CCProgressTo"></returns>
function CCProgressTo:create() end

CCProgressFromTo = class(CCActionInterval)
--- <summary>
--- //Creates and initializes the action with a duration, a "from" percentage and a "to" percentage 
--- static CCProgressFromTo* create(float duration, float fFromPercentage, float fToPercentage);
--- </summary>
--- <returns type="CCProgressFromTo"></returns>
function CCProgressFromTo:create() end

CCShakyTiles3D = class(CCTiledGrid3DAction)
--- <summary>
--- //creates the action with a range, whether or not to shake Z vertices, a grid size, and duration 
--- static CCShakyTiles3D* create(float duration, const CCSize&amp; gridSize, int nRange, bool bShakeZ);
--- </summary>
--- <returns type="CCShakyTiles3D"></returns>
function CCShakyTiles3D:create() end

CCShatteredTiles3D = class(CCTiledGrid3DAction)
--- <summary>
--- //creates the action with a range, whether of not to shatter Z vertices, a grid size and duration 
--- static CCShatteredTiles3D* create(float duration, const CCSize&amp; gridSize, int nRange, bool bShatterZ);
--- </summary>
--- <returns type="CCShatteredTiles3D"></returns>
function CCShatteredTiles3D:create() end

CCShuffleTiles = class(CCTiledGrid3DAction)
--- <summary>
--- //creates the action with a random seed, the grid size and the duration 
--- static CCShuffleTiles* create(float duration, const CCSize&amp; gridSize, unsigned int seed);
--- </summary>
--- <returns type="CCShuffleTiles"></returns>
function CCShuffleTiles:create() end
--- <summary>
--- CCSize getDelta(CCSize pos);
--- </summary>
--- <returns type="CCSize"></returns>
function CCShuffleTiles:getDelta() end
--- <summary>
--- void placeTile(CCPoint pos, Tile *t);
--- </summary>
function CCShuffleTiles:placeTile() end
--- <summary>
--- void shuffle(unsigned int *pArray, int nLen);
--- </summary>
function CCShuffleTiles:shuffle() end

CCFadeOutTRTiles = class(CCTiledGrid3DAction)
--- <summary>
--- //creates the action with the grid size and the duration 
--- static CCFadeOutTRTiles* create(float duration, const CCSize&amp; gridSize);
--- </summary>
--- <returns type="CCFadeOutTRTiles"></returns>
function CCFadeOutTRTiles:create() end
--- <summary>
--- void transformTile(CCPoint pos, float distance);
--- </summary>
function CCFadeOutTRTiles:transformTile() end
--- <summary>
--- void turnOffTile(CCPoint pos);
--- </summary>
function CCFadeOutTRTiles:turnOffTile() end
--- <summary>
--- void turnOnTile(CCPoint pos);
--- </summary>
function CCFadeOutTRTiles:turnOnTile() end

CCFadeOutBLTiles = class(CCFadeOutTRTiles)
--- <summary>
--- //creates the action with the grid size and the duration 
--- static CCFadeOutBLTiles* create(float duration, const CCSize&amp; gridSize);
--- </summary>
--- <returns type="CCFadeOutBLTiles"></returns>
function CCFadeOutBLTiles:create() end

CCFadeOutUpTiles = class(CCFadeOutTRTiles)
--- <summary>
--- //creates the action with the grid size and the duration 
--- static CCFadeOutUpTiles* create(float duration, const CCSize&amp; gridSize);
--- </summary>
--- <returns type="CCFadeOutUpTiles"></returns>
function CCFadeOutUpTiles:create() end
--- <summary>
--- void transformTile(CCPoint pos, float distance);
--- </summary>
function CCFadeOutUpTiles:transformTile() end

CCFadeOutDownTiles = class(CCFadeOutUpTiles)
--- <summary>
--- //creates the action with the grid size and the duration 
--- static CCFadeOutDownTiles* create(float duration, const CCSize&amp; gridSize);
--- </summary>
--- <returns type="CCFadeOutDownTiles"></returns>
function CCFadeOutDownTiles:create() end

CCTurnOffTiles = class(CCTiledGrid3DAction)
--- <summary>
--- //creates the action with the grid size and the duration 
--- static CCTurnOffTiles* create(float duration, const CCSize&amp; gridSize);
--- 
--- //creates the action with a random seed, the grid size and the duration 
--- static CCTurnOffTiles* create(float duration, const CCSize&amp; gridSize, unsigned int seed);
--- </summary>
--- <returns type="CCTurnOffTiles"></returns>
function CCTurnOffTiles:create() end
--- <summary>
--- void shuffle(unsigned int *pArray, int nLen);
--- </summary>
function CCTurnOffTiles:shuffle() end
--- <summary>
--- void turnOffTile(CCPoint pos);
--- </summary>
function CCTurnOffTiles:turnOffTile() end
--- <summary>
--- void turnOnTile(CCPoint pos);
--- </summary>
function CCTurnOffTiles:turnOnTile() end

CCWavesTiles3D = class(CCTiledGrid3DAction)
--- <summary>
--- //creates the action with a number of waves, the waves amplitude, the grid size and the duration 
--- static CCWavesTiles3D* create(float duration, const CCSize&amp; gridSize, unsigned int waves, float amplitude);
--- </summary>
--- <returns type="CCWavesTiles3D"></returns>
function CCWavesTiles3D:create() end
--- <summary>
--- //waves amplitude 
--- inline float getAmplitude(void);
--- </summary>
function CCWavesTiles3D:getAmplitude() end
--- <summary>
--- //waves amplitude rate 
--- inline float getAmplitudeRate(void);
--- </summary>
function CCWavesTiles3D:getAmplitudeRate() end
--- <summary>
--- void setAmplitude(float fAmplitude);
--- </summary>
function CCWavesTiles3D:setAmplitude() end
--- <summary>
--- void setAmplitudeRate(float fAmplitudeRate);
--- </summary>
function CCWavesTiles3D:setAmplitudeRate() end

CCJumpTiles3D = class(CCTiledGrid3DAction)
--- <summary>
--- //creates the action with the number of jumps, the sin amplitude, the grid size and the duration 
--- static CCJumpTiles3D* create(float duration, const CCSize&amp; gridSize, unsigned int numberOfJumps, float amplitude);
--- </summary>
--- <returns type="CCJumpTiles3D"></returns>
function CCJumpTiles3D:create() end
--- <summary>
--- //amplitude of the sin
--- inline float getAmplitude(void);
--- </summary>
function CCJumpTiles3D:getAmplitude() end
--- <summary>
--- //amplitude rate 
--- inline float getAmplitudeRate(void);
--- </summary>
function CCJumpTiles3D:getAmplitudeRate() end
--- <summary>
--- void setAmplitude(float fAmplitude);
--- </summary>
function CCJumpTiles3D:setAmplitude() end
--- <summary>
--- void setAmplitudeRate(float fAmplitudeRate);
--- </summary>
function CCJumpTiles3D:setAmplitudeRate() end

CCSplitRows = class(CCTiledGrid3DAction)
--- <summary>
--- //creates the action with the number of rows to split and the duration 
--- static CCSplitRows* create(float duration, unsigned int nRows);
--- </summary>
--- <returns type="CCSplitRows"></returns>
function CCSplitRows:create() end

CCSplitCols = class(CCTiledGrid3DAction)
--- <summary>
--- //creates the action with the number of columns to split and the duration 
--- static CCSplitCols* create(float duration, unsigned int nCols);
--- </summary>
--- <returns type="CCSplitCols"></returns>
function CCSplitCols:create() end

CCAffineTransform = {}

CCAnimationFrame = class(CCObject)
--- <summary>
--- //@js ctor
--- CCAnimationFrame();
--- </summary>
function CCAnimationFrame:new() end
function CCAnimationFrame:new_local() end
--- <summary>
--- float getDelayUnits();
--- </summary>
function CCAnimationFrame:getDelayUnits() end
--- <summary>
--- CCSpriteFrame* getSpriteFrame();
--- </summary>
--- <returns type="CCSpriteFrame"></returns>
function CCAnimationFrame:getSpriteFrame() end
--- <summary>
--- CCDictionary*  getUserInfo();
--- </summary>
--- <returns type="CCDictionary"></returns>
function CCAnimationFrame:getUserInfo() end
--- <summary>
--- //initializes the animation frame with a spriteframe, number of delay units and a notification user info 
--- bool initWithSpriteFrame(CCSpriteFrame* spriteFrame, float delayUnits, CCDictionary* userInfo);
--- </summary>
function CCAnimationFrame:initWithSpriteFrame() end
--- <summary>
--- void setDelayUnits(float fDelayUnits);
--- </summary>
function CCAnimationFrame:setDelayUnits() end
--- <summary>
--- void setSpriteFrame(CCSpriteFrame* pSpFrame);
--- </summary>
function CCAnimationFrame:setSpriteFrame() end
--- <summary>
--- void setUserInfo(CCDictionary* pDict);
--- </summary>
function CCAnimationFrame:setUserInfo() end

CCAnimation = class(CCObject)
--- <summary>
--- //Adds a CCSpriteFrame to a CCAnimation.
--- //The frame will be added with one "delay unit".
--- void addSpriteFrame(CCSpriteFrame *pFrame);
--- </summary>
function CCAnimation:addSpriteFrame() end
--- <summary>
--- //Adds a frame with an image filename. Internally it will create a CCSpriteFrame and it will add it.
--- //The frame will be added with one "delay unit".
--- //Added to facilitate the migration from v0.8 to v0.9.
--- //@js addSpriteFrameWithFile
--- void addSpriteFrameWithFileName(const char *pszFileName);
--- </summary>
function CCAnimation:addSpriteFrameWithFileName() end
--- <summary>
--- //Adds a frame with a texture and a rect. Internally it will create a CCSpriteFrame and it will add it.
--- //The frame will be added with one "delay unit".
--- //Added to facilitate the migration from v0.8 to v0.9.
--- void addSpriteFrameWithTexture(CCTexture2D* pobTexture, const CCRect&amp; rect);
--- </summary>
function CCAnimation:addSpriteFrameWithTexture() end
--- <summary>
--- CCAnimation* copy();
--- </summary>
--- <returns type="CCAnimation"></returns>
function CCAnimation:copy() end
--- <summary>
--- //Creates an animation
--- //@since v0.99.5
--- static CCAnimation* create(void);
--- </summary>
--- <returns type="CCAnimation"></returns>
function CCAnimation:create() end
--- <summary>
--- static CCAnimation* createWithSpriteFrames(CCArray* arrayOfSpriteFrameNames, float delay);
--- static CCAnimation* createWithSpriteFrames(CCArray* arrayOfSpriteFrameNames);
--- </summary>
--- <returns type="CCAnimation"></returns>
function CCAnimation:createWithSpriteFrames() end
--- <summary>
--- float getDelayPerUnit();
--- </summary>
function CCAnimation:getDelayPerUnit() end
--- <summary>
--- float getDuration();
--- </summary>
function CCAnimation:getDuration() end
--- <summary>
--- CCArray* getFrames();
--- </summary>
--- <returns type="CCArray"></returns>
function CCAnimation:getFrames() end
--- <summary>
--- unsigned int getLoops();
--- </summary>
function CCAnimation:getLoops() end
--- <summary>
--- bool getRestoreOriginalFrame();
--- </summary>
function CCAnimation:getRestoreOriginalFrame() end
--- <summary>
--- float getTotalDelayUnits();
--- </summary>
function CCAnimation:getTotalDelayUnits() end
--- <summary>
--- void setDelayPerUnit(float fDelayPerUnits);
--- </summary>
function CCAnimation:setDelayPerUnit() end
--- <summary>
--- void setFrames(CCArray* pFrames);
--- </summary>
function CCAnimation:setFrames() end
--- <summary>
--- void setLoops(unsigned int uLoops);
--- </summary>
function CCAnimation:setLoops() end
--- <summary>
--- void setRestoreOriginalFrame(bool bRestoreFrame);
--- </summary>
function CCAnimation:setRestoreOriginalFrame() end

CCAnimationCache = class(CCObject)
--- <summary>
--- //Adds a CCAnimation with a name.
--- void addAnimation(CCAnimation *animation, const char * name);
--- </summary>
function CCAnimationCache:addAnimation() end
--- <summary>
--- //Adds an animation from an NSDictionary
--- //Make sure that the frames were previously loaded in the CCSpriteFrameCache.
--- //@param plist The path of the relative file,it use to find the plist path for load SpriteFrames.
--- //@since v1.1
--- void addAnimationsWithDictionary(CCDictionary* dictionary,const char* plist = NULL);
--- </summary>
function CCAnimationCache:addAnimationsWithDictionary() end
--- <summary>
--- //Adds an animation from a plist file.
--- //Make sure that the frames were previously loaded in the CCSpriteFrameCache.
--- //@since v1.1
--- //@js addAnimations
--- void addAnimationsWithFile(const char* plist);
--- </summary>
function CCAnimationCache:addAnimationsWithFile() end
--- <summary>
--- //Returns a CCAnimation that was previously added.
--- //If the name is not found it will return nil.
--- //You should retain the returned copy if you are going to use it.
--- //@js getAnimation
--- CCAnimation* animationByName(const char* name);
--- </summary>
--- <returns type="CCAnimation"></returns>
function CCAnimationCache:animationByName() end
--- <summary>
--- //Purges the cache. It releases all the CCAnimation objects and the shared instance.
--- static void purgeSharedAnimationCache(void);
--- </summary>
function CCAnimationCache:purgeSharedAnimationCache() end
--- <summary>
--- //Deletes a CCAnimation from the cache.
--- //@js removeAnimation
--- void removeAnimationByName(const char* name);
--- </summary>
function CCAnimationCache:removeAnimationByName() end
--- <summary>
--- //Returns the shared instance of the Animation cache 
--- //@js getInstance
--- static CCAnimationCache* sharedAnimationCache(void);
--- </summary>
--- <returns type="CCAnimationCache"></returns>
function CCAnimationCache:sharedAnimationCache() end

CCApplication = {}
--- <summary>
--- //@brief Get current language config
--- //@return Current language config
--- virtual ccLanguageType getCurrentLanguage();
--- </summary>
--- <returns type="ccLanguageType"></returns>
function CCApplication:getCurrentLanguage() end
--- <summary>
--- //@brief Get target platform
--- virtual TargetPlatform getTargetPlatform();
--- </summary>
--- <returns type="TargetPlatform"></returns>
function CCApplication:getTargetPlatform() end
--- <summary>
--- //@brief    Get current application instance.
--- //@return Current application instance pointer.
--- static CCApplication* sharedApplication();
--- </summary>
--- <returns type="CCApplication"></returns>
function CCApplication:sharedApplication() end

CCArmature = class(CCNodeRGBA)
--- <summary>
--- //@js ctor
--- CCArmature();
--- </summary>
function CCArmature:new() end
function CCArmature:new_local() end
--- <summary>
--- //Add a CCBone to this CCArmature,
--- //@param bone  The CCBone you want to add to CCArmature
--- //@param parentName   The parent CCBone's name you want to add to . If it's  NULL, then set CCArmature to its parent
--- virtual void addBone(CCBone *bone, const char *parentName);
--- </summary>
function CCArmature:addBone() end
--- <summary>
--- //This boundingBox will calculate all bones' boundingBox every time
--- virtual CCRect boundingBox();
--- </summary>
--- <returns type="CCRect"></returns>
function CCArmature:boundingBox() end
--- <summary>
--- //Change a bone's parent with the specified parent name.
--- //@param bone The bone you want to change parent
--- //@param parentName The new parent's name.
--- virtual void changeBoneParent(CCBone *bone, const char *parentName);
--- </summary>
function CCArmature:changeBoneParent() end
--- <summary>
--- //Allocates and initializes an armature.
--- //@return An initialized armature which is marked as "autorelease".
--- static CCArmature *create();
--- 
--- //Allocates an armature, and use the CCArmatureData named name in CCArmatureDataManager to initializes the armature.
--- //@param  name CCArmature will use the name to find the CCArmatureData to initializes it.
--- //@return A initialized armature which is marked as "autorelease".
--- static CCArmature *create(const char *name);
--- </summary>
--- <returns type="CCArmature"></returns>
function CCArmature:create() end
--- <summary>
--- virtual void draw();
--- </summary>
function CCArmature:draw() end
--- <summary>
--- virtual CCArmatureAnimation *getAnimation();
--- </summary>
--- <returns type="CCArmatureAnimation"></returns>
function CCArmature:getAnimation() end
--- <summary>
--- virtual CCArmatureData* getArmatureData(void) const;
--- </summary>
--- <returns type="CCArmatureData"></returns>
function CCArmature:getArmatureData() end
--- <summary>
--- virtual bool getArmatureTransformDirty(void) const;
--- </summary>
function CCArmature:getArmatureTransformDirty() end
--- <summary>
--- virtual CCBatchNode* getBatchNode(void) const;
--- </summary>
--- <returns type="CCBatchNode"></returns>
function CCArmature:getBatchNode() end
--- <summary>
--- ccBlendFunc getBlendFunc(void);
--- </summary>
--- <returns type="ccBlendFunc"></returns>
function CCArmature:getBlendFunc() end
--- <summary>
--- //Get a bone with the specified name
--- //@param name The bone's name you want to get
--- virtual CCBone *getBone(const char *name) const;
--- </summary>
--- <returns type="CCBone"></returns>
function CCArmature:getBone() end
--- <summary>
--- CCBone *getBoneAtPoint(float x, float y);
--- </summary>
--- <returns type="CCBone"></returns>
function CCArmature:getBoneAtPoint() end
--- <summary>
--- //Get CCArmature's bone dictionary
--- //@return CCArmature's bone dictionary
--- CCDictionary *getBoneDic();
--- </summary>
--- <returns type="CCDictionary"></returns>
function CCArmature:getBoneDic() end
--- <summary>
--- virtual std::string getName(void) const;
--- </summary>
--- <returns type="std::string"></returns>
function CCArmature:getName() end
--- <summary>
--- virtual CCBone* getParentBone(void);
--- </summary>
--- <returns type="CCBone"></returns>
function CCArmature:getParentBone() end
--- <summary>
--- virtual CCTextureAtlas* getTextureAtlas(void) const;
--- </summary>
--- <returns type="CCTextureAtlas"></returns>
function CCArmature:getTextureAtlas() end
--- <summary>
--- virtual CCTextureAtlas *getTexureAtlasWithTexture(CCTexture2D *texture);
--- </summary>
--- <returns type="CCTextureAtlas"></returns>
function CCArmature:getTexureAtlasWithTexture() end
--- <summary>
--- virtual float getVersion(void) const;
--- </summary>
function CCArmature:getVersion() end
--- <summary>
--- //Init the empty armature
--- virtual bool init();
--- 
--- //Init an armature with specified name
--- //@param name CCArmature name
--- virtual bool init(const char *name);
--- </summary>
function CCArmature:init() end
--- <summary>
--- virtual CCAffineTransform nodeToParentTransform();
--- </summary>
--- <returns type="CCAffineTransform"></returns>
function CCArmature:nodeToParentTransform() end
--- <summary>
--- //Remove a bone with the specified name. If recursion it will also remove child CCBone recursionly.
--- //@param bone The bone you want to remove
--- //@param recursion Determine whether remove the bone's child  recursion.
--- virtual void removeBone(CCBone *bone, bool recursion);
--- </summary>
function CCArmature:removeBone() end
--- <summary>
--- virtual void setAnimation(CCArmatureAnimation *animation);
--- </summary>
function CCArmature:setAnimation() end
--- <summary>
--- virtual void setArmatureData(CCArmatureData* var);
--- </summary>
function CCArmature:setArmatureData() end
--- <summary>
--- virtual void setBatchNode(CCBatchNode* var);
--- </summary>
function CCArmature:setBatchNode() end
--- <summary>
--- void setBlendFunc(ccBlendFunc blendFunc);
--- </summary>
function CCArmature:setBlendFunc() end
--- <summary>
--- virtual void setName(std::string var);
--- </summary>
function CCArmature:setName() end
--- <summary>
--- virtual void setParentBone(CCBone* var);
--- </summary>
function CCArmature:setParentBone() end
--- <summary>
--- virtual void setTextureAtlas(CCTextureAtlas* var);
--- </summary>
function CCArmature:setTextureAtlas() end
--- <summary>
--- virtual void setVersion(float var);
--- </summary>
function CCArmature:setVersion() end
--- <summary>
--- virtual void update(float dt);
--- </summary>
function CCArmature:update() end
--- <summary>
--- //Set contentsize and Calculate anchor point.
--- virtual void updateOffsetPoint();
--- </summary>
function CCArmature:updateOffsetPoint() end
--- <summary>
--- virtual void visit();
--- </summary>
function CCArmature:visit() end

CCArmatureAnimation = class(CCProcessBase)
--- <summary>
--- //@js ctor
--- CCArmatureAnimation();
--- </summary>
function CCArmatureAnimation:new() end
function CCArmatureAnimation:new_local() end
--- <summary>
--- //Create with a CCArmature
--- //@param armature The CCArmature CCArmatureAnimation will bind to
--- static CCArmatureAnimation *create(CCArmature *armature);
--- </summary>
--- <returns type="CCArmatureAnimation"></returns>
function CCArmatureAnimation:create() end
--- <summary>
--- virtual CCAnimationData* getAnimationData();
--- </summary>
--- <returns type="CCAnimationData"></returns>
function CCArmatureAnimation:getAnimationData() end
--- <summary>
--- //Get current movementID
--- //@return The name of current movement
--- std::string getCurrentMovementID();
--- </summary>
--- <returns type="std::string"></returns>
function CCArmatureAnimation:getCurrentMovementID() end
--- <summary>
--- //Get movement count
--- int getMovementCount();
--- </summary>
function CCArmatureAnimation:getMovementCount() end
--- <summary>
--- virtual float getSpeedScale() const;
--- </summary>
function CCArmatureAnimation:getSpeedScale() end
--- <summary>
--- //Returns a user assigned CCObject
--- //@return A user assigned CCObject
--- virtual CCObject* getUserObject();
--- </summary>
--- <returns type="CCObject"></returns>
function CCArmatureAnimation:getUserObject() end
--- <summary>
--- //Go to specified frame and pause current movement.
--- virtual void gotoAndPause(int frameIndex);
--- </summary>
function CCArmatureAnimation:gotoAndPause() end
--- <summary>
--- //Go to specified frame and play current movement.
--- //You need first switch to the movement you want to play, then call this function.
--- //example : playByIndex(0);
--- //gotoAndPlay(0);
--- //playByIndex(1);
--- //gotoAndPlay(0);
--- //gotoAndPlay(15);
--- virtual void gotoAndPlay(int frameIndex);
--- </summary>
function CCArmatureAnimation:gotoAndPlay() end
--- <summary>
--- //Init with a CCArmature
--- //@param armature The CCArmature CCArmatureAnimation will bind to
--- virtual bool init(CCArmature *armature);
--- </summary>
function CCArmatureAnimation:init() end
--- <summary>
--- //Pause the Process
--- virtual void pause();
--- </summary>
function CCArmatureAnimation:pause() end
--- <summary>
--- //Play animation by animation name.
--- //@param  animationName  The animation name you want to play
--- //@param  durationTo The frames between two animation changing-over.
--- //It's meaning is changing to this animation need how many frames
--- //-1 : use the value from CCMovementData get from flash design panel
--- //@param  durationTween  The frame count you want to play in the game.
--- //if  _durationTween is 80, then the animation will played 80 frames in a loop
--- //-1 : use the value from CCMovementData get from flash design panel
--- //@param  loop   Whether the animation is loop
--- //loop &lt; 0 : use the value from CCMovementData get from flash design panel
--- //loop = 0 : this animation is not loop
--- //loop > 0 : this animation is loop
--- //@param  tweenEasing CCTween easing is used for calculate easing effect
--- //TWEEN_EASING_MAX : use the value from CCMovementData get from flash design panel
--- //-1 : fade out
--- //0  : line
--- //1  : fade in
--- //2  : fade in and out
--- virtual void play(const char *animationName, int durationTo = -1, int durationTween = -1, int loop = -1, int tweenEasing = TWEEN_EASING_MAX);
--- </summary>
function CCArmatureAnimation:play() end
--- <summary>
--- void playWithIndex(int animationIndex,  int durationTo = -1, int durationTween = -1,  int loop = -1, int tweenEasing = TWEEN_EASING_MAX);
--- </summary>
function CCArmatureAnimation:playWithIndex() end
--- <summary>
--- //Resume the Process
--- virtual void resume();
--- </summary>
function CCArmatureAnimation:resume() end
--- <summary>
--- virtual void setAnimationData(CCAnimationData* var);
--- </summary>
function CCArmatureAnimation:setAnimationData() end
--- <summary>
--- //Scale animation play speed.
--- //@param animationScale Scale value
--- virtual void setSpeedScale(float speedScale);
--- </summary>
function CCArmatureAnimation:setSpeedScale() end
--- <summary>
--- //Returns a user assigned CCObject
--- //The UserObject will be retained once in this method,
--- //and the previous UserObject (if existed) will be relese.
--- //The UserObject will be released in destructure.
--- //@param A user assigned CCObject
--- virtual void setUserObject(CCObject *pUserObject);
--- </summary>
function CCArmatureAnimation:setUserObject() end
--- <summary>
--- //Stop the Process
--- virtual void stop();
--- </summary>
function CCArmatureAnimation:stop() end
--- <summary>
--- void update(float dt);
--- </summary>
function CCArmatureAnimation:update() end
--- <summary>
--- //@js NA
--- virtual ~CCArmatureAnimation(void);
--- </summary>
function CCArmatureAnimation:delete() end

CCArmatureDataManager = class(CCObject)
--- <summary>
--- //@brief	Add ArmatureFileInfo, it is managed by CCArmatureDataManager.
--- void addArmatureFileInfo(const char *configFilePath);
--- 
--- //@brief	Add ArmatureFileInfo, it is managed by CCArmatureDataManager.
--- void addArmatureFileInfo(const char *imagePath, const char *plistPath, const char *configFilePath);
--- </summary>
function CCArmatureDataManager:addArmatureFileInfo() end
--- <summary>
--- //@brief	Add sprite frame to CCSpriteFrameCache, it will save display name and it's relative image name
--- void addSpriteFrameFromFile(const char *plistPath, const char *imagePath, const char *configFilePath = "");
--- </summary>
function CCArmatureDataManager:addSpriteFrameFromFile() end
--- <summary>
--- //Init CCArmatureDataManager
--- virtual bool init();
--- </summary>
function CCArmatureDataManager:init() end
--- <summary>
--- //@brief	Juge whether or not need auto load sprite file
--- bool isAutoLoadSpriteFile();
--- </summary>
function CCArmatureDataManager:isAutoLoadSpriteFile() end
--- <summary>
--- static void purge();
--- </summary>
function CCArmatureDataManager:purge() end
--- <summary>
--- virtual void removeArmatureFileInfo(const char *configFilePath);
--- </summary>
function CCArmatureDataManager:removeArmatureFileInfo() end
--- <summary>
--- //@js getInstance
--- static CCArmatureDataManager *sharedArmatureDataManager();
--- </summary>
--- <returns type="CCArmatureDataManager"></returns>
function CCArmatureDataManager:sharedArmatureDataManager() end

CCArray = class(CCObject)
--- <summary>
--- //Add a certain object 
--- void addObject(CCObject* object);
--- </summary>
function CCArray:addObject() end
--- <summary>
--- //Add all elements of an existing array 
--- void addObjectsFromArray(CCArray* otherArray);
--- </summary>
function CCArray:addObjectsFromArray() end
--- <summary>
--- //Returns capacity of the array 
--- unsigned int capacity() const;
--- </summary>
function CCArray:capacity() end
--- <summary>
--- //Returns a Boolean value that indicates whether object is present in array. 
--- bool containsObject(CCObject* object) const;
--- </summary>
function CCArray:containsObject() end
--- <summary>
--- //Returns element count of the array 
--- unsigned int count() const;
--- </summary>
function CCArray:count() end
--- <summary>
--- //Create an array 
--- static CCArray* create();
--- 
--- //Create an array with some objects 
--- //@lua NA
--- static CCArray* create(CCObject* pObject, ...);
--- </summary>
--- <returns type="CCArray"></returns>
function CCArray:create() end
--- <summary>
--- //Create an array with an existing array 
--- static CCArray* createWithArray(CCArray* otherArray);
--- </summary>
--- <returns type="CCArray"></returns>
function CCArray:createWithArray() end
--- <summary>
--- //Create an array with capacity 
--- static CCArray* createWithCapacity(unsigned int capacity);
--- </summary>
--- <returns type="CCArray"></returns>
function CCArray:createWithCapacity() end
--- <summary>
--- //@brief   Generate a CCArray pointer by file
--- //@param   pFileName  The file name of *.plist file
--- //@return  The CCArray pointer generated from the file
--- static CCArray* createWithContentsOfFile(const char* pFileName);
--- </summary>
--- <returns type="CCArray"></returns>
function CCArray:createWithContentsOfFile() end
--- <summary>
--- //Create an array with one object 
--- static CCArray* createWithObject(CCObject* pObject);
--- </summary>
--- <returns type="CCArray"></returns>
function CCArray:createWithObject() end
--- <summary>
--- //Swap two elements 
--- void exchangeObject(CCObject* object1, CCObject* object2);
--- </summary>
function CCArray:exchangeObject() end
--- <summary>
--- //Swap two elements with certain indexes 
--- void exchangeObjectAtIndex(unsigned int index1, unsigned int index2);
--- </summary>
function CCArray:exchangeObjectAtIndex() end
--- <summary>
--- //Fast way to remove a certain object 
--- void fastRemoveObject(CCObject* object);
--- </summary>
function CCArray:fastRemoveObject() end
--- <summary>
--- //Fast way to remove an element with a certain index 
--- void fastRemoveObjectAtIndex(unsigned int index);
--- </summary>
function CCArray:fastRemoveObjectAtIndex() end
--- <summary>
--- //Returns index of a certain object, return UINT_MAX if doesn't contain the object 
--- unsigned int indexOfObject(CCObject* object) const;
--- </summary>
function CCArray:indexOfObject() end
--- <summary>
--- //Insert a certain object at a certain index 
--- void insertObject(CCObject* object, unsigned int index);
--- </summary>
function CCArray:insertObject() end
--- <summary>
--- //@since 1.1 
--- bool isEqualToArray(CCArray* pOtherArray);
--- </summary>
function CCArray:isEqualToArray() end
--- <summary>
--- //Returns last element 
--- CCObject* lastObject();
--- </summary>
--- <returns type="CCObject"></returns>
function CCArray:lastObject() end
--- <summary>
--- //Returns an element with a certain index 
--- CCObject* objectAtIndex(unsigned int index);
--- </summary>
--- <returns type="CCObject"></returns>
function CCArray:objectAtIndex() end
--- <summary>
--- //Returns a random element 
--- CCObject* randomObject();
--- </summary>
--- <returns type="CCObject"></returns>
function CCArray:randomObject() end
--- <summary>
--- void reduceMemoryFootprint();
--- </summary>
function CCArray:reduceMemoryFootprint() end
--- <summary>
--- //Remove all objects 
--- void removeAllObjects();
--- </summary>
function CCArray:removeAllObjects() end
--- <summary>
--- //Remove last object 
--- void removeLastObject(bool bReleaseObj = true);
--- </summary>
function CCArray:removeLastObject() end
--- <summary>
--- //Remove a certain object 
--- void removeObject(CCObject* object, bool bReleaseObj = true);
--- </summary>
function CCArray:removeObject() end
--- <summary>
--- //Remove an element with a certain index 
--- void removeObjectAtIndex(unsigned int index, bool bReleaseObj = true);
--- </summary>
function CCArray:removeObjectAtIndex() end
--- <summary>
--- //Remove all elements 
--- void removeObjectsInArray(CCArray* otherArray);
--- </summary>
function CCArray:removeObjectsInArray() end
--- <summary>
--- //Replace object at index with another object. 
--- void replaceObjectAtIndex(unsigned int uIndex, CCObject* pObject, bool bReleaseObject = true);
--- </summary>
function CCArray:replaceObjectAtIndex() end
--- <summary>
--- //Revers the array 
--- void reverseObjects();
--- </summary>
function CCArray:reverseObjects() end

CCAtlasNode = class(CCNodeRGBA)
--- <summary>
--- //creates a CCAtlasNode  with an Atlas file the width and height of each item and the quantity of items to render
--- static CCAtlasNode * create(const char* tile,unsigned int tileWidth, unsigned int tileHeight, unsigned int itemsToRender);
--- </summary>
--- <returns type="CCAtlasNode"></returns>
function CCAtlasNode:create() end
--- <summary>
--- ccColor3B getColor();
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCAtlasNode:getColor() end
--- <summary>
--- GLubyte getOpacity();
--- </summary>
--- <returns type="GLubyte"></returns>
function CCAtlasNode:getOpacity() end
--- <summary>
--- unsigned int getQuadsToDraw();
--- </summary>
function CCAtlasNode:getQuadsToDraw() end
--- <summary>
--- //returns the used texture
--- virtual CCTexture2D* getTexture(void);
--- </summary>
--- <returns type="CCTexture2D"></returns>
function CCAtlasNode:getTexture() end
--- <summary>
--- CCTextureAtlas* getTextureAtlas();
--- </summary>
--- <returns type="CCTextureAtlas"></returns>
function CCAtlasNode:getTextureAtlas() end
--- <summary>
--- bool isOpacityModifyRGB();
--- </summary>
function CCAtlasNode:isOpacityModifyRGB() end
--- <summary>
--- void setColor(ccColor3B color);
--- </summary>
function CCAtlasNode:setColor() end
--- <summary>
--- void setOpacity(GLubyte opacity);
--- </summary>
function CCAtlasNode:setOpacity() end
--- <summary>
--- void setOpacityModifyRGB(bool isOpacityModifyRGB);
--- </summary>
function CCAtlasNode:setOpacityModifyRGB() end
--- <summary>
--- void setQuadsToDraw(unsigned int quadsToDraw);
--- </summary>
function CCAtlasNode:setQuadsToDraw() end
--- <summary>
--- //sets a new texture. it will be retained
--- virtual void setTexture(CCTexture2D *texture);
--- </summary>
function CCAtlasNode:setTexture() end
--- <summary>
--- void setTextureAtlas(CCTextureAtlas* atlas);
--- </summary>
function CCAtlasNode:setTextureAtlas() end
--- <summary>
--- //updates the Atlas (indexed vertex array).
--- //Shall be overridden in subclasses
--- virtual void updateAtlasValues();
--- </summary>
function CCAtlasNode:updateAtlasValues() end

CCBatchNode = class(CCNode)
--- <summary>
--- //@js ctor
--- CCBatchNode();
--- </summary>
function CCBatchNode:new() end
function CCBatchNode:new_local() end
--- <summary>
--- virtual void addChild(CCNode *pChild);
--- virtual void addChild(CCNode *pChild, int zOrder);
--- virtual void addChild(CCNode *pChild, int zOrder, int tag);
--- </summary>
function CCBatchNode:addChild() end
--- <summary>
--- static CCBatchNode *create();
--- </summary>
--- <returns type="CCBatchNode"></returns>
function CCBatchNode:create() end
--- <summary>
--- virtual CCTextureAtlas *getTexureAtlasWithTexture(CCTexture2D *texture);
--- </summary>
--- <returns type="CCTextureAtlas"></returns>
function CCBatchNode:getTexureAtlasWithTexture() end
--- <summary>
--- virtual void removeChild(CCNode* child, bool cleanup);
--- </summary>
function CCBatchNode:removeChild() end

CCBone = class(CCNodeRGBA)
--- <summary>
--- //@js ctor
--- CCBone();
--- </summary>
function CCBone:new() end
function CCBone:new_local() end
--- <summary>
--- //Add a child to this bone, and it will let this child call setParent(CCBone *parent) function to set self to it's parent
--- //@param 	child  the child you want to add
--- void addChildBone(CCBone *child);
--- </summary>
function CCBone:addChildBone() end
--- <summary>
--- //Add display and use displayData to init the display.
--- //If index already have a display, then replace it.
--- //If index is current display index, then also change display to _index
--- //@param displayData it include the display information, like DisplayType.
--- //If you want to create a sprite display, then create a CCSpriteDisplayData param
--- //@param index the index of the display you want to replace or add to
--- //-1 : append display from back
--- void addDisplay(CCDisplayData *displayData, int index);
--- </summary>
function CCBone:addDisplay() end
--- <summary>
--- void changeDisplayWithIndex(int index, bool force);
--- </summary>
function CCBone:changeDisplayWithIndex() end
--- <summary>
--- //Allocates and initializes a bone.
--- //@return A initialized bone which is marked as "autorelease".
--- static CCBone *create();
--- 
--- //Allocates and initializes a bone.
--- //@param  name If name is not null, then set name to the bone's name
--- //@return A initialized bone which is marked as "autorelease".
--- static CCBone *create(const char *name);
--- </summary>
--- <returns type="CCBone"></returns>
function CCBone:create() end
--- <summary>
--- virtual CCArmature* getArmature(void);
--- </summary>
--- <returns type="CCArmature"></returns>
function CCBone:getArmature() end
--- <summary>
--- virtual CCArmature* getChildArmature(void);
--- </summary>
--- <returns type="CCArmature"></returns>
function CCBone:getChildArmature() end
--- <summary>
--- virtual CCDisplayManager* getDisplayManager(void) const;
--- </summary>
--- <returns type="CCDisplayManager"></returns>
function CCBone:getDisplayManager() end
--- <summary>
--- CCNode *getDisplayRenderNode();
--- </summary>
--- <returns type="CCNode"></returns>
function CCBone:getDisplayRenderNode() end
--- <summary>
--- DisplayType getDisplayRenderNodeType();
--- </summary>
--- <returns type="DisplayType"></returns>
function CCBone:getDisplayRenderNodeType() end
--- <summary>
--- virtual bool getIgnoreMovementBoneData(void);
--- </summary>
function CCBone:getIgnoreMovementBoneData() end
--- <summary>
--- virtual std::string getName(void) const;
--- </summary>
--- <returns type="std::string"></returns>
function CCBone:getName() end
--- <summary>
--- //Get parent bone
--- //@return parent bone
--- CCBone *getParentBone();
--- </summary>
--- <returns type="CCBone"></returns>
function CCBone:getParentBone() end
--- <summary>
--- CCTween *getTween();
--- </summary>
--- <returns type="CCTween"></returns>
function CCBone:getTween() end
--- <summary>
--- virtual CCBaseData* getWorldInfo(void) const;
--- </summary>
--- <returns type="CCBaseData"></returns>
function CCBone:getWorldInfo() end
--- <summary>
--- //Initializes an empty CCBone with nothing init.
--- virtual bool init();
--- 
--- //Initializes a CCBone with the specified name
--- //@param name CCBone's name.
--- virtual bool init(const char *name);
--- </summary>
function CCBone:init() end
--- <summary>
--- virtual inline bool isTransformDirty();
--- </summary>
function CCBone:isTransformDirty() end
--- <summary>
--- virtual CCAffineTransform nodeToArmatureTransform();
--- </summary>
--- <returns type="CCAffineTransform"></returns>
function CCBone:nodeToArmatureTransform() end
--- <summary>
--- virtual CCAffineTransform nodeToWorldTransform();
--- </summary>
--- <returns type="CCAffineTransform"></returns>
function CCBone:nodeToWorldTransform() end
--- <summary>
--- //Removes a child CCBone
--- //@param 	bone   the bone you want to remove
--- void removeChildBone(CCBone *bone, bool recursion);
--- </summary>
function CCBone:removeChildBone() end
--- <summary>
--- void removeDisplay(int index);
--- </summary>
function CCBone:removeDisplay() end
--- <summary>
--- //Remove itself from its parent.
--- //@param 	recursion    whether or not to remove childBone's display
--- void removeFromParent(bool recursion);
--- </summary>
function CCBone:removeFromParent() end
--- <summary>
--- virtual void setArmature(CCArmature* var);
--- </summary>
function CCBone:setArmature() end
--- <summary>
--- virtual void setChildArmature(CCArmature* var);
--- </summary>
function CCBone:setChildArmature() end
--- <summary>
--- void setColor(const ccColor3B &amp;color);
--- </summary>
function CCBone:setColor() end
--- <summary>
--- virtual void setDisplayManager(CCDisplayManager* var);
--- </summary>
function CCBone:setDisplayManager() end
--- <summary>
--- virtual void setIgnoreMovementBoneData(bool var);
--- </summary>
function CCBone:setIgnoreMovementBoneData() end
--- <summary>
--- virtual void setName(std::string var);
--- </summary>
function CCBone:setName() end
--- <summary>
--- void setOpacity(GLubyte opacity);
--- </summary>
function CCBone:setOpacity() end
--- <summary>
--- //Set parent bone.
--- //If parent is NUll, then also remove this bone from armature.
--- //It will not set the CCArmature, if you want to add the bone to a CCArmature, you should use CCArmature::addBone(CCBone *bone, const char* parentName).
--- //@param parent  the parent bone.
--- //NULL : remove this bone from armature
--- void setParentBone(CCBone *parent);
--- </summary>
function CCBone:setParentBone() end
--- <summary>
--- virtual inline void setTransformDirty(bool dirty);
--- </summary>
function CCBone:setTransformDirty() end
--- <summary>
--- virtual void setZOrder(int zOrder);
--- </summary>
function CCBone:setZOrder() end
--- <summary>
--- void update(float delta);
--- </summary>
function CCBone:update() end
--- <summary>
--- void updateColor();
--- </summary>
function CCBone:updateColor() end
--- <summary>
--- void updateDisplayedColor(const ccColor3B &amp;parentColor);
--- </summary>
function CCBone:updateDisplayedColor() end
--- <summary>
--- void updateDisplayedOpacity(GLubyte parentOpacity);
--- </summary>
function CCBone:updateDisplayedOpacity() end
--- <summary>
--- void updateZOrder();
--- </summary>
function CCBone:updateZOrder() end
--- <summary>
--- //@js NA
--- virtual ~CCBone(void);
--- </summary>
function CCBone:delete() end

CCCamera = class(CCObject)
--- <summary>
--- //@js ctor
--- CCCamera(void);
--- </summary>
function CCCamera:new() end
function CCCamera:new_local() end
--- <summary>
--- //@js NA
--- const char* description(void);
--- </summary>
function CCCamera:description() end
--- <summary>
--- //get the center vector values int points 
--- //@js NA
--- void getCenterXYZ(float *pCenterX, float *pCenterY, float *pCenterZ);
--- </summary>
function CCCamera:getCenterXYZ() end
--- <summary>
--- //get the eye vector values in points 
--- //@js NA
--- void getEyeXYZ(float *pEyeX, float *pEyeY, float *pEyeZ);
--- </summary>
function CCCamera:getEyeXYZ() end
--- <summary>
--- //get the up vector values 
--- //@js NA
--- void getUpXYZ(float *pUpX, float *pUpY, float *pUpZ);
--- </summary>
function CCCamera:getUpXYZ() end
--- <summary>
--- //returns the Z eye 
--- static float getZEye();
--- </summary>
function CCCamera:getZEye() end
--- <summary>
--- void init(void);
--- </summary>
function CCCamera:init() end
--- <summary>
--- //get the dirty value 
--- inline bool isDirty(void);
--- </summary>
function CCCamera:isDirty() end
--- <summary>
--- //Sets the camera using gluLookAt using its eye, center and up_vector 
--- void locate(void);
--- </summary>
function CCCamera:locate() end
--- <summary>
--- //sets the camera in the default position 
--- void restore(void);
--- </summary>
function CCCamera:restore() end
--- <summary>
--- //sets the center values in points 
--- //@js setCenter
--- void setCenterXYZ(float fCenterX, float fCenterY, float fCenterZ);
--- </summary>
function CCCamera:setCenterXYZ() end
--- <summary>
--- //sets the dirty value 
--- inline void setDirty(bool bValue);
--- </summary>
function CCCamera:setDirty() end
--- <summary>
--- //sets the eye values in points 
--- //@js setEye
--- void setEyeXYZ(float fEyeX, float fEyeY, float fEyeZ);
--- </summary>
function CCCamera:setEyeXYZ() end
--- <summary>
--- //sets the up values 
--- //@js setUp
--- void setUpXYZ(float fUpX, float fUpY, float fUpZ);
--- </summary>
function CCCamera:setUpXYZ() end

CCComAttribute = class(CCComponent)
--- <summary>
--- static CCComAttribute* create(void);
--- </summary>
--- <returns type="CCComAttribute"></returns>
function CCComAttribute:create() end
--- <summary>
--- bool   getBool(const char *key) const;
--- </summary>
function CCComAttribute:getBool() end
--- <summary>
--- const char* getCString(const char *key) const;
--- </summary>
function CCComAttribute:getCString() end
--- <summary>
--- float  getFloat(const char *key) const;
--- </summary>
function CCComAttribute:getFloat() end
--- <summary>
--- int    getInt(const char *key) const;
--- </summary>
function CCComAttribute:getInt() end
--- <summary>
--- virtual bool init();
--- </summary>
function CCComAttribute:init() end
--- <summary>
--- void setBool(const char *key, bool value);
--- </summary>
function CCComAttribute:setBool() end
--- <summary>
--- void setCString(const char *key, const char *value);
--- </summary>
function CCComAttribute:setCString() end
--- <summary>
--- void setFloat(const char *key, float value);
--- </summary>
function CCComAttribute:setFloat() end
--- <summary>
--- void setInt(const char *key, int value);
--- </summary>
function CCComAttribute:setInt() end

CCComAudio = class(CCComponent)
--- <summary>
--- static CCComAudio* create(void);
--- </summary>
--- <returns type="CCComAudio"></returns>
function CCComAudio:create() end
--- <summary>
--- float getBackgroundMusicVolume();
--- </summary>
function CCComAudio:getBackgroundMusicVolume() end
--- <summary>
--- float getEffectsVolume();
--- </summary>
function CCComAudio:getEffectsVolume() end
--- <summary>
--- const char* getFile();
--- </summary>
function CCComAudio:getFile() end
--- <summary>
--- virtual bool init();
--- </summary>
function CCComAudio:init() end
--- <summary>
--- bool isBackgroundMusicPlaying();
--- </summary>
function CCComAudio:isBackgroundMusicPlaying() end
--- <summary>
--- virtual bool isEnabled() const;
--- </summary>
function CCComAudio:isEnabled() end
--- <summary>
--- bool isLoop();
--- </summary>
function CCComAudio:isLoop() end
--- <summary>
--- void pauseAllEffects();
--- </summary>
function CCComAudio:pauseAllEffects() end
--- <summary>
--- void pauseBackgroundMusic();
--- </summary>
function CCComAudio:pauseBackgroundMusic() end
--- <summary>
--- void pauseEffect(unsigned int nSoundId);
--- </summary>
function CCComAudio:pauseEffect() end
--- <summary>
--- void playBackgroundMusic(const char* pszFilePath, bool bLoop);
--- void playBackgroundMusic(const char* pszFilePath);
--- void playBackgroundMusic();
--- </summary>
function CCComAudio:playBackgroundMusic() end
--- <summary>
--- unsigned int playEffect(const char* pszFilePath, bool bLoop);
--- unsigned int playEffect(const char* pszFilePath);
--- unsigned int playEffect();
--- </summary>
function CCComAudio:playEffect() end
--- <summary>
--- void preloadBackgroundMusic(const char* pszFilePath);
--- </summary>
function CCComAudio:preloadBackgroundMusic() end
--- <summary>
--- void preloadEffect(const char* pszFilePath);
--- </summary>
function CCComAudio:preloadEffect() end
--- <summary>
--- void resumeAllEffects();
--- </summary>
function CCComAudio:resumeAllEffects() end
--- <summary>
--- void resumeBackgroundMusic();
--- </summary>
function CCComAudio:resumeBackgroundMusic() end
--- <summary>
--- void resumeEffect(unsigned int nSoundId);
--- </summary>
function CCComAudio:resumeEffect() end
--- <summary>
--- void rewindBackgroundMusic();
--- </summary>
function CCComAudio:rewindBackgroundMusic() end
--- <summary>
--- void setBackgroundMusicVolume(float volume);
--- </summary>
function CCComAudio:setBackgroundMusicVolume() end
--- <summary>
--- void setEffectsVolume(float volume);
--- </summary>
function CCComAudio:setEffectsVolume() end
--- <summary>
--- virtual void setEnabled(bool b);
--- </summary>
function CCComAudio:setEnabled() end
--- <summary>
--- void setFile(const char* pszFilePath);
--- </summary>
function CCComAudio:setFile() end
--- <summary>
--- void setLoop(bool bLoop);
--- </summary>
function CCComAudio:setLoop() end
--- <summary>
--- void stopAllEffects();
--- </summary>
function CCComAudio:stopAllEffects() end
--- <summary>
--- void stopBackgroundMusic(bool bReleaseData);
--- void stopBackgroundMusic();
--- </summary>
function CCComAudio:stopBackgroundMusic() end
--- <summary>
--- void stopEffect(unsigned int nSoundId);
--- </summary>
function CCComAudio:stopEffect() end
--- <summary>
--- void unloadEffect(const char* pszFilePath);
--- </summary>
function CCComAudio:unloadEffect() end
--- <summary>
--- bool willPlayBackgroundMusic();
--- </summary>
function CCComAudio:willPlayBackgroundMusic() end

CCComController = class(CCComponent)
--- <summary>
--- //@js ctor
--- CCComController(void);
--- </summary>
function CCComController:new() end
function CCComController:new_local() end
--- <summary>
--- static CCComController* create(void);
--- </summary>
--- <returns type="CCComController"></returns>
function CCComController:create() end
--- <summary>
--- virtual bool init();
--- </summary>
function CCComController:init() end
--- <summary>
--- virtual bool isEnabled() const;
--- </summary>
function CCComController:isEnabled() end
--- <summary>
--- virtual void setEnabled(bool b);
--- </summary>
function CCComController:setEnabled() end
--- <summary>
--- virtual void update(float delta);
--- </summary>
function CCComController:update() end
--- <summary>
--- //@js NA
--- virtual ~CCComController(void);
--- </summary>
function CCComController:delete() end

CCComRender = class(CCComponent)
--- <summary>
--- static CCComRender* create(CCNode *pNode, const char *comName);
--- </summary>
--- <returns type="CCComRender"></returns>
function CCComRender:create() end
--- <summary>
--- CCNode* getNode();
--- </summary>
--- <returns type="CCNode"></returns>
function CCComRender:getNode() end
--- <summary>
--- void setNode(CCNode *pNode);
--- </summary>
function CCComRender:setNode() end

CCComponent = class(CCObject)
--- <summary>
--- static CCComponent* create(void);
--- </summary>
--- <returns type="CCComponent"></returns>
function CCComponent:create() end
--- <summary>
--- const char* getName() const;
--- </summary>
function CCComponent:getName() end
--- <summary>
--- CCNode* getOwner() const;
--- </summary>
--- <returns type="CCNode"></returns>
function CCComponent:getOwner() end
--- <summary>
--- virtual bool init();
--- </summary>
function CCComponent:init() end
--- <summary>
--- virtual bool isEnabled() const;
--- </summary>
function CCComponent:isEnabled() end
--- <summary>
--- virtual bool serialize(void* r);
--- </summary>
function CCComponent:serialize() end
--- <summary>
--- virtual void setEnabled(bool b);
--- </summary>
function CCComponent:setEnabled() end
--- <summary>
--- void setName(const char *pName);
--- </summary>
function CCComponent:setName() end
--- <summary>
--- void setOwner(CCNode *pOwner);
--- </summary>
function CCComponent:setOwner() end
--- <summary>
--- virtual void update(float delta);
--- </summary>
function CCComponent:update() end
--- <summary>
--- //@js NA
--- //@lua NA
--- virtual ~CCComponent(void);
--- </summary>
function CCComponent:delete() end

CCControl = class(CCLayerRGBA)
--- <summary>
--- //@js ctor
--- CCControl();
--- </summary>
function CCControl:new() end
function CCControl:new_local() end
--- <summary>
--- //@js NA
--- void addHandleOfControlEvent(int nFunID,CCControlEvent controlEvent);
--- </summary>
function CCControl:addHandleOfControlEvent() end
--- <summary>
--- //Adds a target and action for a particular event (or events) to an internal
--- //dispatch table.
--- //The action message may optionnaly include the sender and the event as 
--- //parameters, in that order.
--- //When you call this method, target is not retained.
--- //@param target The target object that is, the object to which the action 
--- //message is sent. It cannot be nil. The target is not retained.
--- //@param action A selector identifying an action message. It cannot be NULL.
--- //@param controlEvents A bitmask specifying the control events for which the 
--- //action message is sent. See "CCControlEvent" for bitmask constants.
--- virtual void addTargetWithActionForControlEvents(CCObject* target, SEL_CCControlHandler action, CCControlEvent controlEvents);
--- </summary>
function CCControl:addTargetWithActionForControlEvents() end
--- <summary>
--- virtual CCControlState getState() const; 
--- </summary>
--- <returns type="CCControlState"></returns>
function CCControl:getState() end
--- <summary>
--- //Returns a point corresponding to the touh location converted into the 
--- //control space coordinates.
--- //@param touch A CCTouch object that represents a touch.
--- virtual CCPoint getTouchLocation(CCTouch* touch);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCControl:getTouchLocation() end
--- <summary>
--- bool hasVisibleParents();
--- </summary>
function CCControl:hasVisibleParents() end
--- <summary>
--- virtual bool init(void);
--- </summary>
function CCControl:init() end
--- <summary>
--- virtual bool isEnabled();
--- </summary>
function CCControl:isEnabled() end
--- <summary>
--- virtual bool isHighlighted();
--- </summary>
function CCControl:isHighlighted() end
--- <summary>
--- virtual bool isOpacityModifyRGB();
--- </summary>
function CCControl:isOpacityModifyRGB() end
--- <summary>
--- virtual bool isSelected();
--- </summary>
function CCControl:isSelected() end
--- <summary>
--- //Returns a boolean value that indicates whether a touch is inside the bounds
--- //of the receiver. The given touch must be relative to the world.
--- //@param touch A CCTouch object that represents a touch.
--- //@return YES whether a touch is inside the receiver's rect.
--- virtual bool isTouchInside(CCTouch * touch);
--- </summary>
function CCControl:isTouchInside() end
--- <summary>
--- //Updates the control layout using its current internal state.
--- virtual void needsLayout();
--- </summary>
function CCControl:needsLayout() end
--- <summary>
--- //@js NA
--- //@lua NA
--- virtual void onEnter();
--- </summary>
function CCControl:onEnter() end
--- <summary>
--- //@js NA
--- //@lua NA
--- virtual void onExit();
--- </summary>
function CCControl:onExit() end
--- <summary>
--- virtual void registerWithTouchDispatcher();
--- </summary>
function CCControl:registerWithTouchDispatcher() end
--- <summary>
--- //@js NA
--- void removeHandleOfControlEvent(CCControlEvent controlEvent);
--- </summary>
function CCControl:removeHandleOfControlEvent() end
--- <summary>
--- //Removes a target and action for a particular event (or events) from an 
--- //internal dispatch table.
--- //@param target The target object, that is, the object to which the action 
--- //message is sent. Pass nil to remove all targets paired with action and the
--- //specified control events.
--- //@param action A selector identifying an action message. Pass NULL to remove
--- //all action messages paired with target.
--- //@param controlEvents A bitmask specifying the control events associated with
--- //target and action. See "CCControlEvent" for bitmask constants.
--- virtual void removeTargetWithActionForControlEvents(CCObject* target, SEL_CCControlHandler action, CCControlEvent controlEvents);
--- </summary>
function CCControl:removeTargetWithActionForControlEvents() end
--- <summary>
--- //Sends action messages for the given control events.
--- //@param controlEvents A bitmask whose set flags specify the control events for
--- //which action messages are sent. See "CCControlEvent" for bitmask constants.
--- virtual void sendActionsForControlEvents(CCControlEvent controlEvents);
--- </summary>
function CCControl:sendActionsForControlEvents() end
--- <summary>
--- //Tells whether the control is enabled. 
--- virtual void setEnabled(bool bEnabled);
--- </summary>
function CCControl:setEnabled() end
--- <summary>
--- //A Boolean value that determines whether the control is highlighted. 
--- virtual void setHighlighted(bool bHighlighted);
--- </summary>
function CCControl:setHighlighted() end
--- <summary>
--- virtual void setOpacityModifyRGB(bool bOpacityModifyRGB); 
--- </summary>
function CCControl:setOpacityModifyRGB() end
--- <summary>
--- //A Boolean value that determines the control selected state. 
--- virtual void setSelected(bool bSelected);
--- </summary>
function CCControl:setSelected() end
--- <summary>
--- //@js NA
--- //@lua NA
--- virtual ~CCControl();
--- </summary>
function CCControl:delete() end

CCControlButton = class(CCControl)
--- <summary>
--- CCControlButton();
--- </summary>
function CCControlButton:new() end
function CCControlButton:new_local() end
--- <summary>
--- virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCControlButton:ccTouchBegan() end
--- <summary>
--- virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCControlButton:ccTouchCancelled() end
--- <summary>
--- virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCControlButton:ccTouchEnded() end
--- <summary>
--- virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCControlButton:ccTouchMoved() end
--- <summary>
--- static CCControlButton* create(CCNode* label, CCScale9Sprite* backgroundSprite);
--- static CCControlButton* create(std::string title, const char * fontName, float fontSize);
--- static CCControlButton* create(CCScale9Sprite* sprite);
--- static CCControlButton* create();
--- </summary>
--- <returns type="CCControlButton"></returns>
function CCControlButton:create() end
--- <summary>
--- bool doesAdjustBackgroundImage();
--- </summary>
function CCControlButton:doesAdjustBackgroundImage() end
--- <summary>
--- virtual CCScale9Sprite* getBackgroundSprite();
--- </summary>
--- <returns type="CCScale9Sprite"></returns>
function CCControlButton:getBackgroundSprite() end
--- <summary>
--- virtual CCDictionary* getBackgroundSpriteDispatchTable();
--- </summary>
--- <returns type="CCDictionary"></returns>
function CCControlButton:getBackgroundSpriteDispatchTable() end
--- <summary>
--- //Returns the background sprite used for a state.
--- //@param state The state that uses the background sprite. Possible values are
--- //described in "CCControlState".
--- virtual CCScale9Sprite* getBackgroundSpriteForState(CCControlState state);
--- </summary>
--- <returns type="CCScale9Sprite"></returns>
function CCControlButton:getBackgroundSpriteForState() end
--- <summary>
--- virtual CCString* getCurrentTitle();
--- </summary>
--- <returns type="CCString"></returns>
function CCControlButton:getCurrentTitle() end
--- <summary>
--- virtual const ccColor3B&amp; getCurrentTitleColor() const;
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCControlButton:getCurrentTitleColor() end
--- <summary>
--- virtual int getHorizontalOrigin() const;
--- </summary>
function CCControlButton:getHorizontalOrigin() end
--- <summary>
--- virtual CCPoint   getLabelAnchorPoint();
--- </summary>
--- <returns type="CCPoint"></returns>
function CCControlButton:getLabelAnchorPoint() end
--- <summary>
--- virtual GLubyte getOpacity(void);
--- </summary>
--- <returns type="GLubyte"></returns>
function CCControlButton:getOpacity() end
--- <summary>
--- virtual CCSize getPreferredSize();
--- </summary>
--- <returns type="CCSize"></returns>
function CCControlButton:getPreferredSize() end
--- <summary>
--- virtual const char * getTitleBMFontForState(CCControlState state);
--- </summary>
function CCControlButton:getTitleBMFontForState() end
--- <summary>
--- virtual CCDictionary* getTitleColorDispatchTable();
--- </summary>
--- <returns type="CCDictionary"></returns>
function CCControlButton:getTitleColorDispatchTable() end
--- <summary>
--- virtual const ccColor3B getTitleColorForState(CCControlState state);
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCControlButton:getTitleColorForState() end
--- <summary>
--- virtual CCDictionary* getTitleDispatchTable();
--- </summary>
--- <returns type="CCDictionary"></returns>
function CCControlButton:getTitleDispatchTable() end
--- <summary>
--- //Returns the title used for a state.
--- //@param state The state that uses the title. Possible values are described in
--- //"CCControlState".
--- //@return The title for the specified state.
--- virtual CCString* getTitleForState(CCControlState state);
--- </summary>
--- <returns type="CCString"></returns>
function CCControlButton:getTitleForState() end
--- <summary>
--- virtual CCNode* getTitleLabel();
--- </summary>
--- <returns type="CCNode"></returns>
function CCControlButton:getTitleLabel() end
--- <summary>
--- virtual CCDictionary* getTitleLabelDispatchTable();
--- </summary>
--- <returns type="CCDictionary"></returns>
function CCControlButton:getTitleLabelDispatchTable() end
--- <summary>
--- //Returns the title label used for a state.
--- //@param state The state that uses the title label. Possible values are described
--- //in "CCControlState".
--- virtual CCNode* getTitleLabelForState(CCControlState state);
--- </summary>
--- <returns type="CCNode"></returns>
function CCControlButton:getTitleLabelForState() end
--- <summary>
--- virtual const char * getTitleTTFForState(CCControlState state);
--- </summary>
function CCControlButton:getTitleTTFForState() end
--- <summary>
--- virtual float getTitleTTFSizeForState(CCControlState state);
--- </summary>
function CCControlButton:getTitleTTFSizeForState() end
--- <summary>
--- virtual int getVerticalMargin() const;
--- </summary>
function CCControlButton:getVerticalMargin() end
--- <summary>
--- virtual bool   getZoomOnTouchDown();
--- </summary>
function CCControlButton:getZoomOnTouchDown() end
--- <summary>
--- virtual bool init();
--- </summary>
function CCControlButton:init() end
--- <summary>
--- virtual bool initWithBackgroundSprite(CCScale9Sprite* sprite);
--- </summary>
function CCControlButton:initWithBackgroundSprite() end
--- <summary>
--- virtual bool initWithLabelAndBackgroundSprite(CCNode* label, CCScale9Sprite* backgroundSprite);
--- </summary>
function CCControlButton:initWithLabelAndBackgroundSprite() end
--- <summary>
--- virtual bool initWithTitleAndFontNameAndFontSize(std::string title, const char * fontName, float fontSize);
--- </summary>
function CCControlButton:initWithTitleAndFontNameAndFontSize() end
--- <summary>
--- bool isPushed();
--- </summary>
function CCControlButton:isPushed() end
--- <summary>
--- virtual void needsLayout(void);
--- </summary>
function CCControlButton:needsLayout() end
--- <summary>
--- void setAdjustBackgroundImage(bool adjustBackgroundImage);
--- </summary>
function CCControlButton:setAdjustBackgroundImage() end
--- <summary>
--- virtual void setBackgroundSprite(CCScale9Sprite* var);
--- </summary>
function CCControlButton:setBackgroundSprite() end
--- <summary>
--- virtual void setBackgroundSpriteDispatchTable(CCDictionary* var);
--- </summary>
function CCControlButton:setBackgroundSpriteDispatchTable() end
--- <summary>
--- //Sets the background sprite to use for the specified button state.
--- //@param sprite The background sprite to use for the specified state.
--- //@param state The state that uses the specified image. The values are described
--- //in "CCControlState".
--- virtual void setBackgroundSpriteForState(CCScale9Sprite* sprite, CCControlState state);
--- </summary>
function CCControlButton:setBackgroundSpriteForState() end
--- <summary>
--- //Sets the background spriteFrame to use for the specified button state.
--- //@param spriteFrame The background spriteFrame to use for the specified state.
--- //@param state The state that uses the specified image. The values are described
--- //in "CCControlState".
--- virtual void setBackgroundSpriteFrameForState(CCSpriteFrame * spriteFrame, CCControlState state);
--- </summary>
function CCControlButton:setBackgroundSpriteFrameForState() end
--- <summary>
--- virtual void setEnabled(bool enabled);
--- </summary>
function CCControlButton:setEnabled() end
--- <summary>
--- virtual void setHighlighted(bool enabled);
--- </summary>
function CCControlButton:setHighlighted() end
--- <summary>
--- virtual void      setLabelAnchorPoint(CCPoint var);
--- </summary>
function CCControlButton:setLabelAnchorPoint() end
--- <summary>
--- virtual void setMargins(int marginH, int marginV);
--- </summary>
function CCControlButton:setMargins() end
--- <summary>
--- virtual void    setOpacity(GLubyte var);
--- </summary>
function CCControlButton:setOpacity() end
--- <summary>
--- virtual void   setPreferredSize(CCSize var);
--- </summary>
function CCControlButton:setPreferredSize() end
--- <summary>
--- virtual void setSelected(bool enabled);
--- </summary>
function CCControlButton:setSelected() end
--- <summary>
--- //Sets the font of the label, changes the label to a CCLabelBMFont if neccessary.
--- //@param fntFile The name of the font to change to
--- //@param state The state that uses the specified fntFile. The values are described
--- //in "CCControlState".
--- virtual void setTitleBMFontForState(const char * fntFile, CCControlState state);
--- </summary>
function CCControlButton:setTitleBMFontForState() end
--- <summary>
--- virtual void setTitleColorDispatchTable(CCDictionary* var);
--- </summary>
function CCControlButton:setTitleColorDispatchTable() end
--- <summary>
--- //Sets the color of the title to use for the specified state.
--- //@param color The color of the title to use for the specified state.
--- //@param state The state that uses the specified color. The values are described
--- //in "CCControlState".
--- virtual void setTitleColorForState(ccColor3B color, CCControlState state);
--- </summary>
function CCControlButton:setTitleColorForState() end
--- <summary>
--- virtual void setTitleDispatchTable(CCDictionary* var);
--- </summary>
function CCControlButton:setTitleDispatchTable() end
--- <summary>
--- //Sets the title string to use for the specified state.
--- //If a property is not specified for a state, the default is to use
--- //the CCButtonStateNormal value.
--- //@param title The title string to use for the specified state.
--- //@param state The state that uses the specified title. The values are described
--- //in "CCControlState".
--- virtual void setTitleForState(CCString* title, CCControlState state);
--- </summary>
function CCControlButton:setTitleForState() end
--- <summary>
--- virtual void setTitleLabel(CCNode* var);
--- </summary>
function CCControlButton:setTitleLabel() end
--- <summary>
--- virtual void setTitleLabelDispatchTable(CCDictionary* var);
--- </summary>
function CCControlButton:setTitleLabelDispatchTable() end
--- <summary>
--- //Sets the title label to use for the specified state.
--- //If a property is not specified for a state, the default is to use
--- //the CCButtonStateNormal value.
--- //@param title The title label to use for the specified state.
--- //@param state The state that uses the specified title. The values are described
--- //in "CCControlState".
--- virtual void setTitleLabelForState(CCNode* label, CCControlState state);
--- </summary>
function CCControlButton:setTitleLabelForState() end
--- <summary>
--- virtual void setTitleTTFForState(const char * fntFile, CCControlState state);
--- </summary>
function CCControlButton:setTitleTTFForState() end
--- <summary>
--- virtual void setTitleTTFSizeForState(float size, CCControlState state);
--- </summary>
function CCControlButton:setTitleTTFSizeForState() end
--- <summary>
--- virtual void   setZoomOnTouchDown(bool  var);
--- </summary>
function CCControlButton:setZoomOnTouchDown() end
--- <summary>
--- virtual ~CCControlButton();
--- </summary>
function CCControlButton:delete() end

CCControlColourPicker = class(CCControl)
--- <summary>
--- CCControlColourPicker();
--- </summary>
function CCControlColourPicker:new() end
function CCControlColourPicker:new_local() end
--- <summary>
--- void colourSliderValueChanged(CCObject * sender, CCControlEvent controlEvent);
--- </summary>
function CCControlColourPicker:colourSliderValueChanged() end
--- <summary>
--- static CCControlColourPicker* create();
--- </summary>
--- <returns type="CCControlColourPicker"></returns>
function CCControlColourPicker:create() end
--- <summary>
--- virtual CCSprite*  getBackground() const; 
--- </summary>
--- <returns type="CCSprite"></returns>
function CCControlColourPicker:getBackground() end
--- <summary>
--- virtual CCControlHuePicker*  getHuePicker() const; 
--- </summary>
--- <returns type="CCControlHuePicker"></returns>
function CCControlColourPicker:getHuePicker() end
--- <summary>
--- virtual CCControlSaturationBrightnessPicker*  getcolourPicker() const; 
--- </summary>
--- <returns type="CCControlSaturationBrightnessPicker"></returns>
function CCControlColourPicker:getcolourPicker() end
--- <summary>
--- void hueSliderValueChanged(CCObject * sender, CCControlEvent controlEvent);
--- </summary>
function CCControlColourPicker:hueSliderValueChanged() end
--- <summary>
--- virtual bool init();
--- </summary>
function CCControlColourPicker:init() end
--- <summary>
--- virtual void setBackground(CCSprite*  var);
--- </summary>
function CCControlColourPicker:setBackground() end
--- <summary>
--- virtual void setColor(const ccColor3B&amp; colorValue);
--- </summary>
function CCControlColourPicker:setColor() end
--- <summary>
--- virtual void setEnabled(bool bEnabled);
--- </summary>
function CCControlColourPicker:setEnabled() end
--- <summary>
--- virtual void setHuePicker(CCControlHuePicker*  var);
--- </summary>
function CCControlColourPicker:setHuePicker() end
--- <summary>
--- virtual void setcolourPicker(CCControlSaturationBrightnessPicker*  var);
--- </summary>
function CCControlColourPicker:setcolourPicker() end
--- <summary>
--- virtual ~CCControlColourPicker();
--- </summary>
function CCControlColourPicker:delete() end

CCControlPotentiometer = class(CCControl)
--- <summary>
--- CCControlPotentiometer();
--- </summary>
function CCControlPotentiometer:new() end
function CCControlPotentiometer:new_local() end
--- <summary>
--- //Returns the angle in degree between line1 and line2. 
--- float angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint(CCPoint beginLineA, CCPoint endLineA,CCPoint beginLineB,CCPoint endLineB);
--- </summary>
function CCControlPotentiometer:angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint() end
--- <summary>
--- virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCControlPotentiometer:ccTouchBegan() end
--- <summary>
--- virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCControlPotentiometer:ccTouchEnded() end
--- <summary>
--- virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCControlPotentiometer:ccTouchMoved() end
--- <summary>
--- //Creates potentiometer with a track filename and a progress filename.
--- static CCControlPotentiometer* create(const char* backgroundFile, const char* progressFile, const char* thumbFile);
--- </summary>
--- <returns type="CCControlPotentiometer"></returns>
function CCControlPotentiometer:create() end
--- <summary>
--- //Returns the distance between the point1 and point2. 
--- float distanceBetweenPointAndPoint(CCPoint point1, CCPoint point2);
--- </summary>
function CCControlPotentiometer:distanceBetweenPointAndPoint() end
--- <summary>
--- float getMaximumValue();
--- </summary>
function CCControlPotentiometer:getMaximumValue() end
--- <summary>
--- float getMinimumValue();
--- </summary>
function CCControlPotentiometer:getMinimumValue() end
--- <summary>
--- virtual CCPoint  getPreviousLocation() const;
--- </summary>
--- <returns type="CCPoint"></returns>
function CCControlPotentiometer:getPreviousLocation() end
--- <summary>
--- virtual CCProgressTimer* getProgressTimer() const;
--- </summary>
--- <returns type="CCProgressTimer"></returns>
function CCControlPotentiometer:getProgressTimer() end
--- <summary>
--- virtual CCSprite*  getThumbSprite() const;
--- </summary>
--- <returns type="CCSprite"></returns>
function CCControlPotentiometer:getThumbSprite() end
--- <summary>
--- float getValue();
--- </summary>
function CCControlPotentiometer:getValue() end
--- <summary>
--- //Initializes a potentiometer with a track sprite and a progress bar.
--- //@param trackSprite CCSprite, that is used as a background.
--- //@param progressSprite CCProgressTimer, that is used as a progress bar.
--- bool initWithTrackSprite_ProgressTimer_ThumbSprite(CCSprite* trackSprite, CCProgressTimer* progressTimer, CCSprite* thumbSprite);
--- </summary>
function CCControlPotentiometer:initWithTrackSprite_ProgressTimer_ThumbSprite() end
--- <summary>
--- virtual bool isTouchInside(CCTouch * touch);
--- </summary>
function CCControlPotentiometer:isTouchInside() end
--- <summary>
--- //Factorize the event dispath into these methods. 
--- void potentiometerBegan(CCPoint location);
--- </summary>
function CCControlPotentiometer:potentiometerBegan() end
--- <summary>
--- void potentiometerEnded(CCPoint location);
--- </summary>
function CCControlPotentiometer:potentiometerEnded() end
--- <summary>
--- void potentiometerMoved(CCPoint location);
--- </summary>
function CCControlPotentiometer:potentiometerMoved() end
--- <summary>
--- void setEnabled(bool enabled);
--- </summary>
function CCControlPotentiometer:setEnabled() end
--- <summary>
--- void setMaximumValue(float maximumValue);
--- </summary>
function CCControlPotentiometer:setMaximumValue() end
--- <summary>
--- void setMinimumValue(float minimumValue);
--- </summary>
function CCControlPotentiometer:setMinimumValue() end
--- <summary>
--- virtual void setPreviousLocation(CCPoint var);
--- </summary>
function CCControlPotentiometer:setPreviousLocation() end
--- <summary>
--- virtual void setProgressTimer(CCProgressTimer* var);
--- </summary>
function CCControlPotentiometer:setProgressTimer() end
--- <summary>
--- virtual void setThumbSprite(CCSprite* var);
--- </summary>
function CCControlPotentiometer:setThumbSprite() end
--- <summary>
--- void setValue(float value);
--- </summary>
function CCControlPotentiometer:setValue() end
--- <summary>
--- virtual ~CCControlPotentiometer();
--- </summary>
function CCControlPotentiometer:delete() end

CCControlSlider = class(CCControl)
--- <summary>
--- CCControlSlider();
--- </summary>
function CCControlSlider:new() end
function CCControlSlider:new_local() end
--- <summary>
--- static CCControlSlider* create(const char* bgFile, const char* progressFile, const char* thumbFile);
--- static CCControlSlider* create(CCSprite * backgroundSprite, CCSprite* pogressSprite, CCSprite* thumbSprite);
--- </summary>
--- <returns type="CCControlSlider"></returns>
function CCControlSlider:create() end
--- <summary>
--- virtual CCSprite*  getBackgroundSprite() const;
--- </summary>
--- <returns type="CCSprite"></returns>
function CCControlSlider:getBackgroundSprite() end
--- <summary>
--- virtual float getMaximumAllowedValue() const;
--- </summary>
function CCControlSlider:getMaximumAllowedValue() end
--- <summary>
--- virtual float getMaximumValue() const;
--- </summary>
function CCControlSlider:getMaximumValue() end
--- <summary>
--- virtual float getMinimumAllowedValue() const;
--- </summary>
function CCControlSlider:getMinimumAllowedValue() end
--- <summary>
--- virtual float getMinimumValue() const;
--- </summary>
function CCControlSlider:getMinimumValue() end
--- <summary>
--- virtual CCSprite*  getProgressSprite() const;
--- </summary>
--- <returns type="CCSprite"></returns>
function CCControlSlider:getProgressSprite() end
--- <summary>
--- virtual CCSprite*  getThumbSprite() const;
--- </summary>
--- <returns type="CCSprite"></returns>
function CCControlSlider:getThumbSprite() end
--- <summary>
--- virtual float getValue() const; 
--- </summary>
function CCControlSlider:getValue() end
--- <summary>
--- virtual bool initWithSprites(CCSprite * backgroundSprite, CCSprite* progressSprite, CCSprite* thumbSprite);
--- </summary>
function CCControlSlider:initWithSprites() end
--- <summary>
--- virtual bool isTouchInside(CCTouch * touch);
--- </summary>
function CCControlSlider:isTouchInside() end
--- <summary>
--- CCPoint locationFromTouch(CCTouch* touch);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCControlSlider:locationFromTouch() end
--- <summary>
--- virtual void needsLayout();  
--- </summary>
function CCControlSlider:needsLayout() end
--- <summary>
--- virtual void  setBackgroundSprite(CCSprite* val);
--- </summary>
function CCControlSlider:setBackgroundSprite() end
--- <summary>
--- virtual void setEnabled(bool enabled);
--- </summary>
function CCControlSlider:setEnabled() end
--- <summary>
--- virtual void  setMaximumAllowedValue(float val); 
--- </summary>
function CCControlSlider:setMaximumAllowedValue() end
--- <summary>
--- virtual void  setMaximumValue(float val);
--- virtual void setMaximumValue(float val);
--- </summary>
function CCControlSlider:setMaximumValue() end
--- <summary>
--- virtual void  setMinimumAllowedValue(float val);
--- </summary>
function CCControlSlider:setMinimumAllowedValue() end
--- <summary>
--- virtual void setMinimumValue(float val);
--- </summary>
function CCControlSlider:setMinimumValue() end
--- <summary>
--- virtual void  setProgressSprite(CCSprite* val);
--- </summary>
function CCControlSlider:setProgressSprite() end
--- <summary>
--- virtual void  setThumbSprite(CCSprite* val);
--- </summary>
function CCControlSlider:setThumbSprite() end
--- <summary>
--- virtual void setValue(float val);
--- </summary>
function CCControlSlider:setValue() end
--- <summary>
--- virtual ~CCControlSlider();
--- </summary>
function CCControlSlider:delete() end

CCControlStepper = class(CCControl)
--- <summary>
--- CCControlStepper();
--- </summary>
function CCControlStepper:new() end
function CCControlStepper:new_local() end
--- <summary>
--- virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCControlStepper:ccTouchBegan() end
--- <summary>
--- virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCControlStepper:ccTouchEnded() end
--- <summary>
--- virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCControlStepper:ccTouchMoved() end
--- <summary>
--- static CCControlStepper* create(CCSprite *minusSprite, CCSprite *plusSprite);
--- </summary>
--- <returns type="CCControlStepper"></returns>
function CCControlStepper:create() end
--- <summary>
--- virtual CCLabelTTF*  getMinusLabel() const;
--- </summary>
--- <returns type="CCLabelTTF"></returns>
function CCControlStepper:getMinusLabel() end
--- <summary>
--- virtual CCSprite*  getMinusSprite() const;
--- </summary>
--- <returns type="CCSprite"></returns>
function CCControlStepper:getMinusSprite() end
--- <summary>
--- virtual CCLabelTTF*  getPlusLabel() const;
--- </summary>
--- <returns type="CCLabelTTF"></returns>
function CCControlStepper:getPlusLabel() end
--- <summary>
--- virtual CCSprite*  getPlusSprite() const;
--- </summary>
--- <returns type="CCSprite"></returns>
function CCControlStepper:getPlusSprite() end
--- <summary>
--- virtual double getValue();
--- </summary>
function CCControlStepper:getValue() end
--- <summary>
--- bool initWithMinusSpriteAndPlusSprite(CCSprite *minusSprite, CCSprite *plusSprite);
--- </summary>
function CCControlStepper:initWithMinusSpriteAndPlusSprite() end
--- <summary>
--- virtual bool isContinuous();
--- </summary>
function CCControlStepper:isContinuous() end
--- <summary>
--- virtual void setMaximumValue(double maximumValue);
--- </summary>
function CCControlStepper:setMaximumValue() end
--- <summary>
--- virtual void setMinimumValue(double minimumValue);
--- </summary>
function CCControlStepper:setMinimumValue() end
--- <summary>
--- virtual void setMinusLabel(CCLabelTTF* var);
--- </summary>
function CCControlStepper:setMinusLabel() end
--- <summary>
--- virtual void setMinusSprite(CCSprite* var);
--- </summary>
function CCControlStepper:setMinusSprite() end
--- <summary>
--- virtual void setPlusLabel(CCLabelTTF* var);
--- </summary>
function CCControlStepper:setPlusLabel() end
--- <summary>
--- virtual void setPlusSprite(CCSprite* var);
--- </summary>
function CCControlStepper:setPlusSprite() end
--- <summary>
--- virtual void setStepValue(double stepValue);
--- </summary>
function CCControlStepper:setStepValue() end
--- <summary>
--- virtual void setValue(double value);
--- </summary>
function CCControlStepper:setValue() end
--- <summary>
--- //Set the numeric value of the stepper. If send is true, the CCControlEventValueChanged is sent. 
--- virtual void setValueWithSendingEvent(double value, bool send);
--- </summary>
function CCControlStepper:setValueWithSendingEvent() end
--- <summary>
--- virtual void setWraps(bool wraps);
--- </summary>
function CCControlStepper:setWraps() end
--- <summary>
--- //Start the autorepeat increment/decrement. 
--- void startAutorepeat();
--- </summary>
function CCControlStepper:startAutorepeat() end
--- <summary>
--- //Stop the autorepeat. 
--- void stopAutorepeat();
--- </summary>
function CCControlStepper:stopAutorepeat() end
--- <summary>
--- void update(float dt);
--- </summary>
function CCControlStepper:update() end
--- <summary>
--- //Update the layout of the stepper with the given touch location. 
--- void updateLayoutUsingTouchLocation(CCPoint location);
--- </summary>
function CCControlStepper:updateLayoutUsingTouchLocation() end
--- <summary>
--- virtual ~CCControlStepper();
--- </summary>
function CCControlStepper:delete() end

CCControlSwitch = class(CCControl)
--- <summary>
--- CCControlSwitch();
--- </summary>
function CCControlSwitch:new() end
function CCControlSwitch:new_local() end
--- <summary>
--- virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCControlSwitch:ccTouchBegan() end
--- <summary>
--- virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCControlSwitch:ccTouchCancelled() end
--- <summary>
--- virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCControlSwitch:ccTouchEnded() end
--- <summary>
--- virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCControlSwitch:ccTouchMoved() end
--- <summary>
--- //Creates a switch with a mask sprite, on/off sprites for on/off states and a thumb sprite. 
--- static CCControlSwitch* create(CCSprite *maskSprite, CCSprite * onSprite, CCSprite * offSprite, CCSprite * thumbSprite);
--- 
--- //Creates a switch with a mask sprite, on/off sprites for on/off states, a thumb sprite and an on/off labels. 
--- static CCControlSwitch* create(CCSprite *maskSprite, CCSprite * onSprite, CCSprite * offSprite, CCSprite * thumbSprite, CCLabelTTF* onLabel, CCLabelTTF* offLabel);
--- </summary>
--- <returns type="CCControlSwitch"></returns>
function CCControlSwitch:create() end
--- <summary>
--- bool hasMoved() { return m_bMoved; }
--- </summary>
function CCControlSwitch:hasMoved() end
--- <summary>
--- //Initializes a switch with a mask sprite, on/off sprites for on/off states and a thumb sprite. 
--- bool initWithMaskSprite(CCSprite *maskSprite, CCSprite * onSprite, CCSprite * offSprite, CCSprite * thumbSprite);
--- 
--- //Initializes a switch with a mask sprite, on/off sprites for on/off states, a thumb sprite and an on/off labels. 
--- bool initWithMaskSprite(CCSprite *maskSprite, CCSprite * onSprite, CCSprite * offSprite, CCSprite * thumbSprite, CCLabelTTF* onLabel, CCLabelTTF* offLabel);
--- </summary>
function CCControlSwitch:initWithMaskSprite() end
--- <summary>
--- bool isOn(void) { return m_bOn; }
--- </summary>
function CCControlSwitch:isOn() end
--- <summary>
--- CCPoint locationFromTouch(CCTouch* touch);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCControlSwitch:locationFromTouch() end
--- <summary>
--- virtual void setEnabled(bool enabled);
--- </summary>
function CCControlSwitch:setEnabled() end
--- <summary>
--- //Set the state of the switch to On or Off, optionally animating the transition.
--- //@param isOn YES if the switch should be turned to the On position; NO if it 
--- //should be turned to the Off position. If the switch is already in the 
--- //designated position, nothing happens.
--- //@param animated YES to animate the "flipping" of the switch; otherwise NO.
--- void setOn(bool isOn, bool animated);
--- </summary>
function CCControlSwitch:setOn() end
--- <summary>
--- virtual ~CCControlSwitch();
--- </summary>
function CCControlSwitch:delete() end

CCBaseData = class(CCObject)
--- <summary>
--- //@js ctor
--- CCBaseData();
--- </summary>
function CCBaseData:new() end
function CCBaseData:new_local() end
--- <summary>
--- CCBaseData* create(void);
--- </summary>
--- <returns type="CCBaseData"></returns>
function CCBaseData:create() end
--- <summary>
--- virtual ccColor4B getColor();
--- </summary>
--- <returns type="ccColor4B"></returns>
function CCBaseData:getColor() end
--- <summary>
--- virtual void setColor(const ccColor4B &amp;color);
--- </summary>
function CCBaseData:setColor() end

CCDictionary = class(CCObject)
--- <summary>
--- //Return all keys of elements.
--- //@return  The array contains all keys of elements. It's an autorelease object yet.
--- CCArray* allKeys();
--- </summary>
--- <returns type="CCArray"></returns>
function CCDictionary:allKeys() end
--- <summary>
--- //Get all keys according to the specified object.
--- //@warning  We use '==' to compare two objects
--- //@return   The array contains all keys for the specified object. It's an autorelease object yet.
--- CCArray* allKeysForObject(CCObject* object);
--- </summary>
--- <returns type="CCArray"></returns>
function CCDictionary:allKeysForObject() end
--- <summary>
--- //Get the count of elements in CCDictionary.
--- //@return  The count of elements.
--- unsigned int count();
--- </summary>
function CCDictionary:count() end
--- <summary>
--- //Create a dictionary.
--- //@return A dictionary which is an autorelease object.
--- //@see createWithDictionary(CCDictionary*), createWithContentsOfFile(const char*), createWithContentsOfFileThreadSafe(const char*).
--- static CCDictionary* create();
--- </summary>
--- <returns type="CCDictionary"></returns>
function CCDictionary:create() end
--- <summary>
--- //Create a dictionary with a plist file.
--- //@param  pFileName  The name of the plist file.
--- //@return A dictionary which is an autorelease object.
--- //@see create(), createWithDictionary(CCDictionary*), createWithContentsOfFileThreadSafe(const char*).
--- static CCDictionary* createWithContentsOfFile(const char *pFileName);
--- </summary>
--- <returns type="CCDictionary"></returns>
function CCDictionary:createWithContentsOfFile() end
--- <summary>
--- //Create a dictionary with an existing dictionary.
--- //@param srcDict The exist dictionary.
--- //@return A dictionary which is an autorelease object.
--- //@see create(), createWithContentsOfFile(const char*), createWithContentsOfFileThreadSafe(const char*).
--- static CCDictionary* createWithDictionary(CCDictionary* srcDict);
--- </summary>
--- <returns type="CCDictionary"></returns>
function CCDictionary:createWithDictionary() end
--- <summary>
--- //Get the object according to the specified string key.
--- //@note The dictionary needs to use string as key. If integer is passed, an assert will appear.
--- //@param key  The string key for searching.
--- //@return The object matches the key. You need to force convert it to the type you know.
--- //@code
--- //// Assume that the elements are CCString* pointers. Convert it by following code.
--- //CCString* pStr = (CCString*)pDict->objectForKey("key1");
--- //// Do something about pStr.
--- //// If you don't know the object type, properly you need to use dynamic_cast&lt;SomeType*> to check it.
--- //CCString* pStr2 = dynamic_cast&lt;CCString*>(pDict->objectForKey("key1"));
--- //if (pStr2 != NULL) {
--- //// Do something about pStr2
--- //}
--- //@endcode
--- //@see objectForKey(intptr_t)
--- CCObject* objectForKey(const std::string&amp; key);
--- 
--- //Get the object according to the specified integer key.
--- //@note The dictionary needs to use integer as key. If string is passed, an assert will appear.
--- //@param key  The integer key for searching.
--- //@return The object matches the key.
--- //@see objectForKey(const std::string&amp;)
--- CCObject* objectForKey(intptr_t key);
--- </summary>
--- <returns type="CCObject"></returns>
function CCDictionary:objectForKey() end
--- <summary>
--- //Remove all objects in the dictionary.
--- //@see removeObjectForKey(const std::string&amp;), removeObjectForKey(intptr_t),
--- //removeObjectsForKeys(CCArray*), removeObjectForElememt(CCDictElement*).
--- void removeAllObjects();
--- </summary>
function CCDictionary:removeAllObjects() end
--- <summary>
--- //Remove an object by the specified string key.
--- //@param key  The string key for searching.
--- //@see removeObjectForKey(intptr_t), removeObjectsForKeys(CCArray*),
--- //removeObjectForElememt(CCDictElement*), removeAllObjects().
--- void removeObjectForKey(const std::string&amp; key);
--- 
--- //Remove an object by the specified integer key.
--- //@param key  The integer key for searching.
--- //@see removeObjectForKey(const std::string&amp;), removeObjectsForKeys(CCArray*),
--- //removeObjectForElememt(CCDictElement*), removeAllObjects().
--- void removeObjectForKey(intptr_t key);
--- </summary>
function CCDictionary:removeObjectForKey() end
--- <summary>
--- //Remove objects by an array of keys.
--- //@param pKeyArray  The array contains keys to be removed.
--- //@see removeObjectForKey(const std::string&amp;), removeObjectForKey(intptr_t),
--- //removeObjectForElememt(CCDictElement*), removeAllObjects().
--- void removeObjectsForKeys(CCArray* pKeyArray);
--- </summary>
function CCDictionary:removeObjectsForKeys() end
--- <summary>
--- //Insert an object to dictionary, and match it with the specified string key.
--- //@note Whe the first time this method is invoked, the key type will be set to string.
--- //After that you can't setObject with an integer key.
--- //If the dictionary contains the key you passed, the object matching the key will be released and removed from dictionary.
--- //Then the new object will be inserted after that.
--- //@param pObject  The Object to be inserted.
--- //@param key      The string key for searching.
--- //@see setObject(CCObject*, intptr_t)
--- void setObject(CCObject* pObject, const std::string&amp; key);
--- 
--- //Insert an object to dictionary, and match it with the specified string key.
--- //@note Then the first time this method is invoked, the key type will be set to string.
--- //After that you can't setObject with an integer key.
--- //If the dictionary contains the key you passed, the object matching the key will be released and removed from dictionary.
--- //Then the new object will be inserted after that.
--- //@param pObject  The Object to be inserted.
--- //@param key      The string key for searching.
--- //@see setObject(CCObject*, const std::string&amp;)
--- void setObject(CCObject* pObject, intptr_t key);
--- </summary>
function CCDictionary:setObject() end
--- <summary>
--- //Get the value according to the specified string key.
--- //@note Be careful to use this function since it assumes the objects in the dictionary are CCString pointer.
--- //@param key  The string key for searching
--- //@return An instance of CCString.
--- //It will return an empty string if the objects aren't CCString pointer or the key wasn't found.
--- //@see valueForKey(intptr_t)
--- const CCString* valueForKey(const std::string&amp; key);
--- 
--- //Get the value according to the specified integer key.
--- //@note Be careful to use this function since it assumes the objects in the dictionary are CCString pointer.
--- //@param key  The string key for searching.
--- //@return An instance of CCString.
--- //It will return an empty string if the objects aren't CCString pointer or the key wasn't found.
--- //@see valueForKey(intptr_t)
--- const CCString* valueForKey(intptr_t key);
--- </summary>
--- <returns type="CCString"></returns>
function CCDictionary:valueForKey() end

CCDirector = class(CCObject)
--- <summary>
--- //converts a UIKit coordinate to an OpenGL coordinate
--- //Useful to convert (multi) touch coordinates to the current layout (portrait or landscape)
--- CCPoint convertToGL(const CCPoint&amp; obPoint);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCDirector:convertToGL() end
--- <summary>
--- //converts an OpenGL coordinate to a UIKit coordinate
--- //Useful to convert node points to window points for calls such as glScissor
--- CCPoint convertToUI(const CCPoint&amp; obPoint);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCDirector:convertToUI() end
--- <summary>
--- void end @ endToLua ();
--- </summary>
--- <returns type="@"></returns>
function CCDirector:endToLua() end
--- <summary>
--- CCActionManager* getActionManager();
--- </summary>
--- <returns type="CCActionManager"></returns>
function CCDirector:getActionManager() end
--- <summary>
--- //Get the FPS value 
--- inline double getAnimationInterval(void);
--- </summary>
function CCDirector:getAnimationInterval() end
--- <summary>
--- float getContentScaleFactor(void);
--- </summary>
function CCDirector:getContentScaleFactor() end
--- <summary>
--- //This object will be visited after the main scene is visited.
--- //This object MUST implement the "visit" selector.
--- //Useful to hook a notification object, like CCNotifications (http://github.com/manucorporat/CCNotifications)
--- //@since v0.99.5
--- CCNode* getNotificationNode();
--- </summary>
--- <returns type="CCNode"></returns>
function CCDirector:getNotificationNode() end
--- <summary>
--- //Get the CCEGLView, where everything is rendered
--- //@js NA
--- inline CCEGLView* getOpenGLView(void);
--- </summary>
--- <returns type="CCEGLViewProtocol"></returns>
function CCDirector:getOpenGLView() end
--- <summary>
--- //Sets an OpenGL projection
--- //@since v0.8.2
--- //@js NA
--- inline ccDirectorProjection getProjection(void);
--- </summary>
--- <returns type="ccDirectorProjection"></returns>
function CCDirector:getProjection() end
--- <summary>
--- //Get current running Scene. Director can only run one Scene at the time 
--- inline CCScene* getRunningScene(void);
--- </summary>
--- <returns type="CCScene"></returns>
function CCDirector:getRunningScene() end
--- <summary>
--- CCScheduler* getScheduler();
--- </summary>
--- <returns type="CCScheduler"></returns>
function CCDirector:getScheduler() end
--- <summary>
--- //How many frames were called since the director started 
--- inline unsigned int getTotalFrames(void);
--- </summary>
function CCDirector:getTotalFrames() end
--- <summary>
--- CCTouchDispatcher* getTouchDispatcher();
--- </summary>
--- <returns type="CCTouchDispatcher"></returns>
function CCDirector:getTouchDispatcher() end
--- <summary>
--- //returns visible origin of the OpenGL view in points.
--- CCPoint getVisibleOrigin();
--- </summary>
--- <returns type="CCPoint"></returns>
function CCDirector:getVisibleOrigin() end
--- <summary>
--- //returns visible size of the OpenGL view in points.
--- //the value is equal to getWinSize if don't invoke
--- //CCEGLView::setDesignResolutionSize()
--- CCSize getVisibleSize();
--- </summary>
--- <returns type="CCSize"></returns>
function CCDirector:getVisibleSize() end
--- <summary>
--- //returns the size of the OpenGL view in points.
--- CCSize getWinSize(void);
--- </summary>
--- <returns type="CCSize"></returns>
function CCDirector:getWinSize() end
--- <summary>
--- //returns the size of the OpenGL view in pixels.
--- CCSize getWinSizeInPixels(void);
--- </summary>
--- <returns type="CCSize"></returns>
function CCDirector:getWinSizeInPixels() end
--- <summary>
--- float getZEye(void);
--- </summary>
function CCDirector:getZEye() end
--- <summary>
--- //Whether or not to display the FPS on the bottom-left corner 
--- inline bool isDisplayStats(void);
--- </summary>
function CCDirector:isDisplayStats() end
--- <summary>
--- //Whether or not the Director is paused 
--- inline bool isPaused(void);
--- </summary>
function CCDirector:isPaused() end
--- <summary>
--- //Pauses the running scene.
--- //The running scene will be _drawed_ but all scheduled timers will be paused
--- //While paused, the draw rate will be 4 FPS to reduce CPU consumption
--- void pause(void);
--- </summary>
function CCDirector:pause() end
--- <summary>
--- //Pops out a scene from the queue.
--- //This scene will replace the running one.
--- //The running scene will be deleted. If there are no more scenes in the stack the execution is terminated.
--- //ONLY call it if there is a running scene.
--- void popScene(void);
--- </summary>
function CCDirector:popScene() end
--- <summary>
--- //Pops out all scenes from the queue until the root scene in the queue.
--- //This scene will replace the running one.
--- //Internally it will call `popToSceneStackLevel(1)`
--- void popToRootScene(void);
--- </summary>
function CCDirector:popToRootScene() end
--- <summary>
--- //Removes cached all cocos2d cached data.
--- //It will purge the CCTextureCache, CCSpriteFrameCache, CCLabelBMFont cache
--- //@since v0.99.3
--- void purgeCachedData(void);
--- </summary>
function CCDirector:purgeCachedData() end
--- <summary>
--- //Suspends the execution of the running scene, pushing it on the stack of suspended scenes.
--- //The new scene will be executed.
--- //Try to avoid big stacks of pushed scenes to reduce memory allocation. 
--- //ONLY call it if there is a running scene.
--- void pushScene(CCScene *pScene);
--- </summary>
function CCDirector:pushScene() end
--- <summary>
--- //Replaces the running scene with a new one. The running scene is terminated.
--- //ONLY call it if there is a running scene.
--- void replaceScene(CCScene *pScene);
--- </summary>
function CCDirector:replaceScene() end
--- <summary>
--- //Resumes the paused scene
--- //The scheduled timers will be activated again.
--- //The "delta time" will be 0 (as if the game wasn't paused)
--- void resume(void);
--- </summary>
function CCDirector:resume() end
--- <summary>
--- //Enters the Director's main loop with the given Scene.
--- //Call it to run only your FIRST scene.
--- //Don't call it if there is already a running scene.
--- //It will call pushScene: and then it will call startAnimation
--- void runWithScene(CCScene *pScene);
--- </summary>
function CCDirector:runWithScene() end
--- <summary>
--- //The size in pixels of the surface. It could be different than the screen size.
--- //High-res devices might have a higher surface size than the screen size.
--- //Only available when compiled using SDK >= 4.0.
--- //@since v0.99.4
--- void setContentScaleFactor(float scaleFactor);
--- </summary>
function CCDirector:setContentScaleFactor() end
--- <summary>
--- //enables/disables OpenGL depth test 
--- void setDepthTest(bool bOn);
--- </summary>
function CCDirector:setDepthTest() end
--- <summary>
--- //Display the FPS on the bottom-left corner 
--- inline void setDisplayStats(bool bDisplayStats);
--- </summary>
function CCDirector:setDisplayStats() end
--- <summary>
--- void setNotificationNode(CCNode *node);
--- </summary>
function CCDirector:setNotificationNode() end
--- <summary>
--- void setProjection(ccDirectorProjection kProjection);
--- </summary>
function CCDirector:setProjection() end
--- <summary>
--- //returns a shared instance of the director 
--- //@js getInstance
--- static CCDirector* sharedDirector(void);
--- </summary>
--- <returns type="CCDirector"></returns>
function CCDirector:sharedDirector() end

CCDisplayManager = class(CCObject)
--- <summary>
--- CCDisplayManager();
--- </summary>
function CCDisplayManager:new() end
function CCDisplayManager:new_local() end
--- <summary>
--- //Add display and use  _DisplayData init the display.
--- //If index already have a display, then replace it.
--- //If index is current display index, then also change display to _index
--- //@param 	displayData it include the display information, like DisplayType.
--- //If you want to create a sprite display, then create a CCSpriteDisplayData param
--- //@param 	index the index of the display you want to replace or add to
--- //-1 : append display from back
--- void addDisplay(CCDisplayData *displayData, int index);
--- </summary>
function CCDisplayManager:addDisplay() end
--- <summary>
--- //Change display by index. You can just use this method to change display in the display list.
--- //The display list is just used for this bone, and it is the displays you may use in every frame.
--- //Note : if index is the same with prev index, the method will not effect
--- //@param index The index of the display you want to change
--- //@param force If true, then force change display to specified display, or current display will set to  display index edit in the flash every key frame.
--- void changeDisplayWithIndex(int index, bool force);
--- </summary>
function CCDisplayManager:changeDisplayWithIndex() end
--- <summary>
--- //Check if the position is inside the bone.
--- virtual bool containPoint(CCPoint &amp;_point);
--- 
--- //Check if the position is inside the bone.
--- virtual bool containPoint(float x, float y);
--- </summary>
function CCDisplayManager:containPoint() end
--- <summary>
--- static CCDisplayManager *create(CCBone *bone);
--- </summary>
--- <returns type="CCDisplayManager"></returns>
function CCDisplayManager:create() end
--- <summary>
--- CCPoint getAnchorPoint();
--- </summary>
--- <returns type="CCPoint"></returns>
function CCDisplayManager:getAnchorPoint() end
--- <summary>
--- CCPoint getAnchorPointInPoints();
--- </summary>
--- <returns type="CCPoint"></returns>
function CCDisplayManager:getAnchorPointInPoints() end
--- <summary>
--- CCRect getBoundingBox();
--- </summary>
--- <returns type="CCRect"></returns>
function CCDisplayManager:getBoundingBox() end
--- <summary>
--- CCSize getContentSize();
--- </summary>
--- <returns type="CCSize"></returns>
function CCDisplayManager:getContentSize() end
--- <summary>
--- int getCurrentDisplayIndex();
--- </summary>
function CCDisplayManager:getCurrentDisplayIndex() end
--- <summary>
--- CCArray *getDecorativeDisplayList();
--- </summary>
--- <returns type="CCArray"></returns>
function CCDisplayManager:getDecorativeDisplayList() end
--- <summary>
--- CCNode *getDisplayRenderNode();
--- </summary>
--- <returns type="CCNode"></returns>
function CCDisplayManager:getDisplayRenderNode() end
--- <summary>
--- DisplayType getDisplayRenderNodeType();
--- </summary>
--- <returns type="DisplayType"></returns>
function CCDisplayManager:getDisplayRenderNodeType() end
--- <summary>
--- bool init(CCBone *bone);
--- </summary>
function CCDisplayManager:init() end
--- <summary>
--- //Determines if the display is visible
--- //@see setVisible(bool)
--- //@return true if the node is visible, false if the node is hidden.
--- virtual bool isVisible();
--- </summary>
function CCDisplayManager:isVisible() end
--- <summary>
--- void removeDisplay(int index);
--- </summary>
function CCDisplayManager:removeDisplay() end
--- <summary>
--- //Sets whether the display is visible
--- //The default value is true, a node is default to visible
--- //@param visible   true if the node is visible, false if the node is hidden.
--- virtual void setVisible(bool visible);
--- </summary>
function CCDisplayManager:setVisible() end

CCEGLViewProtocol = {}
--- <summary>
--- //Get design resolution size.
--- //Default resolution size is the same as 'getFrameSize'.
--- virtual const CCSize&amp; getDesignResolutionSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function CCEGLViewProtocol:getDesignResolutionSize() end
--- <summary>
--- //Get the frame size of EGL view.
--- //In general, it returns the screen size since the EGL view is a fullscreen view.
--- virtual const CCSize&amp; getFrameSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function CCEGLViewProtocol:getFrameSize() end
--- <summary>
--- //Get scale factor of the horizontal direction.
--- float getScaleX() const;
--- </summary>
function CCEGLViewProtocol:getScaleX() end
--- <summary>
--- //Get scale factor of the vertical direction.
--- float getScaleY() const;
--- </summary>
function CCEGLViewProtocol:getScaleY() end
--- <summary>
--- //Get the opengl view port rectangle.
--- const CCRect&amp; getViewPortRect() const;
--- </summary>
--- <returns type="CCRect"></returns>
function CCEGLViewProtocol:getViewPortRect() end
--- <summary>
--- //Get the visible origin point of opengl viewport.
--- virtual CCPoint getVisibleOrigin() const;
--- </summary>
--- <returns type="CCPoint"></returns>
function CCEGLViewProtocol:getVisibleOrigin() end
--- <summary>
--- //Get the visible area size of opengl viewport.
--- virtual CCSize getVisibleSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function CCEGLViewProtocol:getVisibleSize() end
--- <summary>
--- //Set the design resolution size.
--- //@param width Design resolution width.
--- //@param height Design resolution height.
--- //@param resolutionPolicy The resolution policy desired, you may choose:
--- //[1] kResolutionExactFit Fill screen by stretch-to-fit: if the design resolution ratio of width to height is different from the screen resolution ratio, your game view will be stretched.
--- //[2] kResolutionNoBorder Full screen without black border: if the design resolution ratio of width to height is different from the screen resolution ratio, two areas of your game view will be cut.
--- //[3] kResolutionShowAll  Full screen with black border: if the design resolution ratio of width to height is different from the screen resolution ratio, two black borders will be shown.
--- virtual void setDesignResolutionSize(float width, float height, ResolutionPolicy resolutionPolicy);
--- </summary>
function CCEGLViewProtocol:setDesignResolutionSize() end
--- <summary>
--- //Set the frame size of EGL view.
--- virtual void setFrameSize(float width, float height);
--- </summary>
function CCEGLViewProtocol:setFrameSize() end
--- <summary>
--- //Set Scissor rectangle with points.
--- virtual void setScissorInPoints(float x , float y , float w , float h);
--- </summary>
function CCEGLViewProtocol:setScissorInPoints() end
--- <summary>
--- //Set touch delegate 
--- virtual void setTouchDelegate(EGLTouchDelegate * pDelegate);
--- </summary>
function CCEGLViewProtocol:setTouchDelegate() end
--- <summary>
--- //Set opengl view port rectangle with points.
--- virtual void setViewPortInPoints(float x , float y , float w , float h);
--- </summary>
function CCEGLViewProtocol:setViewPortInPoints() end

CCEGLView = class(CCEGLViewProtocol)
--- <summary>
--- //@brief    get the shared main open gl window
--- static CCEGLView* sharedOpenGLView();
--- </summary>
--- <returns type="CCEGLView"></returns>
function CCEGLView:sharedOpenGLView() end

CCEditBox = class(CCControlButton)
--- <summary>
--- //Constructor.
--- CCEditBox(void);
--- </summary>
function CCEditBox:new() end
function CCEditBox:new_local() end
--- <summary>
--- //create a edit box with size.
--- //@return An autorelease pointer of CCEditBox, you don't need to release it only if you retain it again.
--- static CCEditBox* create(const CCSize&amp; size, CCScale9Sprite* pNormal9SpriteBg, CCScale9Sprite* pPressed9SpriteBg = NULL, CCScale9Sprite* pDisabled9SpriteBg = NULL);
--- </summary>
--- <returns type="CCEditBox"></returns>
function CCEditBox:create() end
--- <summary>
--- //Gets the maximum input length of the edit box.
--- //@return Maximum input length.
--- int getMaxLength();
--- </summary>
function CCEditBox:getMaxLength() end
--- <summary>
--- //Get a text in the edit box that acts as a placeholder when an
--- //edit box is empty.
--- const char* getPlaceHolder(void);
--- </summary>
function CCEditBox:getPlaceHolder() end
--- <summary>
--- //get a script Handler
--- //@js NA
--- int getScriptEditBoxHandler(void);
--- </summary>
function CCEditBox:getScriptEditBoxHandler() end
--- <summary>
--- //Get the text entered in the edit box.
--- //@return The text entered in the edit box.
--- const char* getText(void);
--- </summary>
function CCEditBox:getText() end
--- <summary>
--- //Init edit box with specified size. This method should be invoked right after constructor.
--- //@param size The size of edit box.
--- bool initWithSizeAndBackgroundSprite(const CCSize&amp; size, CCScale9Sprite* pNormal9SpriteBg);
--- </summary>
function CCEditBox:initWithSizeAndBackgroundSprite() end
--- <summary>
--- //@js NA
--- //@lua NA
--- virtual void onEnter(void);
--- </summary>
function CCEditBox:onEnter() end
--- <summary>
--- //@js NA
--- //@lua NA
--- virtual void onExit(void);
--- </summary>
function CCEditBox:onExit() end
--- <summary>
--- //Registers a script function that will be called for EditBox events.
--- //This handler will be removed automatically after onExit() called.
--- //@code
--- //-- lua sample
--- //local function editboxEventHandler(eventType)
--- //if eventType == "began" then
--- //-- triggered when an edit box gains focus after keyboard is shown
--- //elseif eventType == "ended" then
--- //-- triggered when an edit box loses focus after keyboard is hidden.
--- //elseif eventType == "changed" then
--- //-- triggered when the edit box text was changed.
--- //elseif eventType == "return" then
--- //-- triggered when the return button was pressed or the outside area of keyboard was touched.
--- //end
--- //end
--- //local editbox = CCEditBox:create(CCSize(...), CCScale9Sprite:create(...))
--- //editbox = registerScriptEditBoxHandler(editboxEventHandler)
--- //@endcode
--- //@param handler A number that indicates a lua function.
--- //@js NA
--- void registerScriptEditBoxHandler(int handler);
--- </summary>
function CCEditBox:registerScriptEditBoxHandler() end
--- <summary>
--- //Set the font.
--- //@param pFontName The font name.
--- //@param fontSize The font size.
--- void setFont(const char* pFontName, int fontSize);
--- </summary>
function CCEditBox:setFont() end
--- <summary>
--- //Set the font color of the widget's text.
--- void setFontColor(const ccColor3B&amp; color);
--- </summary>
function CCEditBox:setFontColor() end
--- <summary>
--- //Set the font name.
--- //@param pFontName The font name.
--- void setFontName(const char* pFontName);
--- </summary>
function CCEditBox:setFontName() end
--- <summary>
--- //Set the font size.
--- //@param fontSize The font size.
--- void setFontSize(int fontSize);
--- </summary>
function CCEditBox:setFontSize() end
--- <summary>
--- //Set the input flags that are to be applied to the edit box.
--- //@param inputFlag One of the EditBoxInputFlag constants.
--- void setInputFlag(EditBoxInputFlag inputFlag);
--- </summary>
function CCEditBox:setInputFlag() end
--- <summary>
--- //Set the input mode of the edit box.
--- //@param inputMode One of the EditBoxInputMode constants.
--- void setInputMode(EditBoxInputMode inputMode);
--- </summary>
function CCEditBox:setInputMode() end
--- <summary>
--- //Sets the maximum input length of the edit box.
--- //Setting this value enables multiline input mode by default.
--- //Available on Android, iOS and Windows Phone.
--- //@param maxLength The maximum length.
--- void setMaxLength(int maxLength);
--- </summary>
function CCEditBox:setMaxLength() end
--- <summary>
--- //Set a text in the edit box that acts as a placeholder when an
--- //edit box is empty.
--- //@param pText The given text.
--- void setPlaceHolder(const char* pText);
--- </summary>
function CCEditBox:setPlaceHolder() end
--- <summary>
--- //Set the placeholder's font.
--- //@param pFontName The font name.
--- //@param fontSize The font size.
--- void setPlaceholderFont(const char* pFontName, int fontSize);
--- </summary>
function CCEditBox:setPlaceholderFont() end
--- <summary>
--- //Set the font color of the placeholder text when the edit box is empty.
--- //Not supported on IOS.
--- void setPlaceholderFontColor(const ccColor3B&amp; color);
--- </summary>
function CCEditBox:setPlaceholderFontColor() end
--- <summary>
--- //Set the placeholder's font name.
--- //@param pFontName The font name.
--- void setPlaceholderFontName(const char* pFontName);
--- </summary>
function CCEditBox:setPlaceholderFontName() end
--- <summary>
--- //Set the placeholder's font size.
--- //@param fontSize The font size.
--- void setPlaceholderFontSize(int fontSize);
--- </summary>
function CCEditBox:setPlaceholderFontSize() end
--- <summary>
--- //Set the return type that are to be applied to the edit box.
--- //@param returnType One of the CCKeyboardReturnType constants.
--- void setReturnType(KeyboardReturnType returnType);
--- </summary>
function CCEditBox:setReturnType() end
--- <summary>
--- //Set the text entered in the edit box.
--- //@param pText The given text.
--- void setText(const char* pText);
--- </summary>
function CCEditBox:setText() end
--- <summary>
--- virtual void setVisible(bool visible);
--- </summary>
function CCEditBox:setVisible() end
--- <summary>
--- //callback funtions 
--- //@js NA
--- void touchDownAction(CCObject *sender, CCControlEvent controlEvent);
--- </summary>
function CCEditBox:touchDownAction() end
--- <summary>
--- //Unregisters a script function that will be called for EditBox events.
--- //@js NA
--- void unregisterScriptEditBoxHandler(void);
--- </summary>
function CCEditBox:unregisterScriptEditBoxHandler() end
--- <summary>
--- //@js NA
--- virtual void visit(void);
--- </summary>
function CCEditBox:visit() end
--- <summary>
--- //Destructor.
--- virtual ~CCEditBox(void);
--- </summary>
function CCEditBox:delete() end

CCFileUtils = {}
--- <summary>
--- //Adds a path to search paths.
--- //@since v2.2
--- virtual void addSearchPath(const char* path);
--- </summary>
function CCFileUtils:addSearchPath() end
--- <summary>
--- //Append search order of the resources.
--- //@see setSearchResolutionsOrder(), fullPathForFilename().
--- //@since v2.1
--- virtual void addSearchResolutionsOrder(const char* order);
--- </summary>
function CCFileUtils:addSearchResolutionsOrder() end
--- <summary>
--- std::string fullPathForFilename(const char *pszFileName);
--- </summary>
--- <returns type="std::string"></returns>
function CCFileUtils:fullPathForFilename() end
--- <summary>
--- //Gets full path from a file name and the path of the reletive file.
--- //@param pszFilename The file name.
--- //@param pszRelativeFile The path of the relative file.
--- //@return The full path.
--- //e.g. pszFilename: hello.png, pszRelativeFile: /User/path1/path2/hello.plist
--- //Return: /User/path1/path2/hello.pvr (If there a a key(hello.png)-value(hello.pvr) in FilenameLookup dictionary. )
--- virtual const char* fullPathFromRelativeFile(const char *pszFilename, const char *pszRelativeFile);
--- </summary>
function CCFileUtils:fullPathFromRelativeFile() end
--- <summary>
--- //Gets the writable path.
--- //@return  The path that can be write/read a file in
--- //@lua NA
--- virtual std::string getWritablePath() = 0;
--- </summary>
--- <returns type="std::string"></returns>
function CCFileUtils:getWritablePath() end
--- <summary>
--- bool isPopupNotify();
--- </summary>
function CCFileUtils:isPopupNotify() end
--- <summary>
--- //Loads the filenameLookup dictionary from the contents of a filename.
--- //@note The plist file name should follow the format below:
--- //@code
--- //&lt;?xml version="1.0" encoding="UTF-8"?>
--- //&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
--- //&lt;plist version="1.0">
--- //&lt;dict>
--- //&lt;key>filenames&lt;/key>
--- //&lt;dict>
--- //&lt;key>sounds/click.wav&lt;/key>
--- //&lt;string>sounds/click.caf&lt;/string>
--- //&lt;key>sounds/endgame.wav&lt;/key>
--- //&lt;string>sounds/endgame.caf&lt;/string>
--- //&lt;key>sounds/gem-0.wav&lt;/key>
--- //&lt;string>sounds/gem-0.caf&lt;/string>
--- //&lt;/dict>
--- //&lt;key>metadata&lt;/key>
--- //&lt;dict>
--- //&lt;key>version&lt;/key>
--- //&lt;integer>1&lt;/integer>
--- //&lt;/dict>
--- //&lt;/dict>
--- //&lt;/plist>
--- //@endcode
--- //@param filename The plist file name.
--- //@since v2.1
--- //@loadFilenameLookup
--- virtual void loadFilenameLookupDictionaryFromFile(const char* filename);
--- </summary>
function CCFileUtils:loadFilenameLookupDictionaryFromFile() end
--- <summary>
--- //Purges the file searching cache.
--- //@note It should be invoked after the resources were updated.
--- //For instance, in the CocosPlayer sample, every time you run application from CocosBuilder,
--- //All the resources will be downloaded to the writable folder, before new js app launchs,
--- //this method should be invoked to clean the file search cache.
--- virtual void purgeCachedEntries();
--- </summary>
function CCFileUtils:purgeCachedEntries() end
--- <summary>
--- //Destroys the instance of CCFileUtils.
--- static void purgeFileUtils();
--- </summary>
function CCFileUtils:purgeFileUtils() end
--- <summary>
--- //Sets/Gets whether to pop-up a message box when failed to load an image.
--- virtual void setPopupNotify(bool bNotify);
--- </summary>
function CCFileUtils:setPopupNotify() end
--- <summary>
--- //Gets the instance of CCFileUtils.
--- //@js getInstance
--- static CCFileUtils* sharedFileUtils();
--- </summary>
--- <returns type="CCFileUtils"></returns>
function CCFileUtils:sharedFileUtils() end

CCPoint = {}
--- <summary>
--- //@lua NA
--- CCPoint(const CCPoint&amp; other);
--- 
--- //@lua NA
--- CCPoint(const CCSize&amp; size);
--- </summary>
function CCPoint:new() end
function CCPoint:new_local() end
--- <summary>
--- bool equals(const CCPoint &amp; target) const ;
--- </summary>
function CCPoint:equals() end

CCSize = {}
--- <summary>
--- //@lua NA
--- CCSize(const CCSize&amp; other);
--- 
--- //@lua NA
--- CCSize(const CCPoint&amp; point);
--- </summary>
function CCSize:new() end
function CCSize:new_local() end
--- <summary>
--- //@lua NA
--- bool equals(const CCSize&amp; target) const;
--- </summary>
function CCSize:equals() end

CCRect = {}
--- <summary>
--- //@lua NA
--- CCRect(const CCRect&amp; other);
--- </summary>
function CCRect:new() end
function CCRect:new_local() end
--- <summary>
--- bool containsPoint(const CCPoint &amp; point) const;
--- </summary>
function CCRect:containsPoint() end
--- <summary>
--- bool equals(const CCRect &amp; rect) const;
--- </summary>
function CCRect:equals() end
--- <summary>
--- float getMaxX();
--- </summary>
function CCRect:getMaxX() end
--- <summary>
--- float getMaxY();
--- </summary>
function CCRect:getMaxY() end
--- <summary>
--- float getMidX();
--- </summary>
function CCRect:getMidX() end
--- <summary>
--- float getMidY();
--- </summary>
function CCRect:getMidY() end
--- <summary>
--- float getMinX();
--- </summary>
function CCRect:getMinX() end
--- <summary>
--- float getMinY();
--- </summary>
function CCRect:getMinY() end
--- <summary>
--- bool intersectsRect(const CCRect &amp; rect) const;
--- </summary>
function CCRect:intersectsRect() end

CCImage = class(CCObject)
--- <summary>
--- //@js ctor
--- CCImage();
--- </summary>
function CCImage:new() end
function CCImage:new_local() end
--- <summary>
--- int getBitsPerComponent();
--- </summary>
function CCImage:getBitsPerComponent() end
--- <summary>
--- unsigned char *   getData();
--- </summary>
function CCImage:getData() end
--- <summary>
--- int         getDataLen();
--- </summary>
function CCImage:getDataLen() end
--- <summary>
--- unsigned short getHeight();
--- </summary>
--- <returns type="short"></returns>
function CCImage:getHeight() end
--- <summary>
--- unsigned short getWidth();
--- </summary>
--- <returns type="short"></returns>
function CCImage:getWidth() end
--- <summary>
--- bool hasAlpha();
--- </summary>
function CCImage:hasAlpha() end
--- <summary>
--- bool initWithImageData(void * pData,
--- </summary>
function CCImage:initWithImageData() end
--- <summary>
--- //@brief  Load the image from the specified path. 
--- //@param strPath   the absolute file path.
--- //@param imageType the type of image, currently only supporting two types.
--- //@return  true if loaded correctly.
--- bool initWithImageFile(const char * strPath, EImageFormat imageType = kFmtPng);
--- </summary>
function CCImage:initWithImageFile() end
--- <summary>
--- bool initWithImageFileThreadSafe(const char *fullpath, EImageFormat imageType = kFmtPng);
--- </summary>
function CCImage:initWithImageFileThreadSafe() end
--- <summary>
--- //@brief    Create image with specified string.
--- //@param  pText       the text the image will show (cannot be nil).
--- //@param  nWidth      the image width, if 0, the width will match the text's width.
--- //@param  nHeight     the image height, if 0, the height will match the text's height.
--- //@param  eAlignMask  the test Alignment
--- //@param  pFontName   the name of the font used to draw the text. If nil, use the default system font.
--- //@param  nSize       the font size, if 0, use the system default size.
--- //@js NA
--- bool initWithString(const char * pText, int nWidth = 0, int nHeight = 0,ETextAlign eAlignMask = kAlignCenter,const char * pFontName = 0,int nSize = 0);
--- </summary>
function CCImage:initWithString() end
--- <summary>
--- bool isPremultipliedAlpha();
--- </summary>
function CCImage:isPremultipliedAlpha() end
--- <summary>
--- //@brief    Save CCImage data to the specified file, with specified format.
--- //@param    pszFilePath        the file's absolute path, including file suffix.
--- //@param    bIsToRGB        whether the image is saved as RGB format.
--- bool saveToFile(const char *pszFilePath, bool bIsToRGB = true);
--- </summary>
function CCImage:saveToFile() end

CCInteger = class(CCObject)
--- <summary>
--- CCInteger(int v);
--- </summary>
function CCInteger:new() end
function CCInteger:new_local() end
--- <summary>
--- static CCInteger* create(int v);
--- </summary>
--- <returns type="CCInteger"></returns>
function CCInteger:create() end
--- <summary>
--- int getValue() const;
--- </summary>
function CCInteger:getValue() end

CCLabelAtlas = class(CCAtlasNode)
--- <summary>
--- //creates the CCLabelAtlas with a string, a char map file(the atlas), the width and height of each element and the starting char of the atlas 
--- static CCLabelAtlas * create(const char *string, const char *charMapFile, unsigned int itemWidth, unsigned int itemHeight, unsigned int startCharMap);
--- 
--- //creates the CCLabelAtlas with a string and a configuration file
--- //@since v2.0
--- //@js _create
--- static CCLabelAtlas* create(const char *string, const char *fntFile);
--- </summary>
--- <returns type="CCLabelAtlas"></returns>
function CCLabelAtlas:create() end
--- <summary>
--- const char* getString(void);
--- </summary>
function CCLabelAtlas:getString() end
--- <summary>
--- CCTexture2D* getTexture(void);
--- </summary>
--- <returns type="CCTexture2D"></returns>
function CCLabelAtlas:getTexture() end
--- <summary>
--- void setString(const char *label);
--- </summary>
function CCLabelAtlas:setString() end
--- <summary>
--- void setTexture(CCTexture2D *texture);
--- </summary>
function CCLabelAtlas:setTexture() end
--- <summary>
--- void updateAtlasValues();
--- </summary>
function CCLabelAtlas:updateAtlasValues() end

CCLabelBMFont = class(CCSpriteBatchNode)
--- <summary>
--- //@js ctor
--- CCLabelBMFont();
--- </summary>
function CCLabelBMFont:new() end
function CCLabelBMFont:new_local() end
--- <summary>
--- //creates a bitmap font atlas with an initial string and the FNT file 
--- static CCLabelBMFont * create(const char *str, const char *fntFile, float width, CCTextAlignment alignment, CCPoint imageOffset);
--- 
--- //Creates an label.
--- static CCLabelBMFont * create();
--- </summary>
--- <returns type="CCLabelBMFont"></returns>
function CCLabelBMFont:create() end
--- <summary>
--- const ccColor3B&amp; getColor(void);
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCLabelBMFont:getColor() end
--- <summary>
--- const char* getFntFile();
--- </summary>
function CCLabelBMFont:getFntFile() end
--- <summary>
--- GLubyte getOpacity(void);
--- </summary>
--- <returns type="GLubyte"></returns>
function CCLabelBMFont:getOpacity() end
--- <summary>
--- const char* getString(void);
--- </summary>
function CCLabelBMFont:getString() end
--- <summary>
--- bool init();
--- </summary>
function CCLabelBMFont:init() end
--- <summary>
--- bool isOpacityModifyRGB();
--- </summary>
function CCLabelBMFont:isOpacityModifyRGB() end
--- <summary>
--- //Purges the cached data.
--- //Removes from memory the cached configurations and the atlas name dictionary.
--- //@since v0.99.3
--- static void purgeCachedData();
--- </summary>
function CCLabelBMFont:purgeCachedData() end
--- <summary>
--- void setAlignment(CCTextAlignment alignment);
--- </summary>
function CCLabelBMFont:setAlignment() end
--- <summary>
--- void setCString(const char *label);
--- </summary>
function CCLabelBMFont:setCString() end
--- <summary>
--- void setColor(const ccColor3B&amp; color);
--- </summary>
function CCLabelBMFont:setColor() end
--- <summary>
--- void setFntFile(const char* fntFile);
--- </summary>
function CCLabelBMFont:setFntFile() end
--- <summary>
--- void setLineBreakWithoutSpace(bool breakWithoutSpace);
--- </summary>
function CCLabelBMFont:setLineBreakWithoutSpace() end
--- <summary>
--- void setOpacity(GLubyte opacity);
--- </summary>
function CCLabelBMFont:setOpacity() end
--- <summary>
--- void setOpacityModifyRGB(bool isOpacityModifyRGB);
--- </summary>
function CCLabelBMFont:setOpacityModifyRGB() end
--- <summary>
--- void setScale(float scale);
--- </summary>
function CCLabelBMFont:setScale() end
--- <summary>
--- void setScaleX(float scaleX);
--- </summary>
function CCLabelBMFont:setScaleX() end
--- <summary>
--- void setScaleY(float scaleY);
--- </summary>
function CCLabelBMFont:setScaleY() end
--- <summary>
--- void setString(const char *label);
--- void setString(const char *label, bool fromUpdate);
--- </summary>
function CCLabelBMFont:setString() end
--- <summary>
--- void setWidth(float width);
--- </summary>
function CCLabelBMFont:setWidth() end

CCLabelTTF = class(CCSprite)
--- <summary>
--- //@js ctor
--- CCLabelTTF();
--- </summary>
function CCLabelTTF:new() end
function CCLabelTTF:new_local() end
--- <summary>
--- //creates a CCLabelTTF with a font name and font size in points
--- //@since v2.0.1
--- static CCLabelTTF * create(const char *string, const char *fontName, float fontSize);
--- 
--- //creates a CCLabelTTF from a fontname, horizontal alignment, dimension in points,  and font size in points.
--- //@since v2.0.1
--- static CCLabelTTF * create(const char *string, const char *fontName, float fontSize,const CCSize&amp; dimensions, CCTextAlignment hAlignment);
--- 
--- //creates a CCLabel from a fontname, alignment, dimension in points and font size in points
--- //@since v2.0.1
--- static CCLabelTTF * create(const char *string, const char *fontName, float fontSize,const CCSize&amp; dimensions, CCTextAlignment hAlignment, CCVerticalTextAlignment vAlignment);
--- 
--- //Creates an label.
--- static CCLabelTTF * create();
--- </summary>
--- <returns type="CCLabelTTF"></returns>
function CCLabelTTF:create() end
--- <summary>
--- CCSize getDimensions();
--- </summary>
--- <returns type="CCSize"></returns>
function CCLabelTTF:getDimensions() end
--- <summary>
--- const char* getFontName();
--- </summary>
function CCLabelTTF:getFontName() end
--- <summary>
--- float getFontSize();
--- </summary>
function CCLabelTTF:getFontSize() end
--- <summary>
--- CCTextAlignment getHorizontalAlignment();
--- </summary>
--- <returns type="CCTextAlignment"></returns>
function CCLabelTTF:getHorizontalAlignment() end
--- <summary>
--- const char* getString(void);
--- </summary>
function CCLabelTTF:getString() end
--- <summary>
--- CCVerticalTextAlignment getVerticalAlignment();
--- </summary>
--- <returns type="CCVerticalTextAlignment"></returns>
function CCLabelTTF:getVerticalAlignment() end
--- <summary>
--- //initializes the CCLabelTTF 
--- bool init();
--- </summary>
function CCLabelTTF:init() end
--- <summary>
--- void setDimensions(CCSize &amp;dim);
--- </summary>
function CCLabelTTF:setDimensions() end
--- <summary>
--- void setFontName(const char *fontName);
--- </summary>
function CCLabelTTF:setFontName() end
--- <summary>
--- void setFontSize(float fontSize);
--- </summary>
function CCLabelTTF:setFontSize() end
--- <summary>
--- void setHorizontalAlignment(CCTextAlignment alignment);
--- </summary>
function CCLabelTTF:setHorizontalAlignment() end
--- <summary>
--- //changes the string to render
--- //@warning Changing the string is as expensive as creating a new CCLabelTTF. To obtain better performance use CCLabelAtlas
--- virtual void setString(const char *label);
--- </summary>
function CCLabelTTF:setString() end
--- <summary>
--- void setVerticalAlignment(CCVerticalTextAlignment verticalAlignment);
--- </summary>
function CCLabelTTF:setVerticalAlignment() end

CCLayer = class(CCNode)
--- <summary>
--- //create one layer 
--- static CCLayer *create(void);
--- </summary>
--- <returns type="CCLayer"></returns>
function CCLayer:create() end
--- <summary>
--- virtual int getTouchMode();
--- </summary>
function CCLayer:getTouchMode() end
--- <summary>
--- virtual int getTouchPriority();
--- </summary>
function CCLayer:getTouchPriority() end
--- <summary>
--- //whether or not it will receive Accelerometer events
--- //You can enable / disable accelerometer events with this property.
--- //@since v0.8.1
--- virtual bool isAccelerometerEnabled();
--- </summary>
function CCLayer:isAccelerometerEnabled() end
--- <summary>
--- //whether or not it will receive keypad events
--- //You can enable / disable accelerometer events with this property.
--- //it's new in cocos2d-x
--- virtual bool isKeypadEnabled();
--- </summary>
function CCLayer:isKeypadEnabled() end
--- <summary>
--- //whether or not it will receive Touch events.
--- //You can enable / disable touch events with this property.
--- //Only the touches of this node will be affected. This "method" is not propagated to it's children.
--- //@since v0.8.1
--- virtual bool isTouchEnabled();
--- </summary>
function CCLayer:isTouchEnabled() end
--- <summary>
--- void registerScriptAccelerateHandler(LUA_FUNCTION nHandler);
--- </summary>
function CCLayer:registerScriptAccelerateHandler() end
--- <summary>
--- //Register keypad events handler 
--- void registerScriptKeypadHandler(int nHandler);
--- </summary>
function CCLayer:registerScriptKeypadHandler() end
--- <summary>
--- //Register script touch events handler 
--- virtual void registerScriptTouchHandler(int nHandler, bool bIsMultiTouches = false, int nPriority = INT_MIN, bool bSwallowsTouches = false);
--- </summary>
function CCLayer:registerScriptTouchHandler() end
--- <summary>
--- void setAccelerometerEnabled(bool bValue);
--- </summary>
function CCLayer:setAccelerometerEnabled() end
--- <summary>
--- void setKeypadEnabled(bool bValue);
--- </summary>
function CCLayer:setKeypadEnabled() end
--- <summary>
--- void setTouchEnabled(bool bValue);
--- </summary>
function CCLayer:setTouchEnabled() end
--- <summary>
--- virtual void setTouchMode(ccTouchesMode mode);
--- </summary>
function CCLayer:setTouchMode() end
--- <summary>
--- //priority of the touch events. Default is 0 
--- virtual void setTouchPriority(int priority);
--- </summary>
function CCLayer:setTouchPriority() end
--- <summary>
--- void unregisterScriptAccelerateHandler(void);
--- </summary>
function CCLayer:unregisterScriptAccelerateHandler() end
--- <summary>
--- //Unregister keypad events handler 
--- void unregisterScriptKeypadHandler(void);
--- </summary>
function CCLayer:unregisterScriptKeypadHandler() end
--- <summary>
--- //Unregister script touch events handler 
--- virtual void unregisterScriptTouchHandler(void);
--- </summary>
function CCLayer:unregisterScriptTouchHandler() end

CCLayerRGBA = class(CCLayer)
--- <summary>
--- //@js ctor
--- CCLayerRGBA();
--- </summary>
function CCLayerRGBA:new() end
function CCLayerRGBA:new_local() end
--- <summary>
--- static CCLayerRGBA* create();  
--- </summary>
--- <returns type="CCLayerRGBA"></returns>
function CCLayerRGBA:create() end
--- <summary>
--- virtual const ccColor3B&amp; getColor();
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCLayerRGBA:getColor() end
--- <summary>
--- virtual const ccColor3B&amp; getDisplayedColor();
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCLayerRGBA:getDisplayedColor() end
--- <summary>
--- virtual GLubyte getDisplayedOpacity();
--- </summary>
--- <returns type="GLubyte"></returns>
function CCLayerRGBA:getDisplayedOpacity() end
--- <summary>
--- virtual GLubyte getOpacity();
--- </summary>
--- <returns type="GLubyte"></returns>
function CCLayerRGBA:getOpacity() end
--- <summary>
--- virtual bool init();
--- </summary>
function CCLayerRGBA:init() end
--- <summary>
--- virtual bool isCascadeColorEnabled();
--- </summary>
function CCLayerRGBA:isCascadeColorEnabled() end
--- <summary>
--- virtual bool isCascadeOpacityEnabled();
--- </summary>
function CCLayerRGBA:isCascadeOpacityEnabled() end
--- <summary>
--- virtual bool isOpacityModifyRGB();
--- </summary>
function CCLayerRGBA:isOpacityModifyRGB() end
--- <summary>
--- virtual void setCascadeColorEnabled(bool cascadeColorEnabled);
--- </summary>
function CCLayerRGBA:setCascadeColorEnabled() end
--- <summary>
--- virtual void setCascadeOpacityEnabled(bool cascadeOpacityEnabled);
--- </summary>
function CCLayerRGBA:setCascadeOpacityEnabled() end
--- <summary>
--- virtual void setColor(const ccColor3B&amp; color);
--- </summary>
function CCLayerRGBA:setColor() end
--- <summary>
--- virtual void setOpacity(GLubyte opacity);
--- </summary>
function CCLayerRGBA:setOpacity() end
--- <summary>
--- virtual void setOpacityModifyRGB(bool bValue);
--- </summary>
function CCLayerRGBA:setOpacityModifyRGB() end
--- <summary>
--- virtual void updateDisplayedColor(const ccColor3B&amp; parentColor);
--- </summary>
function CCLayerRGBA:updateDisplayedColor() end
--- <summary>
--- virtual void updateDisplayedOpacity(GLubyte parentOpacity);
--- </summary>
function CCLayerRGBA:updateDisplayedOpacity() end
--- <summary>
--- //@js NA
--- //@lua NA
--- virtual ~CCLayerRGBA();
--- </summary>
function CCLayerRGBA:delete() end

CCLayerColor = class(CCLayerRGBA)
--- <summary>
--- //change height in Points
--- void changeHeight(GLfloat h);
--- </summary>
function CCLayerColor:changeHeight() end
--- <summary>
--- //change width in Points
--- void changeWidth(GLfloat w);
--- </summary>
function CCLayerColor:changeWidth() end
--- <summary>
--- //change width and height in Points
--- //@since v0.8
--- void changeWidthAndHeight(GLfloat w ,GLfloat h);
--- </summary>
function CCLayerColor:changeWidthAndHeight() end
--- <summary>
--- //creates a CCLayer with color, width and height in Points 
--- static CCLayerColor * create(const ccColor4B&amp; color, GLfloat width, GLfloat height);
--- 
--- //creates a CCLayer with color. Width and height are the window size. 
--- static CCLayerColor * create(const ccColor4B&amp; color);
--- </summary>
--- <returns type="CCLayerColor"></returns>
function CCLayerColor:create() end
--- <summary>
--- ccBlendFunc getBlendFunc(void);
--- </summary>
--- <returns type="ccBlendFunc"></returns>
function CCLayerColor:getBlendFunc() end
--- <summary>
--- ccColor3B getColor(void);
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCLayerColor:getColor() end
--- <summary>
--- GLubyte getOpacity(void);
--- </summary>
--- <returns type="GLubyte"></returns>
function CCLayerColor:getOpacity() end
--- <summary>
--- bool isOpacityModifyRGB(void);
--- </summary>
function CCLayerColor:isOpacityModifyRGB() end
--- <summary>
--- void setBlendFunc(ccBlendFunc Value);
--- </summary>
function CCLayerColor:setBlendFunc() end
--- <summary>
--- void setColor(ccColor3B Value);
--- </summary>
function CCLayerColor:setColor() end
--- <summary>
--- void setOpacity(GLubyte var);
--- </summary>
function CCLayerColor:setOpacity() end
--- <summary>
--- void setOpacityModifyRGB(bool bValue);
--- </summary>
function CCLayerColor:setOpacityModifyRGB() end

CCLayerGradient = class(CCLayerColor)
--- <summary>
--- //Creates a full-screen CCLayer with a gradient between start and end. 
--- static CCLayerGradient* create(const ccColor4B&amp; start, const ccColor4B&amp; end);
--- 
--- //Creates a full-screen CCLayer with a gradient between start and end in the direction of v. 
--- static CCLayerGradient* create(const ccColor4B&amp; start, const ccColor4B&amp; end, const CCPoint&amp; v);
--- </summary>
--- <returns type="CCLayerGradient"></returns>
function CCLayerGradient:create() end
--- <summary>
--- ccColor3B getEndColor(void);
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCLayerGradient:getEndColor() end
--- <summary>
--- GLubyte getEndOpacity(void);
--- </summary>
--- <returns type="GLubyte"></returns>
function CCLayerGradient:getEndOpacity() end
--- <summary>
--- ccColor3B getStartColor();
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCLayerGradient:getStartColor() end
--- <summary>
--- GLubyte getStartOpacity(void);
--- </summary>
--- <returns type="GLubyte"></returns>
function CCLayerGradient:getStartOpacity() end
--- <summary>
--- CCPoint getVector(void);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCLayerGradient:getVector() end
--- <summary>
--- bool isCompressedInterpolation(void);
--- </summary>
function CCLayerGradient:isCompressedInterpolation() end
--- <summary>
--- void setCompressedInterpolation(bool Value);
--- </summary>
function CCLayerGradient:setCompressedInterpolation() end
--- <summary>
--- void setEndColor(ccColor3B Value);
--- </summary>
function CCLayerGradient:setEndColor() end
--- <summary>
--- void setEndOpacity(GLubyte Value);
--- </summary>
function CCLayerGradient:setEndOpacity() end
--- <summary>
--- void setStartColor(ccColor3B colors);
--- </summary>
function CCLayerGradient:setStartColor() end
--- <summary>
--- void setStartOpacity(GLubyte Value);
--- </summary>
function CCLayerGradient:setStartOpacity() end
--- <summary>
--- void setVector(CCPoint Value);
--- </summary>
function CCLayerGradient:setVector() end

CCLayerMultiplex = class(CCLayer)
--- <summary>
--- void addLayer(CCLayer* layer);
--- </summary>
function CCLayerMultiplex:addLayer() end
--- <summary>
--- //@js NA
--- static CCLayerMultiplex* create();
--- 
--- //creates a CCLayerMultiplex with one or more layers using a variable argument list. 
--- //@lua NA
--- static CCLayerMultiplex * create(CCLayer* layer, ... );
--- </summary>
--- <returns type="CCLayerMultiplex"></returns>
function CCLayerMultiplex:create() end
--- <summary>
--- //creates a CCMultiplexLayer with an array of layers.
--- //@since v2.1
--- //@js NA
--- static CCLayerMultiplex* createWithArray(CCArray* arrayOfLayers);
--- </summary>
--- <returns type="CCLayerMultiplex"></returns>
function CCLayerMultiplex:createWithArray() end
--- <summary>
--- //lua script can not init with undetermined number of variables
--- //so add these functions to be used with lua.
--- static CCLayerMultiplex * createWithLayer(CCLayer* layer);
--- </summary>
--- <returns type="CCLayerMultiplex"></returns>
function CCLayerMultiplex:createWithLayer() end
--- <summary>
--- void switchTo(unsigned int n);
--- </summary>
function CCLayerMultiplex:switchTo() end
--- <summary>
--- //release the current layer and switches to another layer indexed by n.
--- //The current (old) layer will be removed from it's parent with 'cleanup:YES'.
--- void switchToAndReleaseMe(unsigned int n);
--- </summary>
function CCLayerMultiplex:switchToAndReleaseMe() end

CCMenu = class(CCLayerRGBA)
--- <summary>
--- void addChild(CCMenuItem* child, int zOrder = 0, int tag = -1);
--- </summary>
function CCMenu:addChild() end
--- <summary>
--- //align items horizontally 
--- void alignItemsHorizontally();
--- </summary>
function CCMenu:alignItemsHorizontally() end
--- <summary>
--- //align items horizontally with padding
--- //@since v0.7.2
--- void alignItemsHorizontallyWithPadding(float padding);
--- </summary>
function CCMenu:alignItemsHorizontallyWithPadding() end
--- <summary>
--- //@js NA
--- void alignItemsInColumnsWithArray(CCArray* rows);
--- </summary>
function CCMenu:alignItemsInColumnsWithArray() end
--- <summary>
--- //@js NA
--- void alignItemsInRowsWithArray(CCArray* columns);
--- </summary>
function CCMenu:alignItemsInRowsWithArray() end
--- <summary>
--- //align items vertically 
--- void alignItemsVertically();
--- </summary>
function CCMenu:alignItemsVertically() end
--- <summary>
--- //align items vertically with padding
--- //@since v0.7.2
--- void alignItemsVerticallyWithPadding(float padding);
--- </summary>
function CCMenu:alignItemsVerticallyWithPadding() end
--- <summary>
--- //creates an empty CCMenu 
--- static CCMenu* create();
--- 
--- //creates a CCMenu with CCMenuItem objects 
--- //@lua NA
--- static CCMenu* create(CCMenuItem* item, ...);
--- </summary>
--- <returns type="CCMenu"></returns>
function CCMenu:create() end
--- <summary>
--- //creates a CCMenu with a CCArray of CCMenuItem objects 
--- //@js NA
--- static CCMenu* createWithArray(CCArray* pArrayOfItems);
--- </summary>
--- <returns type="CCMenu"></returns>
function CCMenu:createWithArray() end
--- <summary>
--- //creates a CCMenu with it's item, then use addChild() to add 
--- //other items. It is used for script, it can't init with undetermined
--- //number of variables.
--- //@js NA
--- static CCMenu* createWithItem(CCMenuItem* item);
--- </summary>
--- <returns type="CCMenu"></returns>
function CCMenu:createWithItem() end
--- <summary>
--- ccColor3B getColor(void);
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCMenu:getColor() end
--- <summary>
--- GLubyte getOpacity(void);
--- </summary>
--- <returns type="GLubyte"></returns>
function CCMenu:getOpacity() end
--- <summary>
--- bool isEnabled();
--- </summary>
function CCMenu:isEnabled() end
--- <summary>
--- bool isOpacityModifyRGB(void);
--- </summary>
function CCMenu:isOpacityModifyRGB() end
--- <summary>
--- void setColor(ccColor3B color);
--- </summary>
function CCMenu:setColor() end
--- <summary>
--- void setEnabled(bool value);
--- </summary>
function CCMenu:setEnabled() end
--- <summary>
--- //set event handler priority. By default it is: kCCMenuTouchPriority 
--- void setHandlerPriority(int newPriority);
--- </summary>
function CCMenu:setHandlerPriority() end
--- <summary>
--- void setOpacity(GLubyte opacity);
--- </summary>
function CCMenu:setOpacity() end
--- <summary>
--- void setOpacityModifyRGB(bool bValue);
--- </summary>
function CCMenu:setOpacityModifyRGB() end

CCMenuItem = class(CCNodeRGBA)
--- <summary>
--- //Activate the item 
--- virtual void activate();
--- </summary>
function CCMenuItem:activate() end
--- <summary>
--- bool isEnabled();
--- </summary>
function CCMenuItem:isEnabled() end
--- <summary>
--- bool isSelected();
--- </summary>
function CCMenuItem:isSelected() end
--- <summary>
--- //Returns the outside box 
--- CCRect rect();
--- </summary>
--- <returns type="CCRect"></returns>
function CCMenuItem:rect() end
--- <summary>
--- //Register menu handler script function 
--- virtual void registerScriptTapHandler(int nHandler);
--- </summary>
function CCMenuItem:registerScriptTapHandler() end
--- <summary>
--- //The item was selected (not activated), similar to "mouse-over" 
--- virtual void selected();
--- </summary>
function CCMenuItem:selected() end
--- <summary>
--- void setEnabled(bool enabled);
--- </summary>
function CCMenuItem:setEnabled() end
--- <summary>
--- void unregisterScriptTapHandler(void);
--- </summary>
function CCMenuItem:unregisterScriptTapHandler() end
--- <summary>
--- //The item was unselected 
--- virtual void unselected();
--- </summary>
function CCMenuItem:unselected() end

CCMenuItemLabel = class(CCMenuItem)
--- <summary>
--- void activate();
--- </summary>
function CCMenuItemLabel:activate() end
--- <summary>
--- //creates a CCMenuItemLabel with a Label, target and selector 
--- //@lua NA
--- static CCMenuItemLabel * create(CCNode*label, CCObject* target, SEL_MenuHandler selector);
--- 
--- //creates a CCMenuItemLabel with a Label. Target and selector will be nil 
--- static CCMenuItemLabel* create(CCNode *label);
--- </summary>
--- <returns type="CCMenuItemLabel"></returns>
function CCMenuItemLabel:create() end
--- <summary>
--- ccColor3B getColor();
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCMenuItemLabel:getColor() end
--- <summary>
--- const ccColor3B &amp; getDisabledColor();
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCMenuItemLabel:getDisabledColor() end
--- <summary>
--- CCNode* getLabel();
--- </summary>
--- <returns type="CCNode"></returns>
function CCMenuItemLabel:getLabel() end
--- <summary>
--- GLubyte getOpacity();
--- </summary>
--- <returns type="GLubyte"></returns>
function CCMenuItemLabel:getOpacity() end
--- <summary>
--- bool isOpacityModifyRGB(void);
--- </summary>
function CCMenuItemLabel:isOpacityModifyRGB() end
--- <summary>
--- void selected();
--- </summary>
function CCMenuItemLabel:selected() end
--- <summary>
--- void setColor(ccColor3B color);
--- </summary>
function CCMenuItemLabel:setColor() end
--- <summary>
--- void setDisabledColor(const ccColor3B &amp; color);
--- </summary>
function CCMenuItemLabel:setDisabledColor() end
--- <summary>
--- //Enable or disabled the CCMenuItemFont
--- //@warning setEnabled changes the RGB color of the font
--- virtual void setEnabled(bool enabled);
--- </summary>
function CCMenuItemLabel:setEnabled() end
--- <summary>
--- void setLabel(CCNode* pLabel);
--- </summary>
function CCMenuItemLabel:setLabel() end
--- <summary>
--- void setOpacity(GLubyte opacity);
--- </summary>
function CCMenuItemLabel:setOpacity() end
--- <summary>
--- void setOpacityModifyRGB(bool bValue);
--- </summary>
function CCMenuItemLabel:setOpacityModifyRGB() end
--- <summary>
--- //sets a new string to the inner label 
--- void setString(const char * label);
--- </summary>
function CCMenuItemLabel:setString() end
--- <summary>
--- void unselected();
--- </summary>
function CCMenuItemLabel:unselected() end

CCMenuItemAtlasFont = class(CCMenuItemLabel)
--- <summary>
--- //creates a menu item from a string and atlas with a target/selector 
--- static CCMenuItemAtlasFont* create(const char *value, const char *charMapFile, int itemWidth, int itemHeight, char startCharMap);
--- 
--- //creates a menu item from a string and atlas. Use it with MenuItemToggle 
--- //@lua NA
--- static CCMenuItemAtlasFont* create(const char *value, const char *charMapFile, int itemWidth, int itemHeight, char startCharMap, CCObject* target, SEL_MenuHandler selector);
--- </summary>
--- <returns type="CCMenuItemAtlasFont"></returns>
function CCMenuItemAtlasFont:create() end

CCMenuItemFont = class(CCMenuItemLabel)
--- <summary>
--- //creates a menu item from a string without target/selector. To be used with CCMenuItemToggle 
--- static CCMenuItemFont * create(const char *value);
--- 
--- //creates a menu item from a string with a target/selector 
--- //@lua NA
--- static CCMenuItemFont * create(const char *value, CCObject* target, SEL_MenuHandler selector);
--- </summary>
--- <returns type="CCMenuItemFont"></returns>
function CCMenuItemFont:create() end
--- <summary>
--- //get the default font name 
--- static const char *fontName();
--- </summary>
function CCMenuItemFont:fontName() end
--- <summary>
--- //@js fontName
--- const char* fontNameObj();
--- </summary>
function CCMenuItemFont:fontNameObj() end
--- <summary>
--- //get default font size 
--- static unsigned int fontSize();
--- </summary>
function CCMenuItemFont:fontSize() end
--- <summary>
--- //get font size 
--- //@js fontSize
--- unsigned int fontSizeObj();
--- </summary>
function CCMenuItemFont:fontSizeObj() end
--- <summary>
--- //set the default font name 
--- static void setFontName(const char *name);
--- </summary>
function CCMenuItemFont:setFontName() end
--- <summary>
--- //set the font name 
--- //c++ can not overload static and non-static member functions with the same parameter types
--- //so change the name to setFontNameObj
--- //@js setFontName
--- void setFontNameObj(const char* name);
--- </summary>
function CCMenuItemFont:setFontNameObj() end
--- <summary>
--- //set default font size 
--- static void setFontSize(unsigned int s);
--- </summary>
function CCMenuItemFont:setFontSize() end
--- <summary>
--- //set font size
--- //c++ can not overload static and non-static member functions with the same parameter types
--- //so change the name to setFontSizeObj
--- //@js setFontSize
--- void setFontSizeObj(unsigned int s);
--- </summary>
function CCMenuItemFont:setFontSizeObj() end

CCMenuItemSprite = class(CCMenuItem)
--- <summary>
--- //creates a menu item with a normal, selected and disabled image
--- static CCMenuItemSprite * create(CCNode* normalSprite, CCNode* selectedSprite, CCNode* disabledSprite = NULL);
--- 
--- //creates a menu item with a normal and selected image with target/selector 
--- //@lua NA
--- static CCMenuItemSprite * create(CCNode* normalSprite, CCNode* selectedSprite, CCObject* target, SEL_MenuHandler selector);
--- 
--- //creates a menu item with a normal,selected  and disabled image with target/selector 
--- //@lua NA
--- static CCMenuItemSprite * create(CCNode* normalSprite, CCNode* selectedSprite, CCNode* disabledSprite, CCObject* target, SEL_MenuHandler selector);
--- </summary>
--- <returns type="CCMenuItemSprite"></returns>
function CCMenuItemSprite:create() end
--- <summary>
--- ccColor3B getColor();
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCMenuItemSprite:getColor() end
--- <summary>
--- CCNode* getDisabledImage();
--- </summary>
--- <returns type="CCNode"></returns>
function CCMenuItemSprite:getDisabledImage() end
--- <summary>
--- CCNode* getNormalImage();
--- </summary>
--- <returns type="CCNode"></returns>
function CCMenuItemSprite:getNormalImage() end
--- <summary>
--- GLubyte getOpacity();
--- </summary>
--- <returns type="GLubyte"></returns>
function CCMenuItemSprite:getOpacity() end
--- <summary>
--- CCNode* getSelectedImage();
--- </summary>
--- <returns type="CCNode"></returns>
function CCMenuItemSprite:getSelectedImage() end
--- <summary>
--- bool isOpacityModifyRGB(void);
--- </summary>
function CCMenuItemSprite:isOpacityModifyRGB() end
--- <summary>
--- //@since v0.99.5
--- virtual void selected();
--- </summary>
function CCMenuItemSprite:selected() end
--- <summary>
--- void setColor(ccColor3B color);
--- </summary>
function CCMenuItemSprite:setColor() end
--- <summary>
--- void setDisabledImage(CCNode* pImage);
--- </summary>
function CCMenuItemSprite:setDisabledImage() end
--- <summary>
--- void setEnabled(bool bEnabled);
--- </summary>
function CCMenuItemSprite:setEnabled() end
--- <summary>
--- void setNormalImage(CCNode* pImage);
--- </summary>
function CCMenuItemSprite:setNormalImage() end
--- <summary>
--- void setOpacity(GLubyte opacity);
--- </summary>
function CCMenuItemSprite:setOpacity() end
--- <summary>
--- void setOpacityModifyRGB(bool bValue);
--- </summary>
function CCMenuItemSprite:setOpacityModifyRGB() end
--- <summary>
--- void setSelectedImage(CCNode* pImage);
--- </summary>
function CCMenuItemSprite:setSelectedImage() end
--- <summary>
--- void unselected();
--- </summary>
function CCMenuItemSprite:unselected() end

CCMenuItemImage = class(CCMenuItemSprite)
--- <summary>
--- //creates a menu item with a normal and selected image
--- static CCMenuItemImage* create(const char *normalImage, const char *selectedImage);
--- 
--- //creates a menu item with a normal,selected  and disabled image
--- static CCMenuItemImage* create(const char *normalImage, const char *selectedImage, const char *disabledImage);
--- 
--- //creates a menu item with a normal and selected image with target/selector 
--- //@lua NA
--- static CCMenuItemImage* create(const char *normalImage, const char *selectedImage, CCObject* target, SEL_MenuHandler selector);
--- 
--- //creates a menu item with a normal,selected  and disabled image with target/selector 
--- //@lua NA
--- static CCMenuItemImage* create(const char *normalImage, const char *selectedImage, const char *disabledImage, CCObject* target, SEL_MenuHandler selector);
--- 
--- //Creates an CCMenuItemImage.
--- //@js NA
--- static CCMenuItemImage* create();
--- </summary>
--- <returns type="CCMenuItemImage"></returns>
function CCMenuItemImage:create() end
--- <summary>
--- ccColor3B getColor();
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCMenuItemImage:getColor() end
--- <summary>
--- GLubyte getOpacity();
--- </summary>
--- <returns type="GLubyte"></returns>
function CCMenuItemImage:getOpacity() end
--- <summary>
--- void setColor(ccColor3B color);
--- </summary>
function CCMenuItemImage:setColor() end
--- <summary>
--- //sets the sprite frame for the disabled image 
--- void setDisabledSpriteFrame(CCSpriteFrame* frame);
--- </summary>
function CCMenuItemImage:setDisabledSpriteFrame() end
--- <summary>
--- //sets the sprite frame for the normal image 
--- void setNormalSpriteFrame(CCSpriteFrame* frame);
--- </summary>
function CCMenuItemImage:setNormalSpriteFrame() end
--- <summary>
--- void setOpacity(GLubyte opacity);
--- </summary>
function CCMenuItemImage:setOpacity() end
--- <summary>
--- //sets the sprite frame for the selected image 
--- void setSelectedSpriteFrame(CCSpriteFrame* frame);
--- </summary>
function CCMenuItemImage:setSelectedSpriteFrame() end

CCMenuItemToggle = class(CCMenuItem)
--- <summary>
--- void activate();
--- </summary>
function CCMenuItemToggle:activate() end
--- <summary>
--- //add more menu item 
--- void addSubItem(CCMenuItem *item);
--- </summary>
function CCMenuItemToggle:addSubItem() end
--- <summary>
--- //creates a menu item with no target/selector and no items 
--- //@js NA
--- //@lua NA
--- static CCMenuItemToggle* create();
--- 
--- //creates a menu item with a item 
--- static CCMenuItemToggle* create(CCMenuItem *item);
--- </summary>
--- <returns type="CCMenuItemToggle"></returns>
function CCMenuItemToggle:create() end
--- <summary>
--- ccColor3B getColor();
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCMenuItemToggle:getColor() end
--- <summary>
--- GLubyte getOpacity();
--- </summary>
--- <returns type="GLubyte"></returns>
function CCMenuItemToggle:getOpacity() end
--- <summary>
--- unsigned int getSelectedIndex();
--- </summary>
function CCMenuItemToggle:getSelectedIndex() end
--- <summary>
--- CCArray* getSubItems();
--- </summary>
--- <returns type="CCArray"></returns>
function CCMenuItemToggle:getSubItems() end
--- <summary>
--- bool isOpacityModifyRGB(void);
--- </summary>
function CCMenuItemToggle:isOpacityModifyRGB() end
--- <summary>
--- void selected();
--- </summary>
function CCMenuItemToggle:selected() end
--- <summary>
--- //return the selected item 
--- CCMenuItem* selectedItem();
--- </summary>
--- <returns type="CCMenuItem"></returns>
function CCMenuItemToggle:selectedItem() end
--- <summary>
--- void setColor(ccColor3B color);
--- </summary>
function CCMenuItemToggle:setColor() end
--- <summary>
--- void setEnabled(bool var);
--- </summary>
function CCMenuItemToggle:setEnabled() end
--- <summary>
--- void setOpacity(GLubyte opacity);
--- </summary>
function CCMenuItemToggle:setOpacity() end
--- <summary>
--- void setOpacityModifyRGB(bool bValue);
--- </summary>
function CCMenuItemToggle:setOpacityModifyRGB() end
--- <summary>
--- void setSelectedIndex(unsigned int index);
--- </summary>
function CCMenuItemToggle:setSelectedIndex() end
--- <summary>
--- void setSubItems(CCArray* pArrayOfItems);
--- </summary>
function CCMenuItemToggle:setSubItems() end
--- <summary>
--- void unselected();
--- </summary>
function CCMenuItemToggle:unselected() end

CCMotionStreak = class(CCNodeRGBA)
--- <summary>
--- //creates and initializes a motion streak with fade in seconds, minimum segments, stroke's width, color, texture filename 
--- static CCMotionStreak* create(float fade, float minSeg, float stroke, const ccColor3B&amp; color, const char* path);
--- 
--- //creates and initializes a motion streak with fade in seconds, minimum segments, stroke's width, color, texture 
--- static CCMotionStreak* create(float fade, float minSeg, float stroke, const ccColor3B&amp; color, CCTexture2D* texture);
--- </summary>
--- <returns type="CCMotionStreak"></returns>
function CCMotionStreak:create() end
--- <summary>
--- //@js NA
--- virtual ccBlendFunc getBlendFunc(void);
--- </summary>
--- <returns type="ccBlendFunc"></returns>
function CCMotionStreak:getBlendFunc() end
--- <summary>
--- const ccColor3B&amp; getColor(void);
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCMotionStreak:getColor() end
--- <summary>
--- GLubyte getOpacity(void);
--- </summary>
--- <returns type="GLubyte"></returns>
function CCMotionStreak:getOpacity() end
--- <summary>
--- CCTexture2D* getTexture(void);
--- </summary>
--- <returns type="CCTexture2D"></returns>
function CCMotionStreak:getTexture() end
--- <summary>
--- //When fast mode is enabled, new points are added faster but with lower precision 
--- inline bool isFastMode();
--- </summary>
function CCMotionStreak:isFastMode() end
--- <summary>
--- bool isOpacityModifyRGB(void);
--- </summary>
function CCMotionStreak:isOpacityModifyRGB() end
--- <summary>
--- bool isStartingPositionInitialized();
--- </summary>
function CCMotionStreak:isStartingPositionInitialized() end
--- <summary>
--- //Remove all living segments of the ribbon 
--- void reset();
--- </summary>
function CCMotionStreak:reset() end
--- <summary>
--- //@js NA
--- virtual void setBlendFunc(ccBlendFunc blendFunc);
--- </summary>
function CCMotionStreak:setBlendFunc() end
--- <summary>
--- void setColor(const ccColor3B&amp; color);
--- </summary>
function CCMotionStreak:setColor() end
--- <summary>
--- void setFastMode(bool bFastMode);
--- </summary>
function CCMotionStreak:setFastMode() end
--- <summary>
--- void setOpacity(GLubyte opacity);
--- </summary>
function CCMotionStreak:setOpacity() end
--- <summary>
--- void setOpacityModifyRGB(bool bValue);
--- </summary>
function CCMotionStreak:setOpacityModifyRGB() end
--- <summary>
--- void setStartingPositionInitialized(bool bStartingPositionInitialized);
--- </summary>
function CCMotionStreak:setStartingPositionInitialized() end
--- <summary>
--- void setTexture(CCTexture2D *texture);
--- </summary>
function CCMotionStreak:setTexture() end
--- <summary>
--- //color used for the tint 
--- void tintWithColor(ccColor3B colors);
--- </summary>
function CCMotionStreak:tintWithColor() end

CCNode = class(CCObject)
--- <summary>
--- //Adds a child to the container with z-order as 0.
--- //If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.
--- //@param child A child node
--- virtual void addChild(CCNode * child);
--- 
--- //Adds a child to the container with a z-order
--- //If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.
--- //@param child     A child node
--- //@param zOrder    Z order for drawing priority. Please refer to setZOrder(int)
--- virtual void addChild(CCNode * child, int zOrder);
--- 
--- //Adds a child to the container with z order and tag
--- //If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.
--- //@param child     A child node
--- //@param zOrder    Z order for drawing priority. Please refer to setZOrder(int)
--- //@param tag       A interger to identify the node easily. Please refer to setTag(int)
--- virtual void addChild(CCNode* child, int zOrder, int tag);
--- </summary>
function CCNode:addChild() end
--- <summary>
--- //Returns a "local" axis aligned bounding box of the node.
--- //The returned box is relative only to its parent.
--- //@note This method returns a temporaty variable, so it can't returns const CCRect&amp;
--- //@todo Rename to getBoundingBox() in the future versions.
--- //@return A "local" axis aligned boudning box of the node.
--- //@js getBoundingBox
--- CCRect boundingBox(void);
--- </summary>
--- <returns type="CCRect"></returns>
function CCNode:boundingBox() end
--- <summary>
--- //Stops all running actions and schedulers
--- virtual void cleanup(void);
--- </summary>
function CCNode:cleanup() end
--- <summary>
--- //Converts a Point to node (local) space coordinates. The result is in Points.
--- CCPoint convertToNodeSpace(const CCPoint&amp; worldPoint);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCNode:convertToNodeSpace() end
--- <summary>
--- //Converts a Point to node (local) space coordinates. The result is in Points.
--- //treating the returned/received node point as anchor relative.
--- CCPoint convertToNodeSpaceAR(const CCPoint&amp; worldPoint);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCNode:convertToNodeSpaceAR() end
--- <summary>
--- //Converts a Point to world space coordinates. The result is in Points.
--- CCPoint convertToWorldSpace(const CCPoint&amp; nodePoint);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCNode:convertToWorldSpace() end
--- <summary>
--- //Converts a local Point to world space coordinates.The result is in Points.
--- //treating the returned/received node point as anchor relative.
--- CCPoint convertToWorldSpaceAR(const CCPoint&amp; nodePoint);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCNode:convertToWorldSpaceAR() end
--- <summary>
--- //convenience methods which take a CCTouch instead of CCPoint
--- CCPoint convertTouchToNodeSpace(CCTouch * touch);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCNode:convertTouchToNodeSpace() end
--- <summary>
--- //converts a CCTouch (world coordinates) into a local coordinate. This method is AR (Anchor Relative).
--- CCPoint convertTouchToNodeSpaceAR(CCTouch * touch);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCNode:convertTouchToNodeSpaceAR() end
--- <summary>
--- //Allocates and initializes a node.
--- //@return A initialized node which is marked as "autorelease".
--- static CCNode * create(void);
--- </summary>
--- <returns type="CCNode"></returns>
function CCNode:create() end
--- <summary>
--- //Gets the description string. It makes debugging easier.
--- //@return A string terminated with '\0'
--- //@js NA
--- const char* description(void);
--- </summary>
function CCNode:description() end
--- <summary>
--- //Override this method to draw your own node.
--- //The following GL states will be enabled by default:
--- //- glEnableClientState(GL_VERTEX_ARRAY);
--- //- glEnableClientState(GL_COLOR_ARRAY);
--- //- glEnableClientState(GL_TEXTURE_COORD_ARRAY);
--- //- glEnable(GL_TEXTURE_2D);
--- //AND YOU SHOULD NOT DISABLE THEM AFTER DRAWING YOUR NODE
--- //But if you enable any other GL state, you should disable it after drawing your node.
--- virtual void draw(void);
--- </summary>
function CCNode:draw() end
--- <summary>
--- //Gets an action from the running action list by its tag.
--- //@see setTag(int), getTag().
--- //@return The action object with the given tag.
--- CCAction* getActionByTag(int tag);
--- </summary>
--- <returns type="CCAction"></returns>
function CCNode:getActionByTag() end
--- <summary>
--- //Gets the CCActionManager object that is used by all actions.
--- //@see setActionManager(CCActionManager*)
--- //@return A CCActionManager object.
--- virtual CCActionManager* getActionManager();
--- </summary>
--- <returns type="CCActionManager"></returns>
function CCNode:getActionManager() end
--- <summary>
--- //Returns the anchor point in percent.
--- //@see setAnchorPoint(const CCPoint&amp;)
--- //@return The anchor point of node.
--- virtual const CCPoint&amp; getAnchorPoint();
--- </summary>
--- <returns type="CCPoint"></returns>
function CCNode:getAnchorPoint() end
--- <summary>
--- //Returns the anchorPoint in absolute pixels.
--- //@warning You can only read it. If you wish to modify it, use anchorPoint instead.
--- //@see getAnchorPoint()
--- //@return The anchor point in absolute pixels.
--- virtual const CCPoint&amp; getAnchorPointInPoints();
--- </summary>
--- <returns type="CCPoint"></returns>
function CCNode:getAnchorPointInPoints() end
--- <summary>
--- //Returns a camera object that lets you move the node using a gluLookAt
--- //@code
--- //CCCamera* camera = node->getCamera();
--- //camera->setEyeXYZ(0, 0, 415/2);
--- //camera->setCenterXYZ(0, 0, 0);
--- //@endcode
--- //@return A CCCamera object that lets you move the node using a gluLookAt
--- virtual CCCamera* getCamera();
--- </summary>
--- <returns type="CCCamera"></returns>
function CCNode:getCamera() end
--- <summary>
--- //Gets a child from the container with its tag
--- //@param tag   An identifier to find the child node.
--- //@return a CCNode object whose tag equals to the input parameter
--- virtual CCNode * getChildByTag(int tag);
--- </summary>
--- <returns type="CCNode"></returns>
function CCNode:getChildByTag() end
--- <summary>
--- //Return an array of children
--- //Composing a "tree" structure is a very important feature of CCNode
--- //Here's a sample code of traversing children array:
--- //@code
--- //CCNode* node = NULL;
--- //CCARRAY_FOREACH(parent->getChildren(), node)
--- //{
--- //node->setPosition(0,0);
--- //}
--- //@endcode
--- //This sample code traverses all children nodes, and set theie position to (0,0)
--- //@return An array of children
--- virtual CCArray* getChildren();
--- </summary>
--- <returns type="CCArray"></returns>
function CCNode:getChildren() end
--- <summary>
--- //Get the amount of children.
--- //@return The amount of children.
--- virtual unsigned int getChildrenCount(void) const;
--- </summary>
function CCNode:getChildrenCount() end
--- <summary>
--- //gets a component by its name
--- CCComponent* getComponent(const char *pName) const;
--- </summary>
--- <returns type="CCComponent"></returns>
function CCNode:getComponent() end
--- <summary>
--- //Returns the untransformed size of the node.
--- //@see setContentSize(const CCSize&amp;)
--- //@return The untransformed size of the node.
--- virtual const CCSize&amp; getContentSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function CCNode:getContentSize() end
--- <summary>
--- //Returns the state of OpenGL server side.
--- //@return The state of OpenGL server side.
--- //@js NA
--- virtual ccGLServerState getGLServerState();
--- </summary>
--- <returns type="ccGLServerState"></returns>
function CCNode:getGLServerState() end
--- <summary>
--- //Returns a grid object that is used when applying effects
--- //@return A CCGrid object that is used when applying effects
--- //@js NA
--- virtual CCGridBase* getGrid();
--- </summary>
--- <returns type="CCGridBase"></returns>
function CCNode:getGrid() end
--- <summary>
--- //Returns the arrival order, indecates which children is added previously.
--- //@see setOrderOfArrival(unsigned int)
--- //@return The arrival order.
--- virtual unsigned int getOrderOfArrival();
--- </summary>
function CCNode:getOrderOfArrival() end
--- <summary>
--- //Returns a pointer to the parent node
--- //@see setParent(CCNode*)
--- //@returns A pointer to the parnet node
--- virtual CCNode* getParent();
--- </summary>
--- <returns type="CCNode"></returns>
function CCNode:getParent() end
--- <summary>
--- //Gets the position (x,y) of the node in OpenGL coordinates
--- //@see setPosition(const CCPoint&amp;)
--- //@return The position (x,y) of the node in OpenGL coordinates
--- virtual const CCPoint&amp; getPosition();
--- 
--- //Gets position in a more efficient way, returns two number instead of a CCPoint object
--- //@see setPosition(float, float)
--- virtual void getPosition(float* x, float* y);
--- </summary>
function CCNode:getPosition() end
--- <summary>
--- float   getPositionX();
--- </summary>
function CCNode:getPositionX() end
--- <summary>
--- float   getPositionY();
--- </summary>
function CCNode:getPositionY() end
--- <summary>
--- //Returns the rotation of the node in degrees.
--- //@see setRotation(float)
--- //@return The rotation of the node in degrees.
--- virtual float getRotation();
--- </summary>
function CCNode:getRotation() end
--- <summary>
--- //Gets the scale factor of the node,  when X and Y have the same scale factor.
--- //@warning Assert when m_fScaleX != m_fScaleY.
--- //@see setScale(float)
--- //@return The scale factor of the node.
--- virtual float getScale();
--- </summary>
function CCNode:getScale() end
--- <summary>
--- //Returns the scale factor on X axis of this node
--- //@see setScaleX(float)
--- //@return The scale factor on X axis.
--- virtual float getScaleX();
--- </summary>
function CCNode:getScaleX() end
--- <summary>
--- //Returns the scale factor on Y axis of this node
--- //@see setScaleY(float)
--- //@return The scale factor on Y axis. 
--- virtual float getScaleY();
--- </summary>
function CCNode:getScaleY() end
--- <summary>
--- //Gets a CCSheduler object.
--- //@see setScheduler(CCScheduler*)
--- //@return A CCScheduler object.
--- //@js NA
--- virtual CCScheduler* getScheduler();
--- </summary>
--- <returns type="CCScheduler"></returns>
function CCNode:getScheduler() end
--- <summary>
--- //Return the shader program currently used for this node
--- //@return The shader program currelty used for this node
--- virtual CCGLProgram* getShaderProgram();
--- </summary>
--- <returns type="CCGLProgram"></returns>
function CCNode:getShaderProgram() end
--- <summary>
--- //Returns the X skew angle of the node in degrees.
--- //@see setSkewX(float)
--- //@return The X skew angle of the node in degrees.
--- virtual float getSkewX();
--- </summary>
function CCNode:getSkewX() end
--- <summary>
--- //Returns the Y skew angle of the node in degrees.
--- //@see setSkewY(float)
--- //@return The Y skew angle of the node in degrees.
--- virtual float getSkewY();
--- </summary>
function CCNode:getSkewY() end
--- <summary>
--- //Returns a tag that is used to identify the node easily.
--- //You can set tags to node then identify them easily.
--- //@code
--- //#define TAG_PLAYER  1
--- //#define TAG_MONSTER 2
--- //#define TAG_BOSS    3
--- //// set tags
--- //node1->setTag(TAG_PLAYER);
--- //node2->setTag(TAG_MONSTER);
--- //node3->setTag(TAG_BOSS);
--- //parent->addChild(node1);
--- //parent->addChild(node2);
--- //parent->addChild(node3);
--- //// identify by tags
--- //CCNode* node = NULL;
--- //CCARRAY_FOREACH(parent->getChildren(), node)
--- //{
--- //switch(node->getTag())
--- //{
--- //case TAG_PLAYER:
--- //break;
--- //case TAG_MONSTER:
--- //break;
--- //case TAG_BOSS:
--- //break;
--- //}
--- //}
--- //@endcode
--- //@return A interger that identifies the node.
--- virtual int getTag() const;
--- </summary>
function CCNode:getTag() end
--- <summary>
--- //Returns a custom user data pointer
--- //You can set everything in UserData pointer, a data block, a structure or an object.
--- //@return A custom user data pointer
--- //@js NA
--- virtual void* getUserData();
--- </summary>
function CCNode:getUserData() end
--- <summary>
--- //Returns a user assigned CCObject
--- //Similar to userData, but instead of holding a void* it holds an object
--- //@return A user assigned CCObject
--- //@js NA
--- virtual CCObject* getUserObject();
--- </summary>
--- <returns type="CCObject"></returns>
function CCNode:getUserObject() end
--- <summary>
--- //Gets OpenGL Z vertex of this node.
--- //@see setVertexZ(float)
--- //@return OpenGL Z vertex of this node
--- virtual float getVertexZ();
--- </summary>
function CCNode:getVertexZ() end
--- <summary>
--- //Gets the Z order of this node.
--- //@see setZOrder(int)
--- //@return The Z order.
--- virtual int getZOrder();
--- </summary>
function CCNode:getZOrder() end
--- <summary>
--- //Sets whether the anchor point will be (0,0) when you position this node.
--- //This is an internal method, only used by CCLayer and CCScene. Don't call it outside framework.
--- //The default value is false, while in CCLayer and CCScene are true
--- //@param ignore    true if anchor point will be (0,0) when you position this node
--- //@todo This method shoud be renamed as setIgnoreAnchorPointForPosition(bool) or something with "set"
--- virtual void ignoreAnchorPointForPosition(bool ignore);
--- </summary>
function CCNode:ignoreAnchorPointForPosition() end
--- <summary>
--- //Gets whether the anchor point will be (0,0) when you position this node.
--- //@see ignoreAnchorPointForPosition(bool)
--- //@return true if the anchor point will be (0,0) when you position this node.
--- virtual bool isIgnoreAnchorPointForPosition();
--- </summary>
function CCNode:isIgnoreAnchorPointForPosition() end
--- <summary>
--- //Returns whether or not the node accepts event callbacks.
--- //Running means the node accept event callbacks like onEnter(), onExit(), update()
--- //@return Whether or not the node is running.
--- virtual bool isRunning();
--- </summary>
function CCNode:isRunning() end
--- <summary>
--- //Determines if the node is visible
--- //@see setVisible(bool)
--- //@return true if the node is visible, false if the node is hidden.
--- virtual bool isVisible();
--- </summary>
function CCNode:isVisible() end
--- <summary>
--- //Returns the matrix that transform the node's (local) space coordinates into the parent's space coordinates.
--- //The matrix is in Pixels.
--- virtual CCAffineTransform nodeToParentTransform(void);
--- </summary>
--- <returns type="CCAffineTransform"></returns>
function CCNode:nodeToParentTransform() end
--- <summary>
--- //Returns the world affine transform matrix. The matrix is in Pixels.
--- virtual CCAffineTransform nodeToWorldTransform(void);
--- </summary>
--- <returns type="CCAffineTransform"></returns>
function CCNode:nodeToWorldTransform() end
--- <summary>
--- //Returns the numbers of actions that are running plus the ones that are schedule to run (actions in actionsToAdd and actions arrays).
--- //Composable actions are counted as 1 action. Example:
--- //If you are running 1 Sequence of 7 actions, it will return 1.
--- //If you are running 7 Sequences of 2 actions, it will return 7.
--- //@todo Rename to getNumberOfRunningActions()
--- //@return The number of actions that are running plus the ones that are schedule to run
--- unsigned int numberOfRunningActions(void);
--- </summary>
function CCNode:numberOfRunningActions() end
--- <summary>
--- //Returns the matrix that transform parent's space coordinates to the node's (local) space coordinates.
--- //The matrix is in Pixels.
--- virtual CCAffineTransform parentToNodeTransform(void);
--- </summary>
--- <returns type="CCAffineTransform"></returns>
function CCNode:parentToNodeTransform() end
--- <summary>
--- //Registers a script function that will be called in onEnter() &amp; onExit() seires functions.
--- //This handler will be removed automatically after onExit() called.
--- //@code
--- //-- lua sample
--- //local function sceneEventHandler(eventType)
--- //if eventType == kCCNodeOnEnter then
--- //-- do something
--- //elseif evetType == kCCNodeOnExit then
--- //-- do something
--- //end
--- //end
--- //scene::registerScriptHandler(sceneEventHandler)
--- //@endcode
--- //@warning This method is for internal usage, don't call it manually.
--- //@todo Perhaps we should rename it to get/set/removeScriptHandler acoording to the function name style.
--- //@param handler   A number that indicates a lua function. 
--- virtual void registerScriptHandler(int handler);
--- </summary>
function CCNode:registerScriptHandler() end
--- <summary>
--- //Removes all children from the container, and do a cleanup to all running actions depending on the cleanup parameter.
--- //@param cleanup   true if all running actions on all children nodes should be cleanup, false oterwise.
--- //@js removeAllChildren
--- virtual void removeAllChildrenWithCleanup(bool cleanup);
--- </summary>
function CCNode:removeAllChildrenWithCleanup() end
--- <summary>
--- //Removes a child from the container with a cleanup
--- //@see removeChild(CCNode, bool)
--- //@param child     The child node which will be removed.
--- virtual void removeChild(CCNode* child);
--- 
--- //Removes a child from the container. It will also cleanup all running actions depending on the cleanup parameter.
--- //@param child     The child node which will be removed.
--- //@param cleanup   true if all running actions and callbacks on the child node will be cleanup, false otherwise.
--- virtual void removeChild(CCNode* child, bool cleanup);
--- </summary>
function CCNode:removeChild() end
--- <summary>
--- //Removes a child from the container by tag value with a cleanup.
--- //@see removeChildByTag(int, bool)
--- //@param tag       An interger number that identifies a child node
--- virtual void removeChildByTag(int tag);
--- 
--- //Removes a child from the container by tag value. It will also cleanup all running actions depending on the cleanup parameter
--- //@param tag       An interger number that identifies a child node
--- //@param cleanup   true if all running actions and callbacks on the child node will be cleanup, false otherwise. 
--- virtual void removeChildByTag(int tag, bool cleanup);
--- </summary>
function CCNode:removeChildByTag() end
--- <summary>
--- //Removes this node itself from its parent node. 
--- //If the node orphan, then nothing happens.
--- //@param cleanup   true if all actions and callbacks on this node should be removed, false otherwise.
--- //@js removeFromParent
--- virtual void removeFromParentAndCleanup(bool cleanup);
--- </summary>
function CCNode:removeFromParentAndCleanup() end
--- <summary>
--- //Reorders a child according to a new z value.
--- //@param child     An already added child node. It MUST be already added.
--- //@param zOrder    Z order for drawing priority. Please refer to setZOrder(int)
--- virtual void reorderChild(CCNode * child, int zOrder);
--- </summary>
function CCNode:reorderChild() end
--- <summary>
--- //Executes an action, and returns the action that is executed.
--- //This node becomes the action's target. Refer to CCAction::getTarget()
--- //@warning Actions don't retain their target.
--- //@return An Action pointer
--- CCAction* runAction(CCAction* action);
--- </summary>
--- <returns type="CCAction"></returns>
function CCNode:runAction() end
--- <summary>
--- //Schedules for lua script. 
--- //@js NA
--- void scheduleUpdateWithPriorityLua(int nHandler, int priority);
--- </summary>
function CCNode:scheduleUpdateWithPriorityLua() end
--- <summary>
--- //Sets the CCActionManager object that is used by all actions.
--- //@warning If you set a new CCActionManager, then previously created actions will be removed.
--- //@param actionManager     A CCActionManager object that is used by all actions.
--- virtual void setActionManager(CCActionManager* actionManager);
--- </summary>
function CCNode:setActionManager() end
--- <summary>
--- //Sets the anchor point in percent.
--- //anchorPoint is the point around which all transformations and positioning manipulations take place.
--- //It's like a pin in the node where it is "attached" to its parent.
--- //The anchorPoint is normalized, like a percentage. (0,0) means the bottom-left corner and (1,1) means the top-right corner.
--- //But you can use values higher than (1,1) and lower than (0,0) too.
--- //The default anchorPoint is (0.5,0.5), so it starts in the center of the node.
--- //@param anchorPoint   The anchor point of node.
--- virtual void setAnchorPoint(const CCPoint&amp; anchorPoint);
--- </summary>
function CCNode:setAnchorPoint() end
--- <summary>
--- //Sets the untransformed size of the node.
--- //The contentSize remains the same no matter the node is scaled or rotated.
--- //All nodes has a size. Layer and Scene has the same size of the screen.
--- //@param contentSize   The untransformed size of the node.
--- virtual void setContentSize(const CCSize&amp; contentSize);
--- </summary>
function CCNode:setContentSize() end
--- <summary>
--- //Sets the state of OpenGL server side.
--- //@param glServerState     The state of OpenGL server side.
--- //@js NA
--- virtual void setGLServerState(ccGLServerState glServerState);
--- </summary>
function CCNode:setGLServerState() end
--- <summary>
--- //Changes a grid object that is used when applying effects
--- //@param A CCGrid object that is used when applying effects
--- virtual void setGrid(CCGridBase *pGrid);
--- </summary>
function CCNode:setGrid() end
--- <summary>
--- //Sets the arrival order when this node has a same ZOrder with other children.
--- //A node which called addChild subsequently will take a larger arrival order,
--- //If two children have the same Z order, the child with larger arrival order will be drawn later.
--- //@warning This method is used internally for zOrder sorting, don't change this manually
--- //@param uOrderOfArrival   The arrival order.
--- virtual void setOrderOfArrival(unsigned int uOrderOfArrival);
--- </summary>
function CCNode:setOrderOfArrival() end
--- <summary>
--- //Sets the parent node
--- //@param parent    A pointer to the parnet node
--- virtual void setParent(CCNode* parent);
--- </summary>
function CCNode:setParent() end
--- <summary>
--- //Changes the position (x,y) of the node in OpenGL coordinates
--- //Usually we use ccp(x,y) to compose CCPoint object.
--- //The original point (0,0) is at the left-bottom corner of screen.
--- //For example, this codesnip sets the node in the center of screen.
--- //@code
--- //CCSize size = CCDirector::sharedDirector()->getWinSize();
--- //node->setPosition( ccp(size.width/2, size.height/2) )
--- //@endcode
--- //@param position  The position (x,y) of the node in OpenGL coordinates
--- //@js NA
--- virtual void setPosition(const CCPoint &amp;position);
--- 
--- //Sets position in a more efficient way.
--- //Passing two numbers (x,y) is much efficient than passing CCPoint object.
--- //This method is binded to lua and javascript. 
--- //Passing a number is 10 times faster than passing a object from lua to c++
--- //@code
--- //// sample code in lua
--- //local pos  = node::getPosition()  -- returns CCPoint object from C++
--- //node:setPosition(x, y)            -- pass x, y coordinate to C++
--- //@endcode
--- //@param x     X coordinate for position
--- //@param y     Y coordinate for position
--- //@js NA
--- virtual void setPosition(float x, float y);
--- </summary>
function CCNode:setPosition() end
--- <summary>
--- //Gets/Sets x or y coordinate individually for position.
--- //These methods are used in Lua and Javascript Bindings
--- virtual void setPositionX(float x);
--- </summary>
function CCNode:setPositionX() end
--- <summary>
--- void    setPositionY(float y);
--- </summary>
function CCNode:setPositionY() end
--- <summary>
--- //Sets the rotation (angle) of the node in degrees. 
--- //0 is the default rotation angle. 
--- //Positive values rotate node clockwise, and negative values for anti-clockwise.
--- //@param fRotation     The roration of the node in degrees.
--- virtual void setRotation(float fRotation);
--- </summary>
function CCNode:setRotation() end
--- <summary>
--- //Changes both X and Y scale factor of the node.
--- //1.0 is the default scale factor. It modifies the X and Y scale at the same time.
--- //@param scale     The scale factor for both X and Y axis.
--- virtual void setScale(float scale);
--- 
--- //Changes both X and Y scale factor of the node.
--- //1.0 is the default scale factor. It modifies the X and Y scale at the same time.
--- //@param fScaleX     The scale factor on X axis.
--- //@param fScaleY     The scale factor on Y axis.
--- virtual void setScale(float fScaleX,float fScaleY);
--- </summary>
function CCNode:setScale() end
--- <summary>
--- //Changes the scale factor on X axis of this node
--- //The deafult value is 1.0 if you haven't changed it before
--- //@param fScaleX   The scale factor on X axis.
--- virtual void setScaleX(float fScaleX);
--- </summary>
function CCNode:setScaleX() end
--- <summary>
--- //Changes the scale factor on Y axis of this node
--- //The Default value is 1.0 if you haven't changed it before.
--- //@param fScaleY   The scale factor on Y axis.
--- virtual void setScaleY(float fScaleY);
--- </summary>
function CCNode:setScaleY() end
--- <summary>
--- //Sets a CCScheduler object that is used to schedule all "updates" and timers.
--- //@warning If you set a new CCScheduler, then previously created timers/update are going to be removed.
--- //@param scheduler     A CCShdeduler object that is used to schedule all "update" and timers.
--- //@js NA
--- virtual void setScheduler(CCScheduler* scheduler);
--- </summary>
function CCNode:setScheduler() end
--- <summary>
--- //Sets the shader program for this node
--- //Since v2.0, each rendering node must set its shader program.
--- //It should be set in initialize phase.
--- //@code
--- //node->setShaderProgram(CCShaderCache::sharedShaderCache()->programForKey(kCCShader_PositionTextureColor));
--- //@endcode
--- //@param The shader program which fetchs from CCShaderCache.
--- virtual void setShaderProgram(CCGLProgram *pShaderProgram);
--- </summary>
function CCNode:setShaderProgram() end
--- <summary>
--- //Changes the X skew angle of the node in degrees.
--- //This angle describes the shear distortion in the X direction.
--- //Thus, it is the angle between the Y axis and the left edge of the shape
--- //The default skewX angle is 0. Positive values distort the node in a CW direction.
--- //@param fSkewX The X skew angle of the node in degrees.
--- virtual void setSkewX(float fSkewX);
--- </summary>
function CCNode:setSkewX() end
--- <summary>
--- //Changes the Y skew angle of the node in degrees.
--- //This angle describes the shear distortion in the Y direction.
--- //Thus, it is the angle between the X axis and the bottom edge of the shape
--- //The default skewY angle is 0. Positive values distort the node in a CCW direction.
--- //@param fSkewY    The Y skew angle of the node in degrees.
--- virtual void setSkewY(float fSkewY);
--- </summary>
function CCNode:setSkewY() end
--- <summary>
--- //Changes the tag that is used to identify the node easily.
--- //Please refer to getTag for the sample code.
--- //@param A interger that indentifies the node.
--- virtual void setTag(int nTag);
--- </summary>
function CCNode:setTag() end
--- <summary>
--- //Sets a custom user data pointer
--- //You can set everything in UserData pointer, a data block, a structure or an object, etc.
--- //@warning Don't forget to release the memroy manually, 
--- //especially before you change this data pointer, and before this node is autoreleased.
--- //@return A custom user data pointer
--- //@js NA
--- virtual void setUserData(void *pUserData);
--- </summary>
function CCNode:setUserData() end
--- <summary>
--- //Returns a user assigned CCObject
--- //Similar to UserData, but instead of holding a void* it holds an object.
--- //The UserObject will be retained once in this method,
--- //and the previous UserObject (if existed) will be relese.
--- //The UserObject will be released in CCNode's destructure.
--- //@param A user assigned CCObject
--- virtual void setUserObject(CCObject *pUserObject);
--- </summary>
function CCNode:setUserObject() end
--- <summary>
--- //Sets the real OpenGL Z vertex.
--- //Differences between openGL Z vertex and cocos2d Z order:
--- //- OpenGL Z modifies the Z vertex, and not the Z order in the relation between parent-children
--- //- OpenGL Z might require to set 2D projection
--- //- cocos2d Z order works OK if all the nodes uses the same openGL Z vertex. eg: vertexZ = 0
--- //@warning Use it at your own risk since it might break the cocos2d parent-children z order
--- //@param fVertexZ  OpenGL Z vertex of this node.
--- virtual void setVertexZ(float vertexZ);
--- </summary>
function CCNode:setVertexZ() end
--- <summary>
--- //Sets whether the node is visible
--- //The default value is true, a node is default to visible
--- //@param visible   true if the node is visible, false if the node is hidden.
--- virtual void setVisible(bool visible);
--- </summary>
function CCNode:setVisible() end
--- <summary>
--- //Sets the Z order which stands for the drawing order, and reorder this node in its parent's children array.
--- //The Z order of node is relative to its "brothers": children of the same parent.
--- //It's nothing to do with OpenGL's z vertex. This one only affects the draw order of nodes in cocos2d.
--- //The larger number it is, the later this node will be drawn in each message loop.
--- //Please refer to setVertexZ(float) for the difference.
--- //@param nZOrder   Z order of this node.
--- virtual void setZOrder(int zOrder);
--- </summary>
function CCNode:setZOrder() end
--- <summary>
--- //Stops and removes an action from the running action list.
--- //@param An action object to be removed.
--- void stopAction(CCAction* action);
--- </summary>
function CCNode:stopAction() end
--- <summary>
--- //Removes an action from the running action list by its tag.
--- //@param A tag that indicates the action to be removed.
--- void stopActionByTag(int tag);
--- </summary>
function CCNode:stopActionByTag() end
--- <summary>
--- //Stops and removes all actions from the running action list .
--- void stopAllActions(void);
--- </summary>
function CCNode:stopAllActions() end
--- <summary>
--- //Performs OpenGL view-matrix transformation based on position, scale, rotation and other attributes.
--- void transform(void);
--- </summary>
function CCNode:transform() end
--- <summary>
--- //Performs OpenGL view-matrix transformation of it's ancestors.
--- //Generally the ancestors are already transformed, but in certain cases (eg: attaching a FBO)
--- //It's necessary to transform the ancestors again.
--- void transformAncestors(void);
--- </summary>
function CCNode:transformAncestors() end
--- <summary>
--- //Unregisters a script function that will be called in onEnter() &amp; onExit() series functions.
--- //@see registerScriptHandler(int)
--- virtual void unregisterScriptHandler(void);
--- </summary>
function CCNode:unregisterScriptHandler() end
--- <summary>
--- void unscheduleUpdate(void);
--- </summary>
function CCNode:unscheduleUpdate() end
--- <summary>
--- //Visits this node's children and draw them recursively.
--- virtual void visit(void);
--- </summary>
function CCNode:visit() end
--- <summary>
--- //Returns the inverse world affine transform matrix. The matrix is in Pixels.
--- virtual CCAffineTransform worldToNodeTransform(void);
--- </summary>
--- <returns type="CCAffineTransform"></returns>
function CCNode:worldToNodeTransform() end

CCNodeRGBA = class(CCNode)
--- <summary>
--- //@js ctor
--- CCNodeRGBA();
--- </summary>
function CCNodeRGBA:new() end
function CCNodeRGBA:new_local() end
--- <summary>
--- virtual const ccColor3B&amp; getColor(void);
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCNodeRGBA:getColor() end
--- <summary>
--- virtual const ccColor3B&amp; getDisplayedColor();
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCNodeRGBA:getDisplayedColor() end
--- <summary>
--- virtual GLubyte getDisplayedOpacity();
--- </summary>
--- <returns type="GLubyte"></returns>
function CCNodeRGBA:getDisplayedOpacity() end
--- <summary>
--- virtual GLubyte getOpacity();
--- </summary>
--- <returns type="GLubyte"></returns>
function CCNodeRGBA:getOpacity() end
--- <summary>
--- virtual bool init();
--- </summary>
function CCNodeRGBA:init() end
--- <summary>
--- virtual bool isCascadeColorEnabled();
--- </summary>
function CCNodeRGBA:isCascadeColorEnabled() end
--- <summary>
--- virtual bool isCascadeOpacityEnabled();
--- </summary>
function CCNodeRGBA:isCascadeOpacityEnabled() end
--- <summary>
--- virtual bool isOpacityModifyRGB();
--- </summary>
function CCNodeRGBA:isOpacityModifyRGB() end
--- <summary>
--- virtual void setCascadeColorEnabled(bool cascadeColorEnabled);
--- </summary>
function CCNodeRGBA:setCascadeColorEnabled() end
--- <summary>
--- virtual void setCascadeOpacityEnabled(bool cascadeOpacityEnabled);
--- </summary>
function CCNodeRGBA:setCascadeOpacityEnabled() end
--- <summary>
--- virtual void setColor(const ccColor3B&amp; color);
--- </summary>
function CCNodeRGBA:setColor() end
--- <summary>
--- virtual void setOpacity(GLubyte opacity);
--- </summary>
function CCNodeRGBA:setOpacity() end
--- <summary>
--- virtual void setOpacityModifyRGB(bool bValue);
--- </summary>
function CCNodeRGBA:setOpacityModifyRGB() end
--- <summary>
--- virtual void updateDisplayedColor(const ccColor3B&amp; parentColor);
--- </summary>
function CCNodeRGBA:updateDisplayedColor() end
--- <summary>
--- virtual void updateDisplayedOpacity(GLubyte parentOpacity);
--- </summary>
function CCNodeRGBA:updateDisplayedOpacity() end
--- <summary>
--- //@js NA
--- //@lua NA
--- virtual ~CCNodeRGBA();
--- </summary>
function CCNodeRGBA:delete() end

CCNotificationCenter = class(CCObject)
--- <summary>
--- //CCNotificationCenter constructor 
--- CCNotificationCenter();
--- </summary>
function CCNotificationCenter:new() end
function CCNotificationCenter:new_local() end
--- <summary>
--- //@brief Gets observer script handler.
--- //@param name The name of this notification.
--- //@return The observer script handle.
--- int getObserverHandlerByName(const char* name);
--- </summary>
function CCNotificationCenter:getObserverHandlerByName() end
--- <summary>
--- //@brief Gets script handler.
--- //@note Only supports Lua Binding now.
--- //@return The script handle.
--- inline int getScriptHandler();
--- </summary>
function CCNotificationCenter:getScriptHandler() end
--- <summary>
--- //@brief Posts one notification event by name.
--- //@param name The name of this notification.
--- void postNotification(const char *name);
--- 
--- //@brief Posts one notification event by name.
--- //@param name The name of this notification.
--- //@param object The extra parameter.
--- void postNotification(const char *name, CCObject *object);
--- </summary>
function CCNotificationCenter:postNotification() end
--- <summary>
--- //Destroys the single instance of CCNotificationCenter. 
--- static void purgeNotificationCenter(void);
--- </summary>
function CCNotificationCenter:purgeNotificationCenter() end
--- <summary>
--- //@brief Registers one hander for script binding.
--- //@note Only supports Lua Binding now.
--- //@param handler The lua handler.
--- void registerScriptObserver(CCObject *target,int handler,const char* name);
--- </summary>
function CCNotificationCenter:registerScriptObserver() end
--- <summary>
--- //@brief Removes all notifications registered by this target
--- //@param target The target of this notification.
--- //@returns the number of observers removed
--- int removeAllObservers(CCObject *target);
--- </summary>
function CCNotificationCenter:removeAllObservers() end
--- <summary>
--- //Gets the single instance of CCNotificationCenter. 
--- static CCNotificationCenter *sharedNotificationCenter(void);
--- </summary>
--- <returns type="CCNotificationCenter"></returns>
function CCNotificationCenter:sharedNotificationCenter() end
--- <summary>
--- //Unregisters script observer 
--- void unregisterScriptObserver(CCObject *target,const char* name);
--- </summary>
function CCNotificationCenter:unregisterScriptObserver() end

CCObject = {}
--- <summary>
--- CCObject* autorelease();
--- </summary>
--- <returns type="CCObject"></returns>
function CCObject:autorelease() end
--- <summary>
--- CCObject* copy();
--- </summary>
--- <returns type="CCObject"></returns>
function CCObject:copy() end
--- <summary>
--- bool isEqual(const CCObject* pObject);
--- </summary>
function CCObject:isEqual() end
--- <summary>
--- bool isSingleReference(void);
--- </summary>
function CCObject:isSingleReference() end
--- <summary>
--- void release(void);
--- </summary>
function CCObject:release() end
--- <summary>
--- void retain(void);
--- </summary>
function CCObject:retain() end
--- <summary>
--- unsigned int retainCount(void);
--- </summary>
function CCObject:retainCount() end

CCParallaxNode = class(CCNode)
--- <summary>
--- void addChild(CCNode * child, unsigned int z, CCPoint parallaxRatio, CCPoint positionOffset);
--- void addChild(CCNode * child, unsigned int zOrder, int tag);
--- </summary>
function CCParallaxNode:addChild() end
--- <summary>
--- static CCParallaxNode* create();
--- </summary>
--- <returns type="CCParallaxNode"></returns>
function CCParallaxNode:create() end
--- <summary>
--- void removeAllChildrenWithCleanup(bool cleanup);
--- </summary>
function CCParallaxNode:removeAllChildrenWithCleanup() end
--- <summary>
--- void removeChild(CCNode* child, bool cleanup);
--- </summary>
function CCParallaxNode:removeChild() end
--- <summary>
--- void visit(void);
--- </summary>
function CCParallaxNode:visit() end

CCParticleBatchNode = class(CCNode)
--- <summary>
--- //Add a child into the CCParticleBatchNode 
--- virtual void addChild(CCNode * child);
--- </summary>
function CCParticleBatchNode:addChild() end
--- <summary>
--- //initializes the particle system with the name of a file on disk (for a list of supported formats look at the CCTexture2D class), a capacity of particles 
--- static CCParticleBatchNode* create(const char* fileImage, unsigned int capacity = kCCParticleDefaultCapacity);
--- </summary>
--- <returns type="CCParticleBatchNode"></returns>
function CCParticleBatchNode:create() end
--- <summary>
--- //initializes the particle system with CCTexture2D, a capacity of particles, which particle system to use 
--- static CCParticleBatchNode* createWithTexture(CCTexture2D *tex, unsigned int capacity = kCCParticleDefaultCapacity);
--- </summary>
--- <returns type="CCParticleBatchNode"></returns>
function CCParticleBatchNode:createWithTexture() end
--- <summary>
--- //disables a particle by inserting a 0'd quad into the texture atlas 
--- void disableParticle(unsigned int particleIndex);
--- </summary>
function CCParticleBatchNode:disableParticle() end
--- <summary>
--- //returns the blending function used for the texture
--- //@js NA
--- virtual ccBlendFunc getBlendFunc(void);
--- </summary>
--- <returns type="ccBlendFunc"></returns>
function CCParticleBatchNode:getBlendFunc() end
--- <summary>
--- CCTexture2D* getTexture(void);
--- </summary>
--- <returns type="CCTexture2D"></returns>
function CCParticleBatchNode:getTexture() end
--- <summary>
--- //Inserts a child into the CCParticleBatchNode 
--- void insertChild(CCParticleSystem* pSystem, unsigned int index);
--- </summary>
function CCParticleBatchNode:insertChild() end
--- <summary>
--- void removeAllChildrenWithCleanup(bool doCleanup);
--- </summary>
function CCParticleBatchNode:removeAllChildrenWithCleanup() end
--- <summary>
--- //remove child from the CCParticleBatchNode 
--- virtual void removeChild(CCNode* child, bool cleanup);
--- </summary>
function CCParticleBatchNode:removeChild() end
--- <summary>
--- void removeChildAtIndex(unsigned int index, bool doCleanup);
--- </summary>
function CCParticleBatchNode:removeChildAtIndex() end
--- <summary>
--- void reorderChild(CCNode * child, int zOrder);
--- </summary>
function CCParticleBatchNode:reorderChild() end
--- <summary>
--- void setBlendFunc(ccBlendFunc blendFunc);
--- </summary>
function CCParticleBatchNode:setBlendFunc() end
--- <summary>
--- void setTexture(CCTexture2D *texture);
--- </summary>
function CCParticleBatchNode:setTexture() end

CCParticleFire = class(CCParticleSystemQuad)
--- <summary>
--- static CCParticleFire * create();
--- </summary>
--- <returns type="CCParticleFire"></returns>
function CCParticleFire:create() end

CCParticleFireworks = class(CCParticleSystemQuad)
--- <summary>
--- static CCParticleFireworks * create();
--- </summary>
--- <returns type="CCParticleFireworks"></returns>
function CCParticleFireworks:create() end

CCParticleSun = class(CCParticleSystemQuad)
--- <summary>
--- static CCParticleSun * create();
--- </summary>
--- <returns type="CCParticleSun"></returns>
function CCParticleSun:create() end

CCParticleGalaxy = class(CCParticleSystemQuad)
--- <summary>
--- static CCParticleGalaxy * create();
--- </summary>
--- <returns type="CCParticleGalaxy"></returns>
function CCParticleGalaxy:create() end

CCParticleFlower = class(CCParticleSystemQuad)
--- <summary>
--- static CCParticleFlower * create();
--- </summary>
--- <returns type="CCParticleFlower"></returns>
function CCParticleFlower:create() end

CCParticleMeteor = class(CCParticleSystemQuad)
--- <summary>
--- static CCParticleMeteor * create();
--- </summary>
--- <returns type="CCParticleMeteor"></returns>
function CCParticleMeteor:create() end

CCParticleSpiral = class(CCParticleSystemQuad)
--- <summary>
--- static CCParticleSpiral * create();
--- </summary>
--- <returns type="CCParticleSpiral"></returns>
function CCParticleSpiral:create() end

CCParticleExplosion = class(CCParticleSystemQuad)
--- <summary>
--- static CCParticleExplosion * create();
--- </summary>
--- <returns type="CCParticleExplosion"></returns>
function CCParticleExplosion:create() end

CCParticleSmoke = class(CCParticleSystemQuad)
--- <summary>
--- static CCParticleSmoke * create();
--- </summary>
--- <returns type="CCParticleSmoke"></returns>
function CCParticleSmoke:create() end

CCParticleSnow = class(CCParticleSystemQuad)
--- <summary>
--- static CCParticleSnow * create();
--- </summary>
--- <returns type="CCParticleSnow"></returns>
function CCParticleSnow:create() end

CCParticleRain = class(CCParticleSystemQuad)
--- <summary>
--- static CCParticleRain * create();
--- </summary>
--- <returns type="CCParticleRain"></returns>
function CCParticleRain:create() end

CCParticleSystem = class(CCNode)
--- <summary>
--- bool addParticle();
--- </summary>
function CCParticleSystem:addParticle() end
--- <summary>
--- //creates an initializes a CCParticleSystem from a plist file.
--- //This plist files can be created manually or with Particle Designer:
--- //http://particledesigner.71squared.com/
--- //@since v2.0
--- static CCParticleSystem * create(const char *plistFile);
--- </summary>
--- <returns type="CCParticleSystem"></returns>
function CCParticleSystem:create() end
--- <summary>
--- float getAngle();
--- </summary>
function CCParticleSystem:getAngle() end
--- <summary>
--- float getAngleVar();
--- </summary>
function CCParticleSystem:getAngleVar() end
--- <summary>
--- CCParticleBatchNode* getBatchNode(void);
--- </summary>
--- <returns type="CCParticleBatchNode"></returns>
function CCParticleSystem:getBatchNode() end
--- <summary>
--- ccBlendFunc getBlendFunc(void);
--- </summary>
--- <returns type="ccBlendFunc"></returns>
function CCParticleSystem:getBlendFunc() end
--- <summary>
--- float getDuration();
--- </summary>
function CCParticleSystem:getDuration() end
--- <summary>
--- float getEmissionRate();
--- </summary>
function CCParticleSystem:getEmissionRate() end
--- <summary>
--- int  getEmitterMode();
--- </summary>
function CCParticleSystem:getEmitterMode() end
--- <summary>
--- const ccColor4F &amp; getEndColor();
--- </summary>
--- <returns type="ccColor4F"></returns>
function CCParticleSystem:getEndColor() end
--- <summary>
--- const ccColor4F &amp; getEndColorVar();
--- </summary>
--- <returns type="ccColor4F"></returns>
function CCParticleSystem:getEndColorVar() end
--- <summary>
--- float getEndRadius();
--- </summary>
function CCParticleSystem:getEndRadius() end
--- <summary>
--- float getEndRadiusVar();
--- </summary>
function CCParticleSystem:getEndRadiusVar() end
--- <summary>
--- float getEndSize();
--- </summary>
function CCParticleSystem:getEndSize() end
--- <summary>
--- float getEndSizeVar();
--- </summary>
function CCParticleSystem:getEndSizeVar() end
--- <summary>
--- float getEndSpin();
--- </summary>
function CCParticleSystem:getEndSpin() end
--- <summary>
--- float getEndSpinVar();
--- </summary>
function CCParticleSystem:getEndSpinVar() end
--- <summary>
--- const CCPoint&amp; getGravity();
--- </summary>
--- <returns type="CCPoint"></returns>
function CCParticleSystem:getGravity() end
--- <summary>
--- float getLife();
--- </summary>
function CCParticleSystem:getLife() end
--- <summary>
--- float getLifeVar();
--- </summary>
function CCParticleSystem:getLifeVar() end
--- <summary>
--- unsigned int getParticleCount();
--- </summary>
function CCParticleSystem:getParticleCount() end
--- <summary>
--- CCPoint getPosVar();
--- </summary>
--- <returns type="CCPoint"></returns>
function CCParticleSystem:getPosVar() end
--- <summary>
--- tCCPositionType getPositionType(void);
--- </summary>
--- <returns type="tCCPositionType"></returns>
function CCParticleSystem:getPositionType() end
--- <summary>
--- float getRadialAccel();
--- </summary>
function CCParticleSystem:getRadialAccel() end
--- <summary>
--- float getRadialAccelVar();
--- </summary>
function CCParticleSystem:getRadialAccelVar() end
--- <summary>
--- float getRotatePerSecond();
--- </summary>
function CCParticleSystem:getRotatePerSecond() end
--- <summary>
--- float getRotatePerSecondVar();
--- </summary>
function CCParticleSystem:getRotatePerSecondVar() end
--- <summary>
--- CCPoint getSourcePosition();
--- </summary>
--- <returns type="CCPoint"></returns>
function CCParticleSystem:getSourcePosition() end
--- <summary>
--- float getSpeed();
--- </summary>
function CCParticleSystem:getSpeed() end
--- <summary>
--- float getSpeedVar();
--- </summary>
function CCParticleSystem:getSpeedVar() end
--- <summary>
--- const ccColor4F &amp; getStartColor();
--- </summary>
--- <returns type="ccColor4F"></returns>
function CCParticleSystem:getStartColor() end
--- <summary>
--- const ccColor4F &amp; getStartColorVar();
--- </summary>
--- <returns type="ccColor4F"></returns>
function CCParticleSystem:getStartColorVar() end
--- <summary>
--- float getStartRadius();
--- </summary>
function CCParticleSystem:getStartRadius() end
--- <summary>
--- float getStartRadiusVar();
--- </summary>
function CCParticleSystem:getStartRadiusVar() end
--- <summary>
--- float getStartSize();
--- </summary>
function CCParticleSystem:getStartSize() end
--- <summary>
--- float getStartSizeVar();
--- </summary>
function CCParticleSystem:getStartSizeVar() end
--- <summary>
--- float getStartSpin();
--- </summary>
function CCParticleSystem:getStartSpin() end
--- <summary>
--- float getStartSpinVar();
--- </summary>
function CCParticleSystem:getStartSpinVar() end
--- <summary>
--- float getTangentialAccel();
--- </summary>
function CCParticleSystem:getTangentialAccel() end
--- <summary>
--- float getTangentialAccelVar();
--- </summary>
function CCParticleSystem:getTangentialAccelVar() end
--- <summary>
--- CCTexture2D* getTexture(void);
--- </summary>
--- <returns type="CCTexture2D"></returns>
function CCParticleSystem:getTexture() end
--- <summary>
--- unsigned int getTotalParticles();
--- </summary>
function CCParticleSystem:getTotalParticles() end
--- <summary>
--- void initParticle(tCCParticle* particle);
--- </summary>
function CCParticleSystem:initParticle() end
--- <summary>
--- //initializes a CCParticleSystem from a plist file.
--- //This plist files can be created manually or with Particle Designer:
--- //http://particledesigner.71squared.com/
--- //@since v0.99.3
--- bool initWithFile(const char *plistFile);
--- </summary>
function CCParticleSystem:initWithFile() end
--- <summary>
--- bool initWithTotalParticles(unsigned int number);
--- </summary>
function CCParticleSystem:initWithTotalParticles() end
--- <summary>
--- bool isActive();
--- </summary>
function CCParticleSystem:isActive() end
--- <summary>
--- bool isAutoRemoveOnFinish();
--- </summary>
function CCParticleSystem:isAutoRemoveOnFinish() end
--- <summary>
--- bool isBlendAdditive();
--- </summary>
function CCParticleSystem:isBlendAdditive() end
--- <summary>
--- bool isFull();
--- </summary>
function CCParticleSystem:isFull() end
--- <summary>
--- void postStep();
--- </summary>
function CCParticleSystem:postStep() end
--- <summary>
--- void resetSystem();
--- </summary>
function CCParticleSystem:resetSystem() end
--- <summary>
--- void  setAngle(float angle);
--- </summary>
function CCParticleSystem:setAngle() end
--- <summary>
--- void  setAngleVar(float angle);
--- </summary>
function CCParticleSystem:setAngleVar() end
--- <summary>
--- void setAutoRemoveOnFinish(bool var);
--- </summary>
function CCParticleSystem:setAutoRemoveOnFinish() end
--- <summary>
--- void setBatchNode(CCParticleBatchNode* node);
--- </summary>
function CCParticleSystem:setBatchNode() end
--- <summary>
--- void setBlendAdditive(bool value);
--- </summary>
function CCParticleSystem:setBlendAdditive() end
--- <summary>
--- void setBlendFunc(ccBlendFunc var);
--- </summary>
function CCParticleSystem:setBlendFunc() end
--- <summary>
--- void  setDuration(float d);
--- </summary>
function CCParticleSystem:setDuration() end
--- <summary>
--- void  setEmissionRate(float rate);
--- </summary>
function CCParticleSystem:setEmissionRate() end
--- <summary>
--- void setEmitterMode(int mode);
--- </summary>
function CCParticleSystem:setEmitterMode() end
--- <summary>
--- void  setEndColor(const ccColor4F var);
--- </summary>
function CCParticleSystem:setEndColor() end
--- <summary>
--- void  setEndColorVar(const ccColor4F var);
--- </summary>
function CCParticleSystem:setEndColorVar() end
--- <summary>
--- void setEndRadius(float endRadius);
--- </summary>
function CCParticleSystem:setEndRadius() end
--- <summary>
--- void setEndRadiusVar(float endRadiusVar);
--- </summary>
function CCParticleSystem:setEndRadiusVar() end
--- <summary>
--- void  setEndSize(float size);
--- </summary>
function CCParticleSystem:setEndSize() end
--- <summary>
--- void  setEndSizeVar(float size);
--- </summary>
function CCParticleSystem:setEndSizeVar() end
--- <summary>
--- void  setEndSpin(float var);
--- </summary>
function CCParticleSystem:setEndSpin() end
--- <summary>
--- void  setEndSpinVar(float var);
--- </summary>
function CCParticleSystem:setEndSpinVar() end
--- <summary>
--- void setGravity(const CCPoint&amp; g);
--- </summary>
function CCParticleSystem:setGravity() end
--- <summary>
--- void  setLife(float life);
--- </summary>
function CCParticleSystem:setLife() end
--- <summary>
--- void  setLifeVar(float lifeVar);
--- </summary>
function CCParticleSystem:setLifeVar() end
--- <summary>
--- void  setPosVar(CCPoint pos);
--- </summary>
function CCParticleSystem:setPosVar() end
--- <summary>
--- void setPositionType(tCCPositionType type);
--- </summary>
function CCParticleSystem:setPositionType() end
--- <summary>
--- void setRadialAccel(float t);
--- </summary>
function CCParticleSystem:setRadialAccel() end
--- <summary>
--- void setRadialAccelVar(float t);
--- </summary>
function CCParticleSystem:setRadialAccelVar() end
--- <summary>
--- void setRotatePerSecond(float degrees);
--- </summary>
function CCParticleSystem:setRotatePerSecond() end
--- <summary>
--- void setRotatePerSecondVar(float degrees);
--- </summary>
function CCParticleSystem:setRotatePerSecondVar() end
--- <summary>
--- void setRotation(float newRotation);
--- </summary>
function CCParticleSystem:setRotation() end
--- <summary>
--- void setScale(float s);
--- </summary>
function CCParticleSystem:setScale() end
--- <summary>
--- void setScaleX(float newScaleX);
--- </summary>
function CCParticleSystem:setScaleX() end
--- <summary>
--- void setScaleY(float newScaleY);
--- </summary>
function CCParticleSystem:setScaleY() end
--- <summary>
--- void  setSourcePosition(CCPoint pos);
--- </summary>
function CCParticleSystem:setSourcePosition() end
--- <summary>
--- void setSpeed(float speed);
--- </summary>
function CCParticleSystem:setSpeed() end
--- <summary>
--- void setSpeedVar(float speed);
--- </summary>
function CCParticleSystem:setSpeedVar() end
--- <summary>
--- void  setStartColor(const ccColor4F var);
--- </summary>
function CCParticleSystem:setStartColor() end
--- <summary>
--- void  setStartColorVar(const ccColor4F var);
--- </summary>
function CCParticleSystem:setStartColorVar() end
--- <summary>
--- void setStartRadius(float startRadius);
--- </summary>
function CCParticleSystem:setStartRadius() end
--- <summary>
--- void setStartRadiusVar(float startRadiusVar);
--- </summary>
function CCParticleSystem:setStartRadiusVar() end
--- <summary>
--- void  setStartSize(float size);
--- </summary>
function CCParticleSystem:setStartSize() end
--- <summary>
--- void  setStartSizeVar(float size);
--- </summary>
function CCParticleSystem:setStartSizeVar() end
--- <summary>
--- void  setStartSpin(float var);
--- </summary>
function CCParticleSystem:setStartSpin() end
--- <summary>
--- void  setStartSpinVar(float var);
--- </summary>
function CCParticleSystem:setStartSpinVar() end
--- <summary>
--- void setTangentialAccel(float t);
--- </summary>
function CCParticleSystem:setTangentialAccel() end
--- <summary>
--- void setTangentialAccelVar(float t);
--- </summary>
function CCParticleSystem:setTangentialAccelVar() end
--- <summary>
--- void setTexture(CCTexture2D* var);
--- </summary>
function CCParticleSystem:setTexture() end
--- <summary>
--- void stopSystem();
--- </summary>
function CCParticleSystem:stopSystem() end
--- <summary>
--- void updateQuadWithParticle(tCCParticle* particle, const CCPoint&amp; newPosition);
--- </summary>
function CCParticleSystem:updateQuadWithParticle() end

CCParticleSystemQuad = class(CCParticleSystem)
--- <summary>
--- //@js ctor
--- CCParticleSystemQuad();
--- </summary>
function CCParticleSystemQuad:new() end
function CCParticleSystemQuad:new_local() end
--- <summary>
--- //creates an initializes a CCParticleSystemQuad from a plist file.
--- //This plist files can be created manually or with Particle Designer:  
--- static CCParticleSystemQuad * create(const char *plistFile);
--- </summary>
--- <returns type="CCParticleSystemQuad"></returns>
function CCParticleSystemQuad:create() end
--- <summary>
--- //@js NA
--- virtual void postStep();
--- </summary>
function CCParticleSystemQuad:postStep() end
--- <summary>
--- //@js NA
--- virtual void setBatchNode(CCParticleBatchNode* batchNode);
--- </summary>
function CCParticleSystemQuad:setBatchNode() end
--- <summary>
--- //Sets a new CCSpriteFrame as particle.
--- //WARNING: this method is experimental. Use setTexture:withRect instead.
--- //@since v0.99.4
--- void setDisplayFrame(CCSpriteFrame *spriteFrame);
--- </summary>
function CCParticleSystemQuad:setDisplayFrame() end
--- <summary>
--- //@js NA
--- virtual void setTexture(CCTexture2D* texture);
--- </summary>
function CCParticleSystemQuad:setTexture() end
--- <summary>
--- //Sets a new texture with a rect. The rect is in Points.
--- //@since v0.99.4
--- void setTextureWithRect(CCTexture2D *texture, const CCRect&amp; rect);
--- </summary>
function CCParticleSystemQuad:setTextureWithRect() end
--- <summary>
--- //@js NA
--- virtual void setTotalParticles(unsigned int tp);
--- </summary>
function CCParticleSystemQuad:setTotalParticles() end
--- <summary>
--- //@js NA
--- virtual void updateQuadWithParticle(tCCParticle* particle, const CCPoint&amp; newPosition);
--- </summary>
function CCParticleSystemQuad:updateQuadWithParticle() end

CCProgressTimer = class(CCNodeRGBA)
--- <summary>
--- //Creates a progress timer with the sprite as the shape the timer goes through 
--- static CCProgressTimer* create(CCSprite* sp);
--- </summary>
--- <returns type="CCProgressTimer"></returns>
function CCProgressTimer:create() end
--- <summary>
--- CCPoint getBarChangeRate();
--- </summary>
--- <returns type="CCPoint"></returns>
function CCProgressTimer:getBarChangeRate() end
--- <summary>
--- const ccColor3B&amp; getColor(void);
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCProgressTimer:getColor() end
--- <summary>
--- CCPoint getMidpoint();
--- </summary>
--- <returns type="CCPoint"></returns>
function CCProgressTimer:getMidpoint() end
--- <summary>
--- GLubyte getOpacity(void);
--- </summary>
--- <returns type="GLubyte"></returns>
function CCProgressTimer:getOpacity() end
--- <summary>
--- //Percentages are from 0 to 100 
--- inline float getPercentage(void);
--- </summary>
function CCProgressTimer:getPercentage() end
--- <summary>
--- //The image to show the progress percentage, retain 
--- inline CCSprite* getSprite(void);
--- </summary>
--- <returns type="CCSprite"></returns>
function CCProgressTimer:getSprite() end
--- <summary>
--- //Change the percentage to change progress. 
--- inline CCProgressTimerType getType(void);
--- </summary>
--- <returns type="CCProgressTimerType"></returns>
function CCProgressTimer:getType() end
--- <summary>
--- bool isOpacityModifyRGB(void);
--- </summary>
function CCProgressTimer:isOpacityModifyRGB() end
--- <summary>
--- bool isReverseDirection();
--- </summary>
function CCProgressTimer:isReverseDirection() end
--- <summary>
--- void setBarChangeRate(CCPoint rate);
--- </summary>
function CCProgressTimer:setBarChangeRate() end
--- <summary>
--- void setColor(const ccColor3B&amp; color);
--- </summary>
function CCProgressTimer:setColor() end
--- <summary>
--- void setMidpoint(CCPoint pt);
--- </summary>
function CCProgressTimer:setMidpoint() end
--- <summary>
--- void setOpacity(GLubyte opacity);
--- </summary>
function CCProgressTimer:setOpacity() end
--- <summary>
--- void setOpacityModifyRGB(bool bValue);
--- </summary>
function CCProgressTimer:setOpacityModifyRGB() end
--- <summary>
--- void setPercentage(float fPercentage);
--- </summary>
function CCProgressTimer:setPercentage() end
--- <summary>
--- void setReverseDirection(bool bReverseDir);
--- </summary>
function CCProgressTimer:setReverseDirection() end
--- <summary>
--- //@js setReverseDirection
--- void setReverseProgress(bool reverse);
--- </summary>
function CCProgressTimer:setReverseProgress() end
--- <summary>
--- void setSprite(CCSprite *pSprite);
--- </summary>
function CCProgressTimer:setSprite() end
--- <summary>
--- void setType(CCProgressTimerType type);
--- </summary>
function CCProgressTimer:setType() end

CCRGBAProtocol = {}
--- <summary>
--- //Returns color that is currently used.
--- //@return The ccColor3B contains R,G,B bytes.
--- virtual const ccColor3B&amp; getColor(void) = 0;
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCRGBAProtocol:getColor() end
--- <summary>
--- //Returns the displayed color.
--- //@return The ccColor3B contains R,G,B bytes.
--- virtual const ccColor3B&amp; getDisplayedColor(void) = 0;
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCRGBAProtocol:getDisplayedColor() end
--- <summary>
--- //Returns the displayed opacity.
--- //@return  The opacity of sprite, from 0 ~ 255
--- virtual GLubyte getDisplayedOpacity(void) = 0;
--- </summary>
--- <returns type="GLubyte"></returns>
function CCRGBAProtocol:getDisplayedOpacity() end
--- <summary>
--- //Returns the opacity.
--- //The opacity which indicates how transparent or opaque this node is.
--- //0 indicates fully transparent and 255 is fully opaque.
--- //@return  The opacity of sprite, from 0 ~ 255
--- virtual GLubyte getOpacity(void) = 0;
--- </summary>
--- <returns type="GLubyte"></returns>
function CCRGBAProtocol:getOpacity() end
--- <summary>
--- //whether or not color should be propagated to its children.
--- virtual bool isCascadeColorEnabled(void) = 0;
--- </summary>
function CCRGBAProtocol:isCascadeColorEnabled() end
--- <summary>
--- //whether or not opacity should be propagated to its children.
--- virtual bool isCascadeOpacityEnabled(void) = 0;
--- </summary>
function CCRGBAProtocol:isCascadeOpacityEnabled() end
--- <summary>
--- //Returns whether or not the opacity will be applied using glColor(R,G,B,opacity) 
--- //or glColor(opacity, opacity, opacity, opacity)
--- //@return  Returns opacity modify flag.
--- virtual bool isOpacityModifyRGB(void) = 0;
--- </summary>
function CCRGBAProtocol:isOpacityModifyRGB() end
--- <summary>
--- virtual void setCascadeColorEnabled(bool cascadeColorEnabled);
--- </summary>
function CCRGBAProtocol:setCascadeColorEnabled() end
--- <summary>
--- virtual void setCascadeOpacityEnabled(bool cascadeOpacityEnabled);
--- </summary>
function CCRGBAProtocol:setCascadeOpacityEnabled() end
--- <summary>
--- //Changes the color with R,G,B bytes
--- //@param color Example: ccc3(255,100,0) means R=255, G=100, B=0
--- virtual void setColor(const ccColor3B&amp; color) = 0;
--- </summary>
function CCRGBAProtocol:setColor() end
--- <summary>
--- //Changes the opacity.
--- //@param   value   Goes from 0 to 255, where 255 means fully opaque and 0 means fully transparent.
--- virtual void setOpacity(GLubyte opacity) = 0;
--- </summary>
function CCRGBAProtocol:setOpacity() end
--- <summary>
--- //Changes the OpacityModifyRGB property. 
--- //If thie property is set to true, then the rendered color will be affected by opacity.
--- //Normally, r = r * opacity/255, g = g * opacity/255, b = b * opacity/255.
--- //@param   bValue  true then the opacity will be applied as: glColor(R,G,B,opacity);
--- //false then the opacity will be applied as: glColor(opacity, opacity, opacity, opacity);
--- virtual void setOpacityModifyRGB(bool bValue) = 0;
--- </summary>
function CCRGBAProtocol:setOpacityModifyRGB() end
--- <summary>
--- //recursive method that updates display color 
--- virtual void updateDisplayedColor(const ccColor3B&amp; color) = 0;
--- </summary>
function CCRGBAProtocol:updateDisplayedColor() end
--- <summary>
--- //recursive method that updates the displayed opacity.
--- virtual void updateDisplayedOpacity(GLubyte opacity) = 0;
--- </summary>
function CCRGBAProtocol:updateDisplayedOpacity() end

CCRenderTexture = class(CCNode)
--- <summary>
--- //starts grabbing 
--- void begin();
--- </summary>
function CCRenderTexture:begin() end
--- <summary>
--- void beginWithClear(float r, float g, float b, float a);
--- void beginWithClear(float r, float g, float b, float a, float depthValue);
--- void beginWithClear(float r, float g, float b, float a, float depthValue, int stencilValue);
--- </summary>
function CCRenderTexture:beginWithClear() end
--- <summary>
--- //clears the texture with a color 
--- void clear(float r, float g, float b, float a);
--- </summary>
function CCRenderTexture:clear() end
--- <summary>
--- //clears the texture with a specified depth value 
--- void clearDepth(float depthValue);
--- </summary>
function CCRenderTexture:clearDepth() end
--- <summary>
--- //clears the texture with a specified stencil value 
--- void clearStencil(int stencilValue);
--- </summary>
function CCRenderTexture:clearStencil() end
--- <summary>
--- //initializes a RenderTexture object with width and height in Points and a pixel format( only RGB and RGBA formats are valid ) and depthStencil format
--- static CCRenderTexture * create(int w ,int h, CCTexture2DPixelFormat eFormat, GLuint uDepthStencilFormat);
--- 
--- //creates a RenderTexture object with width and height in Points and a pixel format, only RGB and RGBA formats are valid 
--- static CCRenderTexture * create(int w, int h, CCTexture2DPixelFormat eFormat);
--- 
--- //creates a RenderTexture object with width and height in Points, pixel format is RGBA8888 
--- static CCRenderTexture * create(int w, int h);
--- </summary>
--- <returns type="CCRenderTexture"></returns>
function CCRenderTexture:create() end
--- <summary>
--- //end is key word of lua, use other name to export to lua. 
--- inline void endToLua();
--- </summary>
function CCRenderTexture:endToLua() end
--- <summary>
--- CCSprite* getSprite();
--- </summary>
--- <returns type="CCSprite"></returns>
function CCRenderTexture:getSprite() end
--- <summary>
--- CCImage* newCCImage();
--- </summary>
--- <returns type="CCImage"></returns>
function CCRenderTexture:newCCImage() end
--- <summary>
--- //saves the texture into a file using JPEG format. The file will be saved in the Documents folder.
--- //Returns YES if the operation is successful.
--- bool saveToFile(const char *szFilePath);
--- 
--- //saves the texture into a file. The format could be JPG or PNG. The file will be saved in the Documents folder.
--- //Returns YES if the operation is successful.
--- bool saveToFile(const char *name, tCCImageFormat format);
--- </summary>
function CCRenderTexture:saveToFile() end
--- <summary>
--- void setSprite(CCSprite* psprite);
--- </summary>
function CCRenderTexture:setSprite() end

CCRibbon = class(CCNode)
--- <summary>
--- void addPointAt(CCPoint location, float width);
--- </summary>
function CCRibbon:addPointAt() end
--- <summary>
--- static CCRibbon * create(float w, const char *path, float length, ccColor4B color, float fade);
--- </summary>
--- <returns type="CCRibbon"></returns>
function CCRibbon:create() end
--- <summary>
--- ccBlendFunc getBlendFunc();
--- </summary>
--- <returns type="ccBlendFunc"></returns>
function CCRibbon:getBlendFunc() end
--- <summary>
--- ccColor4B getColor();
--- </summary>
--- <returns type="ccColor4B"></returns>
function CCRibbon:getColor() end
--- <summary>
--- CCTexture2D* getTexture();
--- </summary>
--- <returns type="CCTexture2D"></returns>
function CCRibbon:getTexture() end
--- <summary>
--- float getTextureLength();
--- </summary>
function CCRibbon:getTextureLength() end
--- <summary>
--- void setBlendFunc(ccBlendFunc val);
--- </summary>
function CCRibbon:setBlendFunc() end
--- <summary>
--- void setColor(ccColor4B val);
--- </summary>
function CCRibbon:setColor() end
--- <summary>
--- void setTexture(CCTexture2D* val);
--- </summary>
function CCRibbon:setTexture() end
--- <summary>
--- void  setTextureLength(float val);
--- </summary>
function CCRibbon:setTextureLength() end
--- <summary>
--- float sideOfLine(CCPoint p, CCPoint l1, CCPoint l2);
--- </summary>
function CCRibbon:sideOfLine() end

CCScale9Sprite = class(CCNodeRGBA)
--- <summary>
--- CCScale9Sprite();
--- </summary>
function CCScale9Sprite:new() end
function CCScale9Sprite:new_local() end
--- <summary>
--- //Creates a 9-slice sprite with a texture file, a delimitation zone and
--- //with the specified cap insets.
--- //@see initWithFile:rect:centerRegion:
--- static CCScale9Sprite* create(const char* file, CCRect rect, CCRect capInsets);
--- 
--- //Creates a 9-slice sprite with a texture file and a delimitation zone. The
--- //texture will be broken down into a 3×3 grid of equal blocks.
--- //@see initWithFile:rect:
--- static CCScale9Sprite* create(const char* file, CCRect rect);
--- 
--- //Creates a 9-slice sprite with a texture file. The whole texture will be
--- //broken down into a 3×3 grid of equal blocks.
--- //@see initWithFile:capInsets:
--- static CCScale9Sprite* create(CCRect capInsets, const char* file);
--- 
--- //Creates a 9-slice sprite with a texture file. The whole texture will be
--- //broken down into a 3×3 grid of equal blocks.
--- //@see initWithFile:
--- static CCScale9Sprite* create(const char* file);
--- </summary>
--- <returns type="CCScale9Sprite"></returns>
function CCScale9Sprite:create() end
--- <summary>
--- //Creates a 9-slice sprite with an sprite frame and the centre of its zone.
--- //Once the sprite is created, you can then call its "setContentSize:" method
--- //to resize the sprite will all it's 9-slice goodness intract.
--- //It respects the anchorPoint too.
--- //@see initWithSpriteFrame:centerRegion:
--- static CCScale9Sprite* createWithSpriteFrame(CCSpriteFrame* spriteFrame, CCRect capInsets); 
--- 
--- //Creates a 9-slice sprite with an sprite frame.
--- //Once the sprite is created, you can then call its "setContentSize:" method
--- //to resize the sprite will all it's 9-slice goodness intract.
--- //It respects the anchorPoint too.
--- //@see initWithSpriteFrame:
--- static CCScale9Sprite* createWithSpriteFrame(CCSpriteFrame* spriteFrame); 
--- </summary>
--- <returns type="CCScale9Sprite"></returns>
function CCScale9Sprite:createWithSpriteFrame() end
--- <summary>
--- //Creates a 9-slice sprite with an sprite frame name and the centre of its
--- //zone.
--- //Once the sprite is created, you can then call its "setContentSize:" method
--- //to resize the sprite will all it's 9-slice goodness intract.
--- //It respects the anchorPoint too.
--- //@see initWithSpriteFrameName:centerRegion:
--- static CCScale9Sprite* createWithSpriteFrameName(const char*spriteFrameName, CCRect capInsets); 
--- 
--- //Creates a 9-slice sprite with an sprite frame name.
--- //Once the sprite is created, you can then call its "setContentSize:" method
--- //to resize the sprite will all it's 9-slice goodness intract.
--- //It respects the anchorPoint too.
--- //@see initWithSpriteFrameName:
--- static CCScale9Sprite* createWithSpriteFrameName(const char*spriteFrameName);
--- </summary>
--- <returns type="CCScale9Sprite"></returns>
function CCScale9Sprite:createWithSpriteFrameName() end
--- <summary>
--- CCRect getCapInsets();
--- </summary>
--- <returns type="CCRect"></returns>
function CCScale9Sprite:getCapInsets() end
--- <summary>
--- float  getInsetBottom();
--- </summary>
function CCScale9Sprite:getInsetBottom() end
--- <summary>
--- float  getInsetLeft();
--- </summary>
function CCScale9Sprite:getInsetLeft() end
--- <summary>
--- float  getInsetRight();
--- </summary>
function CCScale9Sprite:getInsetRight() end
--- <summary>
--- float  getInsetTop();
--- </summary>
function CCScale9Sprite:getInsetTop() end
--- <summary>
--- CCSize getOriginalSize(void) const;
--- </summary>
--- <returns type="CCSize"></returns>
function CCScale9Sprite:getOriginalSize() end
--- <summary>
--- CCSize getPreferredSize();
--- </summary>
--- <returns type="CCSize"></returns>
function CCScale9Sprite:getPreferredSize() end
--- <summary>
--- virtual bool init();
--- </summary>
function CCScale9Sprite:init() end
--- <summary>
--- virtual bool initWithBatchNode(CCSpriteBatchNode* batchnode, CCRect rect, bool rotated, CCRect capInsets);
--- virtual bool initWithBatchNode(CCSpriteBatchNode* batchnode, CCRect rect, CCRect capInsets);
--- </summary>
function CCScale9Sprite:initWithBatchNode() end
--- <summary>
--- //Initializes a 9-slice sprite with a texture file, a delimitation zone and
--- //with the specified cap insets.
--- //Once the sprite is created, you can then call its "setContentSize:" method
--- //to resize the sprite will all it's 9-slice goodness intract.
--- //It respects the anchorPoint too.
--- //@param file The name of the texture file.
--- //@param rect The rectangle that describes the sub-part of the texture that
--- //is the whole image. If the shape is the whole texture, set this to the 
--- //texture's full rect.
--- //@param capInsets The values to use for the cap insets.
--- virtual bool initWithFile(const char* file, CCRect rect, CCRect capInsets);
--- 
--- //Initializes a 9-slice sprite with a texture file and a delimitation zone. The
--- //texture will be broken down into a 3×3 grid of equal blocks.
--- //Once the sprite is created, you can then call its "setContentSize:" method
--- //to resize the sprite will all it's 9-slice goodness intract.
--- //It respects the anchorPoint too.
--- //@param file The name of the texture file.
--- //@param rect The rectangle that describes the sub-part of the texture that
--- //is the whole image. If the shape is the whole texture, set this to the 
--- //texture's full rect.
--- virtual bool initWithFile(const char* file, CCRect rect);
--- 
--- //Initializes a 9-slice sprite with a texture file and with the specified cap
--- //insets.
--- //Once the sprite is created, you can then call its "setContentSize:" method
--- //to resize the sprite will all it's 9-slice goodness intract.
--- //It respects the anchorPoint too.
--- //@param file The name of the texture file.
--- //@param capInsets The values to use for the cap insets.
--- virtual bool initWithFile(CCRect capInsets, const char* file);
--- 
--- //Initializes a 9-slice sprite with a texture file. The whole texture will be
--- //broken down into a 3×3 grid of equal blocks.
--- //Once the sprite is created, you can then call its "setContentSize:" method
--- //to resize the sprite will all it's 9-slice goodness intract.
--- //It respects the anchorPoint too.
--- //@param file The name of the texture file.
--- virtual bool initWithFile(const char* file);
--- </summary>
function CCScale9Sprite:initWithFile() end
--- <summary>
--- //Initializes a 9-slice sprite with an sprite frame and with the specified 
--- //cap insets.
--- //Once the sprite is created, you can then call its "setContentSize:" method
--- //to resize the sprite will all it's 9-slice goodness intract.
--- //It respects the anchorPoint too.
--- //@param spriteFrame The sprite frame object.
--- //@param capInsets The values to use for the cap insets.
--- virtual bool initWithSpriteFrame(CCSpriteFrame* spriteFrame, CCRect capInsets);
--- 
--- //Initializes a 9-slice sprite with an sprite frame.
--- //Once the sprite is created, you can then call its "setContentSize:" method
--- //to resize the sprite will all it's 9-slice goodness intract.
--- //It respects the anchorPoint too.
--- //@param spriteFrame The sprite frame object.
--- virtual bool initWithSpriteFrame(CCSpriteFrame* spriteFrame);
--- </summary>
function CCScale9Sprite:initWithSpriteFrame() end
--- <summary>
--- //Initializes a 9-slice sprite with an sprite frame name and with the specified 
--- //cap insets.
--- //Once the sprite is created, you can then call its "setContentSize:" method
--- //to resize the sprite will all it's 9-slice goodness intract.
--- //It respects the anchorPoint too.
--- //@param spriteFrameName The sprite frame name.
--- //@param capInsets The values to use for the cap insets.
--- virtual bool initWithSpriteFrameName(const char*spriteFrameName, CCRect capInsets);
--- 
--- //Initializes a 9-slice sprite with an sprite frame name.
--- //Once the sprite is created, you can then call its "setContentSize:" method
--- //to resize the sprite will all it's 9-slice goodness intract.
--- //It respects the anchorPoint too.
--- //@param spriteFrameName The sprite frame name.
--- virtual bool initWithSpriteFrameName(const char*spriteFrameName);
--- </summary>
function CCScale9Sprite:initWithSpriteFrameName() end
--- <summary>
--- //returns whether or not the opacity will be applied using glColor(R,G,B,opacity) or glColor(opacity, opacity, opacity, opacity);
--- //@since v0.8
--- virtual bool isOpacityModifyRGB(void);
--- </summary>
function CCScale9Sprite:isOpacityModifyRGB() end
--- <summary>
--- //Creates and returns a new sprite object with the specified cap insets.
--- //You use this method to add cap insets to a sprite or to change the existing
--- //cap insets of a sprite. In both cases, you get back a new image and the 
--- //original sprite remains untouched.
--- //@param capInsets The values to use for the cap insets.
--- CCScale9Sprite* resizableSpriteWithCapInsets(CCRect capInsets);
--- </summary>
--- <returns type="CCScale9Sprite"></returns>
function CCScale9Sprite:resizableSpriteWithCapInsets() end
--- <summary>
--- void   setCapInsets(CCRect rt);
--- </summary>
function CCScale9Sprite:setCapInsets() end
--- <summary>
--- virtual void setColor(const ccColor3B&amp; color);
--- </summary>
function CCScale9Sprite:setColor() end
--- <summary>
--- void   setInsetBottom(float fBottom);
--- </summary>
function CCScale9Sprite:setInsetBottom() end
--- <summary>
--- void   setInsetLeft(float fLeft);
--- </summary>
function CCScale9Sprite:setInsetLeft() end
--- <summary>
--- void   setInsetRight(float fRight);
--- </summary>
function CCScale9Sprite:setInsetRight() end
--- <summary>
--- void   setInsetTop(float fTop);
--- </summary>
function CCScale9Sprite:setInsetTop() end
--- <summary>
--- virtual void setOpacity(GLubyte opacity);
--- </summary>
function CCScale9Sprite:setOpacity() end
--- <summary>
--- //sets the premultipliedAlphaOpacity property.
--- //If set to NO then opacity will be applied as: glColor(R,G,B,opacity);
--- //If set to YES then oapcity will be applied as: glColor(opacity, opacity, opacity, opacity );
--- //Textures with premultiplied alpha will have this property by default on YES. Otherwise the default value is NO
--- //@since v0.8
--- virtual void setOpacityModifyRGB(bool bValue);
--- </summary>
function CCScale9Sprite:setOpacityModifyRGB() end
--- <summary>
--- void   setPreferredSize(CCSize sz);
--- </summary>
function CCScale9Sprite:setPreferredSize() end
--- <summary>
--- virtual void setSpriteFrame(CCSpriteFrame * spriteFrame);
--- </summary>
function CCScale9Sprite:setSpriteFrame() end
--- <summary>
--- virtual bool updateWithBatchNode(CCSpriteBatchNode* batchnode, CCRect rect, bool rotated, CCRect capInsets);
--- </summary>
function CCScale9Sprite:updateWithBatchNode() end
--- <summary>
--- //@js NA
--- virtual void visit();
--- </summary>
function CCScale9Sprite:visit() end
--- <summary>
--- virtual ~CCScale9Sprite();
--- </summary>
function CCScale9Sprite:delete() end

CCScene = class(CCNode)
--- <summary>
--- static CCScene *create(void);
--- </summary>
--- <returns type="CCScene"></returns>
function CCScene:create() end

CCTimer = class(CCObject)
--- <summary>
--- //get interval in seconds 
--- float getInterval(void) const;
--- </summary>
function CCTimer:getInterval() end
--- <summary>
--- //set interval in seconds 
--- void setInterval(float fInterval);
--- </summary>
function CCTimer:setInterval() end
--- <summary>
--- //Allocates a timer with a script callback function and an interval in seconds. 
--- static CCTimer* timerWithScriptHandler(int nHandler, float fSeconds);
--- </summary>
--- <returns type="CCTimer"></returns>
function CCTimer:timerWithScriptHandler() end
--- <summary>
--- //triggers the timer 
--- void update(float dt);
--- </summary>
function CCTimer:update() end

CCScheduler = class(CCObject)
--- <summary>
--- float getTimeScale(void);
--- </summary>
function CCScheduler:getTimeScale() end
--- <summary>
--- //The scheduled script callback will be called every 'interval' seconds.
--- //If paused is YES, then it won't be called until it is resumed.
--- //If 'interval' is 0, it will be called every frame.
--- //return schedule script entry ID, used for unscheduleScriptFunc().
--- //@js NA
--- unsigned int scheduleScriptFunc(unsigned int nHandler, float fInterval, bool bPaused);
--- </summary>
function CCScheduler:scheduleScriptFunc() end
--- <summary>
--- //Modifies the time of all scheduled callbacks.
--- //You can use this property to create a 'slow motion' or 'fast forward' effect.
--- //Default is 1.0. To create a 'slow motion' effect, use values below 1.0.
--- //To create a 'fast forward' effect, use values higher than 1.0.
--- //@since v0.8
--- //@warning It will affect EVERY scheduled selector / action.
--- inline void setTimeScale(float fTimeScale);
--- </summary>
function CCScheduler:setTimeScale() end
--- <summary>
--- //Unschedule a script entry. 
--- //@js NA
--- void unscheduleScriptEntry(unsigned int uScheduleScriptEntryID);
--- </summary>
function CCScheduler:unscheduleScriptEntry() end

CCScrollView = class(CCLayer)
--- <summary>
--- //@js ctor
--- CCScrollView();
--- </summary>
function CCScrollView:new() end
function CCScrollView:new_local() end
--- <summary>
--- virtual void addChild(CCNode * child, int zOrder, int tag);
--- virtual void addChild(CCNode * child, int zOrder);
--- virtual void addChild(CCNode * child);
--- </summary>
function CCScrollView:addChild() end
--- <summary>
--- virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCScrollView:ccTouchBegan() end
--- <summary>
--- virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCScrollView:ccTouchCancelled() end
--- <summary>
--- virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCScrollView:ccTouchEnded() end
--- <summary>
--- virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCScrollView:ccTouchMoved() end
--- <summary>
--- //Returns an autoreleased scroll view object.
--- //@param size view size
--- //@param container parent object
--- //@return autoreleased scroll view object
--- static CCScrollView* create(CCSize size, CCNode* container = NULL);
--- 
--- //Returns an autoreleased scroll view object.
--- //@param size view size
--- //@param container parent object
--- //@return autoreleased scroll view object
--- static CCScrollView* create();
--- </summary>
--- <returns type="CCScrollView"></returns>
function CCScrollView:create() end
--- <summary>
--- CCNode * getContainer();
--- </summary>
--- <returns type="CCNode"></returns>
function CCScrollView:getContainer() end
--- <summary>
--- CCPoint getContentOffset();
--- </summary>
--- <returns type="CCPoint"></returns>
function CCScrollView:getContentOffset() end
--- <summary>
--- virtual const CCSize&amp; getContentSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function CCScrollView:getContentSize() end
--- <summary>
--- //direction allowed to scroll. CCScrollViewDirectionBoth by default.
--- CCScrollViewDirection getDirection();
--- </summary>
--- <returns type="CCScrollViewDirection"></returns>
function CCScrollView:getDirection() end
--- <summary>
--- int  getScriptHandler(int scriptHandlerType);
--- </summary>
function CCScrollView:getScriptHandler() end
--- <summary>
--- //size to clip. CCNode boundingBox uses contentSize directly.
--- //It's semantically different what it actually means to common scroll views.
--- //Hence, this scroll view will use a separate size property.
--- CCSize getViewSize();
--- </summary>
--- <returns type="CCSize"></returns>
function CCScrollView:getViewSize() end
--- <summary>
--- float getZoomScale();
--- </summary>
function CCScrollView:getZoomScale() end
--- <summary>
--- bool init();
--- </summary>
function CCScrollView:init() end
--- <summary>
--- //Returns a scroll view object
--- //@param size view size
--- //@param container parent object
--- //@return scroll view object
--- bool initWithViewSize(CCSize size, CCNode* container = NULL);
--- </summary>
function CCScrollView:initWithViewSize() end
--- <summary>
--- bool isBounceable();
--- </summary>
function CCScrollView:isBounceable() end
--- <summary>
--- //Determines whether it clips its children or not.
--- bool isClippingToBounds();
--- </summary>
function CCScrollView:isClippingToBounds() end
--- <summary>
--- bool isDragging();
--- </summary>
function CCScrollView:isDragging() end
--- <summary>
--- //Determines if a given node's bounding box is in visible bounds
--- //@return YES if it is in visible bounds
--- bool isNodeVisible(CCNode * node);
--- </summary>
function CCScrollView:isNodeVisible() end
--- <summary>
--- bool isTouchMoved();
--- </summary>
function CCScrollView:isTouchMoved() end
--- <summary>
--- //Returns the current container's maximum offset. You may want this while you animate scrolling by yourself
--- CCPoint maxContainerOffset(); 
--- </summary>
--- <returns type="CCPoint"></returns>
function CCScrollView:maxContainerOffset() end
--- <summary>
--- //Returns the current container's minimum offset. You may want this while you animate scrolling by yourself
--- CCPoint minContainerOffset();
--- </summary>
--- <returns type="CCPoint"></returns>
function CCScrollView:minContainerOffset() end
--- <summary>
--- //Provided to make scroll view compatible with SWLayer's pause method
--- void pause(CCObject* sender);
--- </summary>
function CCScrollView:pause() end
--- <summary>
--- virtual void registerWithTouchDispatcher();
--- </summary>
function CCScrollView:registerWithTouchDispatcher() end
--- <summary>
--- //Provided to make scroll view compatible with SWLayer's resume method
--- void resume(CCObject* sender);
--- </summary>
function CCScrollView:resume() end
--- <summary>
--- void setBounceable(bool bBounceable);
--- </summary>
function CCScrollView:setBounceable() end
--- <summary>
--- void setClippingToBounds(bool bClippingToBounds);
--- </summary>
function CCScrollView:setClippingToBounds() end
--- <summary>
--- void setContainer(CCNode * pContainer);
--- </summary>
function CCScrollView:setContainer() end
--- <summary>
--- //Sets a new content offset. It ignores max/min offset. It just sets what's given. (just like UIKit's UIScrollView)
--- //@param offset new offset
--- //@param If YES, the view scrolls to the new offset
--- void setContentOffset(CCPoint offset, bool animated = false);
--- </summary>
function CCScrollView:setContentOffset() end
--- <summary>
--- //Sets a new content offset. It ignores max/min offset. It just sets what's given. (just like UIKit's UIScrollView)
--- //You can override the animation duration with this method.
--- //@param offset new offset
--- //@param animation duration
--- void setContentOffsetInDuration(CCPoint offset, float dt); 
--- </summary>
function CCScrollView:setContentOffsetInDuration() end
--- <summary>
--- virtual void setDirection(CCScrollViewDirection eDirection);
--- </summary>
function CCScrollView:setDirection() end
--- <summary>
--- void setTouchEnabled(bool e);
--- </summary>
function CCScrollView:setTouchEnabled() end
--- <summary>
--- void setViewSize(CCSize size);
--- </summary>
function CCScrollView:setViewSize() end
--- <summary>
--- //Sets a new scale and does that for a predefined duration.
--- //@param s a new scale vale
--- //@param animated if YES, scaling is animated
--- void setZoomScale(float s, bool animated);
--- </summary>
function CCScrollView:setZoomScale() end
--- <summary>
--- //Sets a new scale for container in a given duration.
--- //@param s a new scale value
--- //@param animation duration
--- void setZoomScaleInDuration(float s, float dt);
--- </summary>
function CCScrollView:setZoomScaleInDuration() end
--- <summary>
--- void unregisterScriptHandler(int scriptHandlerType);
--- </summary>
function CCScrollView:unregisterScriptHandler() end
--- <summary>
--- void updateInset();
--- </summary>
function CCScrollView:updateInset() end
--- <summary>
--- //@js NA
--- //@lua NA
--- virtual ~CCScrollView();
--- </summary>
function CCScrollView:delete() end

CCSet = class(CCObject)
--- <summary>
--- //@brief Add a element into CCSet, it will retain the element.
--- void addObject(CCObject *pObject);
--- </summary>
function CCSet:addObject() end
--- <summary>
--- //@brief Return the first element if it contains elements, or null if it doesn't contain any element.
--- CCObject* anyObject();
--- </summary>
--- <returns type="CCObject"></returns>
function CCSet:anyObject() end
--- <summary>
--- //@brief Check if CCSet contains a element equals pObject.
--- bool containsObject(CCObject *pObject);
--- </summary>
function CCSet:containsObject() end
--- <summary>
--- //@brief Return a copy of the CCSet, it will copy all the elements.
--- CCSet* copy();
--- </summary>
--- <returns type="CCSet"></returns>
function CCSet:copy() end
--- <summary>
--- //@brief Return the number of elements the CCSet contains.
--- int count();
--- </summary>
function CCSet:count() end
--- <summary>
--- //@brief Remove all elements of the set
--- void removeAllObjects();
--- </summary>
function CCSet:removeAllObjects() end
--- <summary>
--- //@brief Remove the given element, nothing todo if no element equals pObject.
--- void removeObject(CCObject *pObject);
--- </summary>
function CCSet:removeObject() end

CCSkin = class(CCSprite)
--- <summary>
--- //@js ctor
--- CCSkin();
--- </summary>
function CCSkin:new() end
function CCSkin:new_local() end
--- <summary>
--- static CCSkin *create();
--- static CCSkin *create(const char *pszFileName);
--- </summary>
--- <returns type="CCSkin"></returns>
function CCSkin:create() end
--- <summary>
--- static CCSkin *createWithSpriteFrameName(const char *pszSpriteFrameName);
--- </summary>
--- <returns type="CCSkin"></returns>
function CCSkin:createWithSpriteFrameName() end
--- <summary>
--- virtual CCBone* getBone();
--- </summary>
--- <returns type="CCBone"></returns>
function CCSkin:getBone() end
--- <summary>
--- std::string getDisplayName() const;
--- </summary>
--- <returns type="std::string"></returns>
function CCSkin:getDisplayName() end
--- <summary>
--- virtual const CCBaseData&amp; getSkinData(void);
--- </summary>
--- <returns type="CCBaseData"></returns>
function CCSkin:getSkinData() end
--- <summary>
--- bool initWithFile(const char *pszFilename);
--- </summary>
function CCSkin:initWithFile() end
--- <summary>
--- bool initWithSpriteFrameName(const char *pszSpriteFrameName);
--- </summary>
function CCSkin:initWithSpriteFrameName() end
--- <summary>
--- CCAffineTransform nodeToWorldTransform();
--- </summary>
--- <returns type="CCAffineTransform"></returns>
function CCSkin:nodeToWorldTransform() end
--- <summary>
--- CCAffineTransform nodeToWorldTransformAR();
--- </summary>
--- <returns type="CCAffineTransform"></returns>
function CCSkin:nodeToWorldTransformAR() end
--- <summary>
--- virtual void setBone(CCBone* var);
--- </summary>
function CCSkin:setBone() end
--- <summary>
--- virtual void setSkinData(const CCBaseData&amp; var);
--- </summary>
function CCSkin:setSkinData() end
--- <summary>
--- void updateArmatureTransform();
--- </summary>
function CCSkin:updateArmatureTransform() end
--- <summary>
--- void updateTransform();
--- </summary>
function CCSkin:updateTransform() end

CCSprite = class(CCNodeRGBA)
--- <summary>
--- void addChild(CCNode* pChild);
--- void addChild(CCNode* pChild, int zOrder);
--- void addChild(CCNode* pChild, int zOrder, int tag);
--- </summary>
function CCSprite:addChild() end
--- <summary>
--- //Creates an empty sprite without texture. You can call setTexture method subsequently.
--- //@return An empty sprite object that is marked as autoreleased.
--- static CCSprite* create();
--- 
--- //Creates a sprite with an image filename.
--- //After creation, the rect of sprite will be the size of the image,
--- //and the offset will be (0,0).
--- //@param   pszFileName The string which indicates a path to image file, e.g., "scene1/monster.png".
--- //@return  A valid sprite object that is marked as autoreleased.
--- static CCSprite* create(const char *pszFileName);
--- 
--- //Creates a sprite with an image filename and a rect.
--- //@param   pszFileName The string wich indicates a path to image file, e.g., "scene1/monster.png"
--- //@param   rect        Only the contents inside rect of pszFileName's texture will be applied for this sprite.
--- //@return  A valid sprite object that is marked as autoreleased.
--- static CCSprite* create(const char *pszFileName, const CCRect&amp; rect);
--- </summary>
--- <returns type="CCSprite"></returns>
function CCSprite:create() end
--- <summary>
--- //Creates a sprite with an sprite frame.
--- //@param   pSpriteFrame    A sprite frame which involves a texture and a rect
--- //@return  A valid sprite object that is marked as autoreleased.
--- static CCSprite* createWithSpriteFrame(CCSpriteFrame *pSpriteFrame);
--- </summary>
--- <returns type="CCSprite"></returns>
function CCSprite:createWithSpriteFrame() end
--- <summary>
--- //Creates a sprite with an sprite frame name.
--- //A CCSpriteFrame will be fetched from the CCSpriteFrameCache by pszSpriteFrameName param.
--- //If the CCSpriteFrame doesn't exist it will raise an exception.
--- //@param   pszSpriteFrameName A null terminated string which indicates the sprite frame name.
--- //@return  A valid sprite object that is marked as autoreleased.
--- static CCSprite* createWithSpriteFrameName(const char *pszSpriteFrameName);
--- </summary>
--- <returns type="CCSprite"></returns>
function CCSprite:createWithSpriteFrameName() end
--- <summary>
--- //Creates a sprite with an exsiting texture contained in a CCTexture2D object
--- //After creation, the rect will be the size of the texture, and the offset will be (0,0).
--- //@param   pTexture    A pointer to a CCTexture2D object.
--- //@return  A valid sprite object that is marked as autoreleased.
--- static CCSprite* createWithTexture(CCTexture2D *pTexture);
--- 
--- //Creates a sprite with a texture and a rect.
--- //After creation, the offset will be (0,0).
--- //@param   pTexture    A pointer to an existing CCTexture2D object.
--- //You can use a CCTexture2D object for many sprites.
--- //@param   rect        Only the contents inside the rect of this texture will be applied for this sprite.
--- //@return  A valid sprite object that is marked as autoreleased.
--- static CCSprite* createWithTexture(CCTexture2D *pTexture, const CCRect&amp; rect);
--- </summary>
--- <returns type="CCSprite"></returns>
function CCSprite:createWithTexture() end
--- <summary>
--- //Returns the current displayed frame.
--- //@js NA
--- virtual CCSpriteFrame* displayFrame(void);
--- </summary>
--- <returns type="CCSpriteFrame"></returns>
function CCSprite:displayFrame() end
--- <summary>
--- //Returns the index used on the TextureAtlas. 
--- inline unsigned int getAtlasIndex(void);
--- </summary>
function CCSprite:getAtlasIndex() end
--- <summary>
--- //Returns the batch node object if this sprite is rendered by CCSpriteBatchNode
--- //@return The CCSpriteBatchNode object if this sprite is rendered by CCSpriteBatchNode,
--- //NULL if the sprite isn't used batch node.
--- virtual CCSpriteBatchNode* getBatchNode(void);
--- </summary>
--- <returns type="CCSpriteBatchNode"></returns>
function CCSprite:getBatchNode() end
--- <summary>
--- //@js NA
--- inline ccBlendFunc getBlendFunc(void);
--- </summary>
--- <returns type="ccBlendFunc"></returns>
function CCSprite:getBlendFunc() end
--- <summary>
--- ccColor3B getColor(void);
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCSprite:getColor() end
--- <summary>
--- //Gets the offset position of the sprite. Calculated automatically by editors like Zwoptex.
--- inline const CCPoint&amp; getOffsetPosition(void);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCSprite:getOffsetPosition() end
--- <summary>
--- GLubyte getOpacity(void);
--- </summary>
--- <returns type="GLubyte"></returns>
function CCSprite:getOpacity() end
--- <summary>
--- //Returns the quad (tex coords, vertex coords and color) information.
--- //@js NA
--- inline ccV3F_C4B_T2F_Quad getQuad(void);
--- </summary>
--- <returns type="ccV3F_C4B_T2F_Quad"></returns>
function CCSprite:getQuad() end
--- <summary>
--- CCTexture2D* getTexture(void);
--- </summary>
--- <returns type="CCTexture2D"></returns>
function CCSprite:getTexture() end
--- <summary>
--- //Gets the weak reference of the CCTextureAtlas when the sprite is rendered using via CCSpriteBatchNode
--- inline CCTextureAtlas* getTextureAtlas(void);
--- </summary>
--- <returns type="CCTextureAtlas"></returns>
function CCSprite:getTextureAtlas() end
--- <summary>
--- //Returns the rect of the CCSprite in points 
--- inline const CCRect&amp; getTextureRect(void);
--- </summary>
--- <returns type="CCRect"></returns>
function CCSprite:getTextureRect() end
--- <summary>
--- void ignoreAnchorPointForPosition(bool newValue);
--- </summary>
function CCSprite:ignoreAnchorPointForPosition() end
--- <summary>
--- //Whether or not the Sprite needs to be updated in the Atlas.
--- //@return true if the sprite needs to be updated in the Atlas, false otherwise.
--- inline virtual bool isDirty(void);
--- </summary>
function CCSprite:isDirty() end
--- <summary>
--- //Returns the flag which indicates whether the sprite is flipped horizontally or not.
--- //It only flips the texture of the sprite, and not the texture of the sprite's children.
--- //Also, flipping the texture doesn't alter the anchorPoint.
--- //If you want to flip the anchorPoint too, and/or to flip the children too use:
--- //sprite->setScaleX(sprite->getScaleX() * -1);
--- //@return true if the sprite is flipped horizaontally, false otherwise.
--- //@js isFlippedX
--- bool isFlipX(void);
--- </summary>
function CCSprite:isFlipX() end
--- <summary>
--- //Return the flag which indicates whether the sprite is flipped vertically or not.
--- //It only flips the texture of the sprite, and not the texture of the sprite's children.
--- //Also, flipping the texture doesn't alter the anchorPoint.
--- //If you want to flip the anchorPoint too, and/or to flip the children too use:
--- //sprite->setScaleY(sprite->getScaleY() * -1);
--- //@return true if the sprite is flipped vertically, flase otherwise.
--- //@js isFlippedY
--- bool isFlipY(void);
--- </summary>
function CCSprite:isFlipY() end
--- <summary>
--- //Returns whether or not a CCSpriteFrame is being displayed
--- virtual bool isFrameDisplayed(CCSpriteFrame *pFrame);
--- </summary>
function CCSprite:isFrameDisplayed() end
--- <summary>
--- bool isOpacityModifyRGB(void);
--- </summary>
function CCSprite:isOpacityModifyRGB() end
--- <summary>
--- //Returns whether or not the texture rectangle is rotated.
--- inline bool isTextureRectRotated(void);
--- </summary>
function CCSprite:isTextureRectRotated() end
--- <summary>
--- void removeAllChildrenWithCleanup(bool bCleanup);
--- </summary>
function CCSprite:removeAllChildrenWithCleanup() end
--- <summary>
--- void removeChild(CCNode* pChild, bool bCleanUp);
--- </summary>
function CCSprite:removeChild() end
--- <summary>
--- void reorderChild(CCNode* pChild, int zOrder);
--- </summary>
function CCSprite:reorderChild() end
--- <summary>
--- //Sets the index used on the TextureAtlas.
--- //@warning Don't modify this value unless you know what you are doing
--- inline void setAtlasIndex(unsigned int uAtlasIndex);
--- </summary>
function CCSprite:setAtlasIndex() end
--- <summary>
--- //Sets the batch node to sprite
--- //@warning This method is not recommended for game developers. Sample code for using batch node
--- //@code
--- //CCSpriteBatchNode *batch = CCSpriteBatchNode::create("Images/grossini_dance_atlas.png", 15);
--- //CCSprite *sprite = CCSprite::createWithTexture(batch->getTexture(), CCRectMake(0, 0, 57, 57));
--- //batch->addChild(sprite);
--- //layer->addChild(batch);
--- //@endcode
--- virtual void setBatchNode(CCSpriteBatchNode *pobSpriteBatchNode);
--- </summary>
function CCSprite:setBatchNode() end
--- <summary>
--- void setBlendFunc(ccBlendFunc blendFunc);
--- </summary>
function CCSprite:setBlendFunc() end
--- <summary>
--- void setColor(ccColor3B color3);
--- </summary>
function CCSprite:setColor() end
--- <summary>
--- //Makes the Sprite to be updated in the Atlas.
--- inline virtual void setDirty(bool bDirty);
--- </summary>
function CCSprite:setDirty() end
--- <summary>
--- //Sets a new display frame to the CCSprite.
--- virtual void setDisplayFrame(CCSpriteFrame *pNewFrame);
--- </summary>
function CCSprite:setDisplayFrame() end
--- <summary>
--- //Changes the display frame with animation name and index.
--- //The animation name will be get from the CCAnimationCache
--- virtual void setDisplayFrameWithAnimationName(const char *animationName, int frameIndex);
--- </summary>
function CCSprite:setDisplayFrameWithAnimationName() end
--- <summary>
--- //Sets whether the sprite should be flipped horizontally or not.
--- //@param bFlipX true if the sprite should be flipped horizaontally, false otherwise.
--- void setFlipX(bool bFlipX);
--- </summary>
function CCSprite:setFlipX() end
--- <summary>
--- //Sets whether the sprite should be flipped vertically or not.
--- //@param bFlipY true if the sprite should be flipped vertically, flase otherwise.
--- void setFlipY(bool bFlipY);
--- </summary>
function CCSprite:setFlipY() end
--- <summary>
--- void setOpacity(GLubyte opacity);
--- </summary>
function CCSprite:setOpacity() end
--- <summary>
--- void setOpacityModifyRGB(bool bValue);
--- </summary>
function CCSprite:setOpacityModifyRGB() end
--- <summary>
--- void setRotation(float rotation);
--- </summary>
function CCSprite:setRotation() end
--- <summary>
--- void setScale(float fScale);
--- </summary>
function CCSprite:setScale() end
--- <summary>
--- void setScaleX(float fScaleX);
--- </summary>
function CCSprite:setScaleX() end
--- <summary>
--- void setScaleY(float fScaleY);
--- </summary>
function CCSprite:setScaleY() end
--- <summary>
--- void setSkewX(float sx);
--- </summary>
function CCSprite:setSkewX() end
--- <summary>
--- void setSkewY(float sy);
--- </summary>
function CCSprite:setSkewY() end
--- <summary>
--- void setTexture(CCTexture2D *texture);
--- </summary>
function CCSprite:setTexture() end
--- <summary>
--- //Sets the weak reference of the CCTextureAtlas when the sprite is rendered using via CCSpriteBatchNode
--- inline void setTextureAtlas(CCTextureAtlas *pobTextureAtlas);
--- </summary>
function CCSprite:setTextureAtlas() end
--- <summary>
--- //Updates the texture rect of the CCSprite in points.
--- //It will call setTextureRect:rotated:untrimmedSize with rotated = NO, and utrimmedSize = rect.size.
--- virtual void setTextureRect(const CCRect&amp; rect);
--- 
--- //Sets the texture rect, rectRotated and untrimmed size of the CCSprite in points.
--- //It will update the texture coordinates and the vertex rectangle.
--- virtual void setTextureRect(const CCRect&amp; rect, bool rotated, const CCSize&amp; untrimmedSize);
--- </summary>
function CCSprite:setTextureRect() end
--- <summary>
--- //Sets the vertex rect.
--- //It will be called internally by setTextureRect.
--- //Useful if you want to create 2x images from SD images in Retina Display.
--- //Do not call it manually. Use setTextureRect instead.
--- virtual void setVertexRect(const CCRect&amp; rect);
--- </summary>
function CCSprite:setVertexRect() end
--- <summary>
--- void setVertexZ(float fVertexZ);
--- </summary>
function CCSprite:setVertexZ() end
--- <summary>
--- void setVisible(bool bVisible);
--- </summary>
function CCSprite:setVisible() end
--- <summary>
--- void sortAllChildren();
--- </summary>
function CCSprite:sortAllChildren() end
--- <summary>
--- //Updates the quad according the rotation, position, scale values. 
--- virtual void updateTransform(void);
--- </summary>
function CCSprite:updateTransform() end

CCSpriteBatchNode = class(CCNode)
--- <summary>
--- void addChild(CCNode * child);
--- void addChild(CCNode * child, int zOrder);
--- void addChild(CCNode * child, int zOrder, int tag);
--- </summary>
function CCSpriteBatchNode:addChild() end
--- <summary>
--- void appendChild(CCSprite *child);
--- </summary>
function CCSpriteBatchNode:appendChild() end
--- <summary>
--- unsigned int atlasIndexForChild(CCSprite *sprite, int z);
--- </summary>
function CCSpriteBatchNode:atlasIndexForChild() end
--- <summary>
--- //creates a CCSpriteBatchNode with a file image (.png, .jpeg, .pvr, etc) and capacity of children.
--- //The capacity will be increased in 33% in runtime if it run out of space.
--- //The file will be loaded using the TextureMgr.
--- static CCSpriteBatchNode* create(const char* fileImage, unsigned int capacity);
--- </summary>
--- <returns type="CCSpriteBatchNode"></returns>
function CCSpriteBatchNode:create() end
--- <summary>
--- //creates a CCSpriteBatchNode with a texture2d and capacity of children.
--- //The capacity will be increased in 33% in runtime if it run out of space.
--- static CCSpriteBatchNode* createWithTexture(CCTexture2D* tex, unsigned int capacity);
--- </summary>
--- <returns type="CCSpriteBatchNode"></returns>
function CCSpriteBatchNode:createWithTexture() end
--- <summary>
--- //@js NA
--- virtual ccBlendFunc getBlendFunc(void);
--- </summary>
--- <returns type="ccBlendFunc"></returns>
function CCSpriteBatchNode:getBlendFunc() end
--- <summary>
--- CCArray* getDescendants(void);
--- </summary>
--- <returns type="CCArray"></returns>
function CCSpriteBatchNode:getDescendants() end
--- <summary>
--- CCTexture2D* getTexture(void);
--- </summary>
--- <returns type="CCTexture2D"></returns>
function CCSpriteBatchNode:getTexture() end
--- <summary>
--- CCTextureAtlas* getTextureAtlas(void);
--- </summary>
--- <returns type="CCTextureAtlas"></returns>
function CCSpriteBatchNode:getTextureAtlas() end
--- <summary>
--- unsigned int highestAtlasIndexInChild(CCSprite *sprite);
--- </summary>
function CCSpriteBatchNode:highestAtlasIndexInChild() end
--- <summary>
--- void increaseAtlasCapacity();
--- </summary>
function CCSpriteBatchNode:increaseAtlasCapacity() end
--- <summary>
--- void insertChild(CCSprite *child, unsigned int index);
--- </summary>
function CCSpriteBatchNode:insertChild() end
--- <summary>
--- unsigned int lowestAtlasIndexInChild(CCSprite *sprite);
--- </summary>
function CCSpriteBatchNode:lowestAtlasIndexInChild() end
--- <summary>
--- unsigned int rebuildIndexInOrder(CCSprite *parent, unsigned int index);
--- </summary>
function CCSpriteBatchNode:rebuildIndexInOrder() end
--- <summary>
--- void removeAllChildrenWithCleanup(bool cleanup);
--- </summary>
function CCSpriteBatchNode:removeAllChildrenWithCleanup() end
--- <summary>
--- void removeChild(CCNode* child, bool cleanup);
--- </summary>
function CCSpriteBatchNode:removeChild() end
--- <summary>
--- //removes a child given a certain index. It will also cleanup the running actions depending on the cleanup parameter.
--- //@warning Removing a child from a CCSpriteBatchNode is very slow
--- void removeChildAtIndex(unsigned int index, bool doCleanup);
--- </summary>
function CCSpriteBatchNode:removeChildAtIndex() end
--- <summary>
--- void removeSpriteFromAtlas(CCSprite *sprite);
--- </summary>
function CCSpriteBatchNode:removeSpriteFromAtlas() end
--- <summary>
--- void reorderBatch(bool reorder);
--- </summary>
function CCSpriteBatchNode:reorderBatch() end
--- <summary>
--- void reorderChild(CCNode * child, int zOrder);
--- </summary>
function CCSpriteBatchNode:reorderChild() end
--- <summary>
--- void setBlendFunc(ccBlendFunc blendFunc);
--- </summary>
function CCSpriteBatchNode:setBlendFunc() end
--- <summary>
--- void setTexture(CCTexture2D *texture);
--- </summary>
function CCSpriteBatchNode:setTexture() end
--- <summary>
--- void setTextureAtlas(CCTextureAtlas* textureAtlas);
--- </summary>
function CCSpriteBatchNode:setTextureAtlas() end
--- <summary>
--- void sortAllChildren();
--- </summary>
function CCSpriteBatchNode:sortAllChildren() end

CCSpriteFrame = class(CCObject)
--- <summary>
--- //Create a CCSpriteFrame with a texture filename, rect in points.
--- //It is assumed that the frame was not trimmed.
--- static CCSpriteFrame* create(const char* filename, const CCRect&amp; rect);
--- 
--- //Create a CCSpriteFrame with a texture filename, rect, rotated, offset and originalSize in pixels.
--- //The originalSize is the size in pixels of the frame before being trimmed.
--- static CCSpriteFrame* create(const char* filename, const CCRect&amp; rect, bool rotated, const CCPoint&amp; offset, const CCSize&amp; originalSize);
--- </summary>
--- <returns type="CCSpriteFrame"></returns>
function CCSpriteFrame:create() end
--- <summary>
--- //Create a CCSpriteFrame with a texture, rect in points.
--- //It is assumed that the frame was not trimmed.
--- static CCSpriteFrame* createWithTexture(CCTexture2D* pobTexture, const CCRect&amp; rect);
--- 
--- //Create a CCSpriteFrame with a texture, rect, rotated, offset and originalSize in pixels.
--- //The originalSize is the size in points of the frame before being trimmed.
--- static CCSpriteFrame* createWithTexture(CCTexture2D* pobTexture, const CCRect&amp; rect, bool rotated, const CCPoint&amp; offset, const CCSize&amp; originalSize);
--- </summary>
--- <returns type="CCSpriteFrame"></returns>
function CCSpriteFrame:createWithTexture() end
--- <summary>
--- const CCPoint &amp; getOffset();
--- </summary>
--- <returns type="CCPoint"></returns>
function CCSpriteFrame:getOffset() end
--- <summary>
--- //get offset of the frame 
--- const CCPoint&amp; getOffsetInPixels(void);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCSpriteFrame:getOffsetInPixels() end
--- <summary>
--- //get original size of the trimmed image 
--- inline const CCSize&amp; getOriginalSize(void);
--- </summary>
--- <returns type="CCSize"></returns>
function CCSpriteFrame:getOriginalSize() end
--- <summary>
--- //get original size of the trimmed image 
--- inline const CCSize&amp; getOriginalSizeInPixels(void);
--- </summary>
--- <returns type="CCSize"></returns>
function CCSpriteFrame:getOriginalSizeInPixels() end
--- <summary>
--- //get rect of the frame 
--- inline const CCRect&amp; getRect(void);
--- </summary>
--- <returns type="CCRect"></returns>
function CCSpriteFrame:getRect() end
--- <summary>
--- CCRect getRectInPixels(void);
--- </summary>
--- <returns type="CCRect"></returns>
function CCSpriteFrame:getRectInPixels() end
--- <summary>
--- //get texture of the frame 
--- CCTexture2D* getTexture(void);
--- </summary>
--- <returns type="CCTexture2D"></returns>
function CCSpriteFrame:getTexture() end
--- <summary>
--- bool isRotated(void);
--- </summary>
function CCSpriteFrame:isRotated() end
--- <summary>
--- void setOffset(const CCPoint &amp; offsets);
--- </summary>
function CCSpriteFrame:setOffset() end
--- <summary>
--- //set offset of the frame 
--- void setOffsetInPixels(const CCPoint&amp; offsetInPixels);
--- </summary>
function CCSpriteFrame:setOffsetInPixels() end
--- <summary>
--- //set original size of the trimmed image 
--- inline void setOriginalSize(const CCSize&amp; sizeInPixels);
--- </summary>
function CCSpriteFrame:setOriginalSize() end
--- <summary>
--- //set original size of the trimmed image 
--- inline void setOriginalSizeInPixels(const CCSize&amp; sizeInPixels);
--- </summary>
function CCSpriteFrame:setOriginalSizeInPixels() end
--- <summary>
--- //set rect of the frame 
--- void setRect(const CCRect&amp; rect);
--- </summary>
function CCSpriteFrame:setRect() end
--- <summary>
--- void setRectInPixels(CCRect rectInPixels);
--- </summary>
function CCSpriteFrame:setRectInPixels() end
--- <summary>
--- void setRotated(bool bRotated);
--- </summary>
function CCSpriteFrame:setRotated() end
--- <summary>
--- //set texture of the frame, the texture is retained 
--- void setTexture(CCTexture2D* pobTexture);
--- </summary>
function CCSpriteFrame:setTexture() end

CCSpriteFrameCache = class(CCObject)
--- <summary>
--- //Adds an sprite frame with a given name.
--- //If the name already exists, then the contents of the old name will be replaced with the new one.
--- void addSpriteFrame(CCSpriteFrame *pobFrame, const char *pszFrameName);
--- </summary>
function CCSpriteFrameCache:addSpriteFrame() end
--- <summary>
--- //Adds multiple Sprite Frames from a plist file.
--- //A texture will be loaded automatically. The texture name will composed by replacing the .plist suffix with .png
--- //If you want to use another texture, you should use the addSpriteFramesWithFile:texture method.
--- //@js addSpriteFrames
--- void addSpriteFramesWithFile(const char *pszPlist);
--- 
--- //Adds multiple Sprite Frames from a plist file. The texture will be associated with the created sprite frames.
--- //@since v0.99.5
--- //@js addSpriteFrames
--- void addSpriteFramesWithFile(const char* plist, const char* textureFileName);
--- 
--- //Adds multiple Sprite Frames from a plist file. The texture will be associated with the created sprite frames. 
--- //@js addSpriteFrames
--- void addSpriteFramesWithFile(const char *pszPlist, CCTexture2D *pobTexture);
--- </summary>
function CCSpriteFrameCache:addSpriteFramesWithFile() end
--- <summary>
--- //Purges the cache. It releases all the Sprite Frames and the retained instance. 
--- static void purgeSharedSpriteFrameCache(void);
--- </summary>
function CCSpriteFrameCache:purgeSharedSpriteFrameCache() end
--- <summary>
--- //Deletes an sprite frame from the sprite frame cache. 
--- //@js getSpriteFrame
--- void removeSpriteFrameByName(const char *pszName);
--- </summary>
function CCSpriteFrameCache:removeSpriteFrameByName() end
--- <summary>
--- //Purges the dictionary of loaded sprite frames.
--- //Call this method if you receive the "Memory Warning".
--- //In the short term: it will free some resources preventing your app from being killed.
--- //In the medium term: it will allocate more resources.
--- //In the long term: it will be the same.
--- void removeSpriteFrames(void);
--- </summary>
function CCSpriteFrameCache:removeSpriteFrames() end
--- <summary>
--- //Removes multiple Sprite Frames from a plist file.
--- //Sprite Frames stored in this file will be removed.
--- //It is convenient to call this method when a specific texture needs to be removed.
--- //@since v0.99.5
--- void removeSpriteFramesFromFile(const char* plist);
--- </summary>
function CCSpriteFrameCache:removeSpriteFramesFromFile() end
--- <summary>
--- //Removes all Sprite Frames associated with the specified textures.
--- //It is convenient to call this method when a specific texture needs to be removed.
--- //@since v0.995.
--- void removeSpriteFramesFromTexture(CCTexture2D* texture);
--- </summary>
function CCSpriteFrameCache:removeSpriteFramesFromTexture() end
--- <summary>
--- //Removes unused sprite frames.
--- //Sprite Frames that have a retain count of 1 will be deleted.
--- //It is convenient to call this method after when starting a new Scene.
--- void removeUnusedSpriteFrames(void);
--- </summary>
function CCSpriteFrameCache:removeUnusedSpriteFrames() end
--- <summary>
--- //Returns the shared instance of the Sprite Frame cache 
--- //@js getInstance
--- static CCSpriteFrameCache* sharedSpriteFrameCache(void);
--- </summary>
--- <returns type="CCSpriteFrameCache"></returns>
function CCSpriteFrameCache:sharedSpriteFrameCache() end
--- <summary>
--- //Returns an Sprite Frame that was previously added.
--- //If the name is not found it will return nil.
--- //You should retain the returned copy if you are going to use it.
--- //@js getSpriteFrame
--- CCSpriteFrame* spriteFrameByName(const char *pszName);
--- </summary>
--- <returns type="CCSpriteFrame"></returns>
function CCSpriteFrameCache:spriteFrameByName() end

CCString = class(CCObject)
--- <summary>
--- //convert to bool value 
--- bool boolValue() const;
--- </summary>
function CCString:boolValue() end
--- <summary>
--- //compare to a c string 
--- int compare(const char *) const;
--- </summary>
function CCString:compare() end
--- <summary>
--- //create a string with std string, you can also pass a c string pointer because the default constructor of std::string can access a c string pointer. 
--- //@return A CCString pointer which is an autorelease object pointer,
--- //it means that you needn't do a release operation unless you retain it.
--- static CCString* create(const std::string&amp; str);
--- </summary>
--- <returns type="CCString"></returns>
function CCString:create() end
--- <summary>
--- //create a string with a file, 
--- //@return A CCString pointer which is an autorelease object pointer,
--- //it means that you needn't do a release operation unless you retain it.
--- static CCString* createWithContentsOfFile(const char* pszFileName);
--- </summary>
--- <returns type="CCString"></returns>
function CCString:createWithContentsOfFile() end
--- <summary>
--- //create a string with binary data 
--- //@return A CCString pointer which is an autorelease object pointer,
--- //it means that you needn't do a release operation unless you retain it.
--- static CCString* createWithData(const unsigned char* pData, unsigned long nLen);
--- </summary>
--- <returns type="CCString"></returns>
function CCString:createWithData() end
--- <summary>
--- //convert to double value 
--- double doubleValue() const;
--- </summary>
function CCString:doubleValue() end
--- <summary>
--- //convert to float value 
--- float floatValue() const;
--- </summary>
function CCString:floatValue() end
--- <summary>
--- //get the C string 
--- const char* getCString() const;
--- </summary>
function CCString:getCString() end
--- <summary>
--- //convert to int value 
--- int intValue() const;
--- </summary>
function CCString:intValue() end
--- <summary>
--- bool isEqual(const CCObject* pObject);
--- </summary>
function CCString:isEqual() end
--- <summary>
--- //get the length of string 
--- unsigned int length() const;
--- </summary>
function CCString:length() end
--- <summary>
--- //convert to unsigned int value 
--- unsigned int uintValue() const;
--- </summary>
function CCString:uintValue() end

CCTMXLayer = class(CCSpriteBatchNode)
--- <summary>
--- //creates a CCTMXLayer with an tileset info, a layer info and a map info 
--- static CCTMXLayer * create(CCTMXTilesetInfo *tilesetInfo, CCTMXLayerInfo *layerInfo, CCTMXMapInfo *mapInfo);
--- </summary>
--- <returns type="CCTMXLayer"></returns>
function CCTMXLayer:create() end
--- <summary>
--- const char* getLayerName();
--- </summary>
function CCTMXLayer:getLayerName() end
--- <summary>
--- unsigned int getLayerOrientation();
--- </summary>
function CCTMXLayer:getLayerOrientation() end
--- <summary>
--- CCSize getLayerSize();
--- </summary>
--- <returns type="CCSize"></returns>
function CCTMXLayer:getLayerSize() end
--- <summary>
--- CCSize getMapTileSize();
--- </summary>
--- <returns type="CCSize"></returns>
function CCTMXLayer:getMapTileSize() end
--- <summary>
--- CCDictionary* getProperties();
--- </summary>
--- <returns type="CCDictionary"></returns>
function CCTMXLayer:getProperties() end
--- <summary>
--- CCTMXTilesetInfo* getTileSet();
--- </summary>
--- <returns type="CCTMXTilesetInfo"></returns>
function CCTMXLayer:getTileSet() end
--- <summary>
--- unsigned int* getTiles();
--- </summary>
function CCTMXLayer:getTiles() end
--- <summary>
--- //returns the position in points of a given tile coordinate 
--- //@js getPositionAt
--- CCPoint positionAt(const CCPoint&amp; tileCoordinate);
--- </summary>
--- <returns type="CCPoint"></returns>
function CCTMXLayer:positionAt() end
--- <summary>
--- //return the value for the specific property name 
--- //@js getProperty
--- CCString *propertyNamed(const char *propertyName);
--- </summary>
--- <returns type="CCString"></returns>
function CCTMXLayer:propertyNamed() end
--- <summary>
--- //dealloc the map that contains the tile position from memory.
--- //Unless you want to know at runtime the tiles positions, you can safely call this method.
--- //If you are going to call layer->tileGIDAt() then, don't release the map
--- void releaseMap();
--- </summary>
function CCTMXLayer:releaseMap() end
--- <summary>
--- //removes a tile at given tile coordinate 
--- void removeTileAt(const CCPoint&amp; tileCoordinate);
--- </summary>
function CCTMXLayer:removeTileAt() end
--- <summary>
--- void setLayerName(const char *layerName);
--- </summary>
function CCTMXLayer:setLayerName() end
--- <summary>
--- void setLayerOrientation(unsigned int val);
--- </summary>
function CCTMXLayer:setLayerOrientation() end
--- <summary>
--- void setLayerSize(CCSize val);
--- </summary>
function CCTMXLayer:setLayerSize() end
--- <summary>
--- void setMapTileSize(CCSize val);
--- </summary>
function CCTMXLayer:setMapTileSize() end
--- <summary>
--- void setProperties(CCDictionary* pval);
--- </summary>
function CCTMXLayer:setProperties() end
--- <summary>
--- //sets the tile gid (gid = tile global id) at a given tile coordinate.
--- //The Tile GID can be obtained by using the method "tileGIDAt" or by using the TMX editor -> Tileset Mgr +1.
--- //If a tile is already placed at that position, then it will be removed.
--- void setTileGID(unsigned int gid, const CCPoint&amp; tileCoordinate);
--- </summary>
function CCTMXLayer:setTileGID() end
--- <summary>
--- void setTileSet(CCTMXTilesetInfo* pval);
--- </summary>
function CCTMXLayer:setTileSet() end
--- <summary>
--- void setTiles(unsigned int* pval);
--- </summary>
function CCTMXLayer:setTiles() end
--- <summary>
--- //Creates the tiles 
--- void setupTiles();
--- </summary>
function CCTMXLayer:setupTiles() end
--- <summary>
--- //returns the tile (CCSprite) at a given a tile coordinate.
--- //The returned CCSprite will be already added to the CCTMXLayer. Don't add it again.
--- //The CCSprite can be treated like any other CCSprite: rotated, scaled, translated, opacity, color, etc.
--- //You can remove either by calling:
--- //- layer->removeChild(sprite, cleanup);
--- //- or layer->removeTileAt(ccp(x,y));
--- //@js getTileGIDAt
--- CCSprite* tileAt(const CCPoint&amp; tileCoordinate);
--- </summary>
--- <returns type="CCSprite"></returns>
function CCTMXLayer:tileAt() end
--- <summary>
--- //returns the tile gid at a given tile coordinate.
--- //if it returns 0, it means that the tile is empty.
--- //This method requires the the tile map has not been previously released (eg. don't call layer->releaseMap())
--- //@js tileGIDAt
--- unsigned int tileGIDAt(const CCPoint&amp; tileCoordinate);
--- 
--- //returns the tile gid at a given tile coordinate. It also returns the tile flags.
--- //This method requires the the tile map has not been previously released (eg. don't call [layer releaseMap])
--- //@js tileGIDAt
--- //@lua NA
--- unsigned int tileGIDAt(const CCPoint&amp; tileCoordinate, ccTMXTileFlags* flags);
--- </summary>
function CCTMXLayer:tileGIDAt() end

CCTMXObjectGroup = class(CCObject)
--- <summary>
--- const char* getGroupName();
--- </summary>
function CCTMXObjectGroup:getGroupName() end
--- <summary>
--- CCArray* getObjects();
--- </summary>
--- <returns type="CCArray"></returns>
function CCTMXObjectGroup:getObjects() end
--- <summary>
--- CCPoint getPositionOffset();
--- </summary>
--- <returns type="CCPoint"></returns>
function CCTMXObjectGroup:getPositionOffset() end
--- <summary>
--- CCDictionary* getProperties();
--- </summary>
--- <returns type="CCDictionary"></returns>
function CCTMXObjectGroup:getProperties() end
--- <summary>
--- //return the dictionary for the specific object name.
--- //It will return the 1st object found on the array for the given name.
--- CCDictionary* objectNamed(const char *objectName);
--- </summary>
--- <returns type="CCDictionary"></returns>
function CCTMXObjectGroup:objectNamed() end
--- <summary>
--- //return the value for the specific property name 
--- CCString *propertyNamed(const char* propertyName);
--- </summary>
--- <returns type="CCString"></returns>
function CCTMXObjectGroup:propertyNamed() end
--- <summary>
--- void setGroupName(const char *groupName);
--- </summary>
function CCTMXObjectGroup:setGroupName() end
--- <summary>
--- void setObjects(CCArray* val);
--- </summary>
function CCTMXObjectGroup:setObjects() end
--- <summary>
--- void setPositionOffset(CCPoint pt);
--- </summary>
function CCTMXObjectGroup:setPositionOffset() end
--- <summary>
--- void setProperties(CCDictionary* pval);
--- </summary>
function CCTMXObjectGroup:setProperties() end

CCTMXTiledMap = class(CCNode)
--- <summary>
--- //creates a TMX Tiled Map with a TMX file.
--- static CCTMXTiledMap* create(const char *tmxFile);
--- </summary>
--- <returns type="CCTMXTiledMap"></returns>
function CCTMXTiledMap:create() end
--- <summary>
--- //initializes a TMX Tiled Map with a TMX formatted XML string and a path to TMX resources 
--- static CCTMXTiledMap* createWithXML(const char* tmxString, const char* resourcePath);
--- </summary>
--- <returns type="CCTMXTiledMap"></returns>
function CCTMXTiledMap:createWithXML() end
--- <summary>
--- int getMapOrientation();
--- </summary>
function CCTMXTiledMap:getMapOrientation() end
--- <summary>
--- CCSize getMapSize();
--- </summary>
--- <returns type="CCSize"></returns>
function CCTMXTiledMap:getMapSize() end
--- <summary>
--- CCArray* getObjectGroups();
--- </summary>
--- <returns type="CCArray"></returns>
function CCTMXTiledMap:getObjectGroups() end
--- <summary>
--- CCDictionary* getProperties();
--- </summary>
--- <returns type="CCDictionary"></returns>
function CCTMXTiledMap:getProperties() end
--- <summary>
--- CCSize getTileSize();
--- </summary>
--- <returns type="CCSize"></returns>
function CCTMXTiledMap:getTileSize() end
--- <summary>
--- //return the TMXLayer for the specific layer
--- //@js getLayer
--- CCTMXLayer* layerNamed(const char *layerName);
--- </summary>
--- <returns type="CCTMXLayer"></returns>
function CCTMXTiledMap:layerNamed() end
--- <summary>
--- //return the TMXObjectGroup for the specific group 
--- //@js getObjectGroup
--- CCTMXObjectGroup* objectGroupNamed(const char *groupName);
--- </summary>
--- <returns type="CCTMXObjectGroup"></returns>
function CCTMXTiledMap:objectGroupNamed() end
--- <summary>
--- //return properties dictionary for tile GID 
--- CCDictionary* propertiesForGID(int GID);
--- </summary>
--- <returns type="CCDictionary"></returns>
function CCTMXTiledMap:propertiesForGID() end
--- <summary>
--- //return the value for the specific property name 
--- //@js getProperty
--- CCString *propertyNamed(const char *propertyName);
--- </summary>
--- <returns type="CCString"></returns>
function CCTMXTiledMap:propertyNamed() end
--- <summary>
--- void setMapOrientation(int val);
--- </summary>
function CCTMXTiledMap:setMapOrientation() end
--- <summary>
--- void setMapSize(CCSize sz);
--- </summary>
function CCTMXTiledMap:setMapSize() end
--- <summary>
--- void  setObjectGroups(CCArray* pval);
--- </summary>
function CCTMXTiledMap:setObjectGroups() end
--- <summary>
--- void setProperties(CCDictionary* pval);
--- </summary>
function CCTMXTiledMap:setProperties() end
--- <summary>
--- void setTileSize(CCSize sz);
--- </summary>
function CCTMXTiledMap:setTileSize() end

CCTMXLayerInfo = class(CCObject)
--- <summary>
--- CCDictionary* getProperties();
--- </summary>
--- <returns type="CCDictionary"></returns>
function CCTMXLayerInfo:getProperties() end
--- <summary>
--- void setProperties(CCDictionary* pval);
--- </summary>
function CCTMXLayerInfo:setProperties() end

CCTMXTilesetInfo = class(CCObject)
--- <summary>
--- CCRect rectForGID(unsigned int gid);
--- </summary>
--- <returns type="CCRect"></returns>
function CCTMXTilesetInfo:rectForGID() end

CCTMXMapInfo = class(CCObject)
--- <summary>
--- //@js NA
--- void endElement(void *ctx, const char *name);
--- </summary>
function CCTMXMapInfo:endElement() end
--- <summary>
--- //creates a TMX Format with a tmx file 
--- static CCTMXMapInfo * formatWithTMXFile(const char *tmxFile);
--- </summary>
--- <returns type="CCTMXMapInfo"></returns>
function CCTMXMapInfo:formatWithTMXFile() end
--- <summary>
--- //creates a TMX Format with an XML string and a TMX resource path 
--- static CCTMXMapInfo * formatWithXML(const char* tmxString, const char* resourcePath);
--- </summary>
--- <returns type="CCTMXMapInfo"></returns>
function CCTMXMapInfo:formatWithXML() end
--- <summary>
--- const char* getCurrentString();
--- </summary>
function CCTMXMapInfo:getCurrentString() end
--- <summary>
--- int getLayerAttribs();
--- </summary>
function CCTMXMapInfo:getLayerAttribs() end
--- <summary>
--- CCArray* getLayers();
--- </summary>
--- <returns type="CCArray"></returns>
function CCTMXMapInfo:getLayers() end
--- <summary>
--- CCSize getMapSize();
--- </summary>
--- <returns type="CCSize"></returns>
function CCTMXMapInfo:getMapSize() end
--- <summary>
--- CCArray* getObjectGroups();
--- </summary>
--- <returns type="CCArray"></returns>
function CCTMXMapInfo:getObjectGroups() end
--- <summary>
--- int getOrientation();
--- </summary>
function CCTMXMapInfo:getOrientation() end
--- <summary>
--- int getParentElement();
--- </summary>
function CCTMXMapInfo:getParentElement() end
--- <summary>
--- unsigned int getParentGID();
--- </summary>
function CCTMXMapInfo:getParentGID() end
--- <summary>
--- CCDictionary* getProperties();
--- </summary>
--- <returns type="CCDictionary"></returns>
function CCTMXMapInfo:getProperties() end
--- <summary>
--- bool getStoringCharacters();
--- </summary>
function CCTMXMapInfo:getStoringCharacters() end
--- <summary>
--- const char* getTMXFileName();
--- </summary>
function CCTMXMapInfo:getTMXFileName() end
--- <summary>
--- CCDictionary* getTileProperties();
--- </summary>
--- <returns type="CCDictionary"></returns>
function CCTMXMapInfo:getTileProperties() end
--- <summary>
--- CCSize getTileSize();
--- </summary>
--- <returns type="CCSize"></returns>
function CCTMXMapInfo:getTileSize() end
--- <summary>
--- CCArray* getTilesets();
--- </summary>
--- <returns type="CCArray"></returns>
function CCTMXMapInfo:getTilesets() end
--- <summary>
--- //initializes parsing of an XML file, either a tmx (Map) file or tsx (Tileset) file 
--- bool parseXMLFile(const char *xmlFilename);
--- </summary>
function CCTMXMapInfo:parseXMLFile() end
--- <summary>
--- bool parseXMLString(const char *xmlString);
--- </summary>
function CCTMXMapInfo:parseXMLString() end
--- <summary>
--- void setCurrentString(const char *currentString);
--- </summary>
function CCTMXMapInfo:setCurrentString() end
--- <summary>
--- void setLayerAttribs(int val);
--- </summary>
function CCTMXMapInfo:setLayerAttribs() end
--- <summary>
--- void setLayers(CCArray* pval);
--- </summary>
function CCTMXMapInfo:setLayers() end
--- <summary>
--- void setMapSize(CCSize sz);
--- </summary>
function CCTMXMapInfo:setMapSize() end
--- <summary>
--- void setObjectGroups(CCArray* val);
--- </summary>
function CCTMXMapInfo:setObjectGroups() end
--- <summary>
--- void setOrientation(int val);
--- </summary>
function CCTMXMapInfo:setOrientation() end
--- <summary>
--- void setParentElement(int val);
--- </summary>
function CCTMXMapInfo:setParentElement() end
--- <summary>
--- void setParentGID(unsigned int val);
--- </summary>
function CCTMXMapInfo:setParentGID() end
--- <summary>
--- void setProperties(CCDictionary* pval);
--- </summary>
function CCTMXMapInfo:setProperties() end
--- <summary>
--- void setStoringCharacters(bool val);
--- </summary>
function CCTMXMapInfo:setStoringCharacters() end
--- <summary>
--- void setTMXFileName(const char *fileName);
--- </summary>
function CCTMXMapInfo:setTMXFileName() end
--- <summary>
--- void setTileProperties(CCDictionary* tileProperties);
--- </summary>
function CCTMXMapInfo:setTileProperties() end
--- <summary>
--- void setTileSize(CCSize sz);
--- </summary>
function CCTMXMapInfo:setTileSize() end
--- <summary>
--- void setTilesets(CCArray* pval);
--- </summary>
function CCTMXMapInfo:setTilesets() end
--- <summary>
--- //implement pure virtual methods of CCSAXDelegator
--- //@js NA
--- void startElement(void *ctx, const char *name, const char **atts);
--- </summary>
function CCTMXMapInfo:startElement() end
--- <summary>
--- //@js NA
--- void textHandler(void *ctx, const char *ch, int len);
--- </summary>
function CCTMXMapInfo:textHandler() end

CCTableViewCell = class(CCNode)
--- <summary>
--- unsigned int getIdx();
--- </summary>
function CCTableViewCell:getIdx() end
--- <summary>
--- unsigned int getObjectID();
--- </summary>
function CCTableViewCell:getObjectID() end
--- <summary>
--- void reset();
--- </summary>
function CCTableViewCell:reset() end
--- <summary>
--- void setIdx(unsigned int uIdx);
--- </summary>
function CCTableViewCell:setIdx() end
--- <summary>
--- void setObjectID(unsigned int uIdx);
--- </summary>
function CCTableViewCell:setObjectID() end

CCTableView = class(CCScrollView)
--- <summary>
--- //@js ctor
--- CCTableView();
--- </summary>
function CCTableView:new() end
function CCTableView:new_local() end
--- <summary>
--- void _updateContentSize();
--- </summary>
function CCTableView:_updateContentSize() end
--- <summary>
--- virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCTableView:ccTouchBegan() end
--- <summary>
--- virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCTableView:ccTouchCancelled() end
--- <summary>
--- virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCTableView:ccTouchEnded() end
--- <summary>
--- virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function CCTableView:ccTouchMoved() end
--- <summary>
--- //Returns an existing cell at a given index. Returns nil if a cell is nonexistent at the moment of query.
--- //@param idx index
--- //@return a cell at a given index
--- CCTableViewCell *cellAtIndex(unsigned int idx);
--- </summary>
--- <returns type="CCTableViewCell"></returns>
function CCTableView:cellAtIndex() end
--- <summary>
--- //Dequeues a free cell if available. nil if not.
--- //@return free cell
--- CCTableViewCell *dequeueCell();
--- </summary>
--- <returns type="CCTableViewCell"></returns>
function CCTableView:dequeueCell() end
--- <summary>
--- CCTableViewVerticalFillOrder getVerticalFillOrder();
--- </summary>
--- <returns type="CCTableViewVerticalFillOrder"></returns>
function CCTableView:getVerticalFillOrder() end
--- <summary>
--- bool initWithViewSize(CCSize size, CCNode* container = NULL);
--- </summary>
function CCTableView:initWithViewSize() end
--- <summary>
--- //Inserts a new cell at a given index
--- //@param idx location to insert
--- void insertCellAtIndex(unsigned int idx);
--- </summary>
function CCTableView:insertCellAtIndex() end
--- <summary>
--- //reloads data from data source.  the view will be refreshed.
--- void reloadData();
--- </summary>
function CCTableView:reloadData() end
--- <summary>
--- //Removes a cell at a given index
--- //@param idx index to find a cell
--- void removeCellAtIndex(unsigned int idx);
--- </summary>
function CCTableView:removeCellAtIndex() end
--- <summary>
--- virtual void scrollViewDidScroll(CCScrollView* view);
--- </summary>
function CCTableView:scrollViewDidScroll() end
--- <summary>
--- virtual void scrollViewDidZoom(CCScrollView* view) {}
--- </summary>
function CCTableView:scrollViewDidZoom() end
--- <summary>
--- //determines how cell is ordered and filled in the view.
--- void setVerticalFillOrder(CCTableViewVerticalFillOrder order);
--- </summary>
function CCTableView:setVerticalFillOrder() end
--- <summary>
--- void unregisterAllScriptHandler();
--- </summary>
function CCTableView:unregisterAllScriptHandler() end
--- <summary>
--- //Updates the content of the cell at a given index.
--- //@param idx index to find a cell
--- void updateCellAtIndex(unsigned int idx);
--- </summary>
function CCTableView:updateCellAtIndex() end
--- <summary>
--- //@js NA
--- virtual ~CCTableView();
--- </summary>
function CCTableView:delete() end

CCTextFieldTTF = class(CCLabelTTF)
--- <summary>
--- //@brief    Open keyboard and receive input text.
--- virtual bool attachWithIME();
--- </summary>
function CCTextFieldTTF:attachWithIME() end
--- <summary>
--- //@brief    End text input and close keyboard.
--- virtual bool detachWithIME();
--- </summary>
function CCTextFieldTTF:detachWithIME() end
--- <summary>
--- int getCharCount();
--- </summary>
function CCTextFieldTTF:getCharCount() end
--- <summary>
--- ccColor3B getColorSpaceHolder();
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCTextFieldTTF:getColorSpaceHolder() end
--- <summary>
--- const char * getPlaceHolder(void);
--- </summary>
function CCTextFieldTTF:getPlaceHolder() end
--- <summary>
--- const char* getString(void);
--- </summary>
function CCTextFieldTTF:getString() end
--- <summary>
--- void setColorSpaceHolder(ccColor3B val);
--- </summary>
function CCTextFieldTTF:setColorSpaceHolder() end
--- <summary>
--- void setPlaceHolder(const char * text);
--- </summary>
function CCTextFieldTTF:setPlaceHolder() end
--- <summary>
--- void setString(const char *text);
--- </summary>
function CCTextFieldTTF:setString() end
--- <summary>
--- //creates a CCTextFieldTTF from a fontname, alignment, dimension and font size 
--- static CCTextFieldTTF * textFieldWithPlaceHolder(const char *placeholder, const CCSize&amp; dimensions, CCTextAlignment alignment, const char *fontName, float fontSize);
--- 
--- //creates a CCLabelTTF from a fontname and font size 
--- static CCTextFieldTTF * textFieldWithPlaceHolder(const char *placeholder, const char *fontName, float fontSize);
--- </summary>
--- <returns type="CCTextFieldTTF"></returns>
function CCTextFieldTTF:textFieldWithPlaceHolder() end

ccTexParams = {}
--- <summary>
--- ccTexParams(void);
--- </summary>
function ccTexParams:new() end
function ccTexParams:new_local() end

CCTexture2D = class(CCObject)
--- <summary>
--- //returns the bits-per-pixel of the in-memory OpenGL texture
--- //@since v1.0
--- unsigned int bitsPerPixelForFormat(); 
--- 
--- //Helper functions that returns bits per pixels for a given format.
--- //@since v2.0
--- unsigned int bitsPerPixelForFormat(CCTexture2DPixelFormat format);
--- </summary>
function CCTexture2D:bitsPerPixelForFormat() end
--- <summary>
--- //returns the alpha pixel format
--- //@since v0.8
--- //@js getDefaultAlphaPixelFormat
--- static CCTexture2DPixelFormat defaultAlphaPixelFormat();
--- </summary>
--- <returns type="CCTexture2DPixelFormat"></returns>
function CCTexture2D:defaultAlphaPixelFormat() end
--- <summary>
--- //draws a texture at a given point 
--- void drawAtPoint(const CCPoint&amp; point);
--- </summary>
function CCTexture2D:drawAtPoint() end
--- <summary>
--- //draws a texture inside a rect 
--- void drawInRect(const CCRect&amp; rect);
--- </summary>
function CCTexture2D:drawInRect() end
--- <summary>
--- //Generates mipmap images for the texture.
--- //It only works if the texture size is POT (power of 2).
--- //@since v0.99.0
--- void generateMipmap();
--- </summary>
function CCTexture2D:generateMipmap() end
--- <summary>
--- CCSize getContentSize(void);
--- </summary>
--- <returns type="CCSize"></returns>
function CCTexture2D:getContentSize() end
--- <summary>
--- //content size 
--- const CCSize&amp; getContentSizeInPixels();
--- </summary>
--- <returns type="CCSize"></returns>
function CCTexture2D:getContentSizeInPixels() end
--- <summary>
--- GLfloat getMaxS();
--- </summary>
--- <returns type="GLfloat"></returns>
function CCTexture2D:getMaxS() end
--- <summary>
--- GLfloat getMaxT();
--- </summary>
--- <returns type="GLfloat"></returns>
function CCTexture2D:getMaxT() end
--- <summary>
--- GLuint getName();
--- </summary>
--- <returns type="GLuint"></returns>
function CCTexture2D:getName() end
--- <summary>
--- CCTexture2DPixelFormat getPixelFormat();
--- </summary>
--- <returns type="CCTexture2DPixelFormat"></returns>
function CCTexture2D:getPixelFormat() end
--- <summary>
--- unsigned int getPixelsHigh();
--- </summary>
function CCTexture2D:getPixelsHigh() end
--- <summary>
--- unsigned int getPixelsWide();
--- </summary>
function CCTexture2D:getPixelsWide() end
--- <summary>
--- bool hasMipmaps();
--- </summary>
function CCTexture2D:hasMipmaps() end
--- <summary>
--- bool hasPremultipliedAlpha();
--- </summary>
function CCTexture2D:hasPremultipliedAlpha() end
--- <summary>
--- //@js NA
--- void* keepData(void *data, unsigned int length);
--- </summary>
function CCTexture2D:keepData() end
--- <summary>
--- //These functions are needed to create mutable textures 
--- //@js NA
--- void releaseData(void *data);
--- </summary>
function CCTexture2D:releaseData() end
--- <summary>
--- void setAliasTexParameters();
--- </summary>
function CCTexture2D:setAliasTexParameters() end
--- <summary>
--- void setAntiAliasTexParameters();
--- </summary>
function CCTexture2D:setAntiAliasTexParameters() end
--- <summary>
--- static void setDefaultAlphaPixelFormat(CCTexture2DPixelFormat format);
--- </summary>
function CCTexture2D:setDefaultAlphaPixelFormat() end
--- <summary>
--- void setMaxS(GLfloat val);
--- </summary>
function CCTexture2D:setMaxS() end
--- <summary>
--- void setMaxT(GLfloat val);
--- </summary>
function CCTexture2D:setMaxT() end
--- <summary>
--- void setTexParameters(ccTexParams* texParams);
--- </summary>
function CCTexture2D:setTexParameters() end
--- <summary>
--- //returns the pixel format.
--- //@since v2.0
--- const char* stringForFormat();
--- </summary>
function CCTexture2D:stringForFormat() end

CCTextureAtlas = class(CCObject)
--- <summary>
--- //creates a TextureAtlas with an filename and with an initial capacity for Quads.
--- //The TextureAtlas capacity can be increased in runtime.
--- static CCTextureAtlas* create(const char* file , unsigned int capacity);
--- </summary>
--- <returns type="CCTextureAtlas"></returns>
function CCTextureAtlas:create() end
--- <summary>
--- //creates a TextureAtlas with a previously initialized Texture2D object, and
--- //with an initial capacity for n Quads. 
--- //The TextureAtlas capacity can be increased in runtime.
--- static CCTextureAtlas* createWithTexture(CCTexture2D *texture, unsigned int capacity);
--- </summary>
--- <returns type="CCTextureAtlas"></returns>
function CCTextureAtlas:createWithTexture() end
--- <summary>
--- //draws n quads
--- //n can't be greater than the capacity of the Atlas
--- void drawNumberOfQuads(unsigned int n);
--- </summary>
function CCTextureAtlas:drawNumberOfQuads() end
--- <summary>
--- //draws all the Atlas's Quads
--- void drawQuads();
--- </summary>
function CCTextureAtlas:drawQuads() end
--- <summary>
--- //Ensures that after a realloc quads are still empty
--- //Used internally by CCParticleBatchNode
--- //@since 1.1
--- void fillWithEmptyQuadsFromIndex(unsigned int index, unsigned int amount);
--- </summary>
function CCTextureAtlas:fillWithEmptyQuadsFromIndex() end
--- <summary>
--- unsigned int getCapacity();
--- </summary>
function CCTextureAtlas:getCapacity() end
--- <summary>
--- ccV3F_C4B_T2F_Quad* getQuads();
--- </summary>
--- <returns type="ccV3F_C4B_T2F_Quad"></returns>
function CCTextureAtlas:getQuads() end
--- <summary>
--- CCTexture2D* getTexture();
--- </summary>
--- <returns type="CCTexture2D"></returns>
function CCTextureAtlas:getTexture() end
--- <summary>
--- unsigned int getTotalQuads();
--- </summary>
function CCTextureAtlas:getTotalQuads() end
--- <summary>
--- //Used internally by CCParticleBatchNode
--- //don't use this unless you know what you're doing
--- //@since 1.1
--- void increaseTotalQuadsWith(unsigned int amount);
--- </summary>
function CCTextureAtlas:increaseTotalQuadsWith() end
--- <summary>
--- //Inserts a Quad (texture, vertex and color) at a certain index
--- //index must be between 0 and the atlas capacity - 1
--- //@since v0.8
--- void insertQuad(ccV3F_C4B_T2F_Quad* quad, unsigned int index);
--- </summary>
function CCTextureAtlas:insertQuad() end
--- <summary>
--- //Removes the quad that is located at a certain index and inserts it at a new index
--- //This operation is faster than removing and inserting in a quad in 2 different steps
--- //@since v0.7.2
--- void insertQuadFromIndex(unsigned int fromIndex, unsigned int newIndex);
--- </summary>
function CCTextureAtlas:insertQuadFromIndex() end
--- <summary>
--- //Moves an amount of quads from oldIndex at newIndex
--- //@since v1.1
--- void moveQuadsFromIndex(unsigned int oldIndex, unsigned int amount, unsigned int newIndex);
--- 
--- //Moves quads from index till totalQuads to the newIndex
--- //Used internally by CCParticleBatchNode
--- //This method doesn't enlarge the array if newIndex + quads to be moved > capacity
--- //@since 1.1
--- void moveQuadsFromIndex(unsigned int index, unsigned int newIndex);
--- </summary>
function CCTextureAtlas:moveQuadsFromIndex() end
--- <summary>
--- //removes all Quads.
--- //The TextureAtlas capacity remains untouched. No memory is freed.
--- //The total number of quads to be drawn will be 0
--- //@since v0.7.2
--- void removeAllQuads();
--- </summary>
function CCTextureAtlas:removeAllQuads() end
--- <summary>
--- //removes a quad at a given index number.
--- //The capacity remains the same, but the total number of quads to be drawn is reduced in 1
--- //@since v0.7.2
--- void removeQuadAtIndex(unsigned int index);
--- </summary>
function CCTextureAtlas:removeQuadAtIndex() end
--- <summary>
--- //resize the capacity of the CCTextureAtlas.
--- //The new capacity can be lower or higher than the current one
--- //It returns YES if the resize was successful.
--- //If it fails to resize the capacity it will return NO with a new capacity of 0.
--- bool resizeCapacity(unsigned int n);
--- </summary>
function CCTextureAtlas:resizeCapacity() end
--- <summary>
--- void setQuads(ccV3F_C4B_T2F_Quad* val);
--- </summary>
function CCTextureAtlas:setQuads() end
--- <summary>
--- void setTexture(CCTexture2D* val);
--- </summary>
function CCTextureAtlas:setTexture() end
--- <summary>
--- //updates a Quad (texture, vertex and color) at a certain index
--- //index must be between 0 and the atlas capacity - 1
--- //@since v0.8
--- void updateQuad(ccV3F_C4B_T2F_Quad* quad, unsigned int index);
--- </summary>
function CCTextureAtlas:updateQuad() end

CCTextureCache = class(CCObject)
--- <summary>
--- //Returns a Texture2D object given an file image
--- //If the file image was not previously loaded, it will create a new CCTexture2D
--- //object and it will return it. It will use the filename as a key.
--- //Otherwise it will return a reference of a previously loaded image.
--- //Supported image extensions: .png, .bmp, .tiff, .jpeg, .pvr, .gif
--- CCTexture2D* addImage(const char* fileimage);
--- </summary>
--- <returns type="CCTexture2D"></returns>
function CCTextureCache:addImage() end
--- <summary>
--- //Returns a Texture2D object given an PVR filename
--- //If the file image was not previously loaded, it will create a new CCTexture2D
--- //object and it will return it. Otherwise it will return a reference of a previously loaded image
--- CCTexture2D* addPVRImage(const char* filename);
--- </summary>
--- <returns type="CCTexture2D"></returns>
function CCTextureCache:addPVRImage() end
--- <summary>
--- //Returns a Texture2D object given an UIImage image
--- //If the image was not previously loaded, it will create a new CCTexture2D object and it will return it.
--- //Otherwise it will return a reference of a previously loaded image
--- //The "key" parameter will be used as the "key" for the cache.
--- //If "key" is nil, then a new texture will be created each time.
--- CCTexture2D* addUIImage(CCImage *image, const char *key);
--- </summary>
--- <returns type="CCTexture2D"></returns>
function CCTextureCache:addUIImage() end
--- <summary>
--- //Output to CCLOG the current contents of this CCTextureCache
--- //This will attempt to calculate the size of each texture, and the total texture memory in use
--- //@since v1.0
--- void dumpCachedTextureInfo();
--- </summary>
function CCTextureCache:dumpCachedTextureInfo() end
--- <summary>
--- //purges the cache. It releases the retained instance.
--- //@since v0.99.0
--- static void purgeSharedTextureCache();
--- </summary>
function CCTextureCache:purgeSharedTextureCache() end
--- <summary>
--- //Reload all textures
--- //It's only useful when the value of CC_ENABLE_CACHE_TEXTURE_DATA is 1
--- static void reloadAllTextures();
--- </summary>
function CCTextureCache:reloadAllTextures() end
--- <summary>
--- //Purges the dictionary of loaded textures.
--- //Call this method if you receive the "Memory Warning"
--- //In the short term: it will free some resources preventing your app from being killed
--- //In the medium term: it will allocate more resources
--- //In the long term: it will be the same
--- void removeAllTextures();
--- </summary>
function CCTextureCache:removeAllTextures() end
--- <summary>
--- //Deletes a texture from the cache given a texture
--- void removeTexture(CCTexture2D* texture);
--- </summary>
function CCTextureCache:removeTexture() end
--- <summary>
--- //Deletes a texture from the cache given a its key name
--- //@since v0.99.4
--- void removeTextureForKey(const char *textureKeyName);
--- </summary>
function CCTextureCache:removeTextureForKey() end
--- <summary>
--- //Removes unused textures
--- //Textures that have a retain count of 1 will be deleted
--- //It is convenient to call this method after when starting a new Scene
--- //@since v0.8
--- void removeUnusedTextures();
--- </summary>
function CCTextureCache:removeUnusedTextures() end
--- <summary>
--- //Returns the shared instance of the cache 
--- //@js getInstance
--- static CCTextureCache * sharedTextureCache();
--- </summary>
--- <returns type="CCTextureCache"></returns>
function CCTextureCache:sharedTextureCache() end
--- <summary>
--- //Returns an already created texture. Returns nil if the texture doesn't exist.
--- //@since v0.99.5
--- CCTexture2D* textureForKey(const char* key);
--- </summary>
--- <returns type="CCTexture2D"></returns>
function CCTextureCache:textureForKey() end

CCTileMapAtlas = class(CCAtlasNode)
--- <summary>
--- //creates a CCTileMap with a tile file (atlas) with a map file and the width and height of each tile in points.
--- //The tile file will be loaded using the TextureMgr.
--- static CCTileMapAtlas * create(const char *tile, const char *mapFile, int tileWidth, int tileHeight);
--- </summary>
--- <returns type="CCTileMapAtlas"></returns>
function CCTileMapAtlas:create() end
--- <summary>
--- //dealloc the map from memory 
--- void releaseMap();
--- </summary>
function CCTileMapAtlas:releaseMap() end
--- <summary>
--- //sets a tile at position x,y.
--- //For the moment only channel R is used
--- void setTile(const ccColor3B&amp; tile, const CCPoint&amp; position);
--- </summary>
function CCTileMapAtlas:setTile() end
--- <summary>
--- //returns a tile from position x,y.
--- //For the moment only channel R is used
--- //@js getTileAt
--- ccColor3B tileAt(const CCPoint&amp; position);
--- </summary>
--- <returns type="ccColor3B"></returns>
function CCTileMapAtlas:tileAt() end

CCTouch = class(CCObject)
--- <summary>
--- //returns the delta of 2 current touches locations in screen coordinates 
--- CCPoint getDelta() const;
--- </summary>
--- <returns type="CCPoint"></returns>
function CCTouch:getDelta() end
--- <summary>
--- //@js getId
--- int getID() const
--- </summary>
function CCTouch:getID() end
--- <summary>
--- //returns the current touch location in OpenGL coordinates 
--- CCPoint getLocation() const;
--- </summary>
--- <returns type="CCPoint"></returns>
function CCTouch:getLocation() end
--- <summary>
--- //returns the current touch location in screen coordinates 
--- CCPoint getLocationInView() const;
--- </summary>
--- <returns type="CCPoint"></returns>
function CCTouch:getLocationInView() end
--- <summary>
--- //returns the previous touch location in OpenGL coordinates 
--- CCPoint getPreviousLocation() const;
--- </summary>
--- <returns type="CCPoint"></returns>
function CCTouch:getPreviousLocation() end
--- <summary>
--- //returns the previous touch location in screen coordinates 
--- CCPoint getPreviousLocationInView() const;
--- </summary>
--- <returns type="CCPoint"></returns>
function CCTouch:getPreviousLocationInView() end
--- <summary>
--- void setTouchInfo(int id, float x, float y);
--- </summary>
function CCTouch:setTouchInfo() end

CCEvent = class(CCObject)

CCTouchDispatcher = class(CCObject)
--- <summary>
--- //Whether or not the events are going to be dispatched. Default: true 
--- bool isDispatchEvents(void);
--- </summary>
function CCTouchDispatcher:isDispatchEvents() end
--- <summary>
--- void setDispatchEvents(bool bDispatchEvents);
--- </summary>
function CCTouchDispatcher:setDispatchEvents() end

CCTransitionScene = class(CCScene)
--- <summary>
--- //creates a base transition with duration and incoming scene 
--- static CCTransitionScene * create(float t, CCScene *scene);
--- </summary>
--- <returns type="CCTransitionScene"></returns>
function CCTransitionScene:create() end

CCTransitionSceneOriented = class(CCScene)
--- <summary>
--- //creates a base transition with duration and incoming scene 
--- static CCTransitionSceneOriented * create(float t,CCScene* scene, tOrientation orientation);
--- </summary>
--- <returns type="CCTransitionSceneOriented"></returns>
function CCTransitionSceneOriented:create() end

CCTransitionRotoZoom = class(CCScene)
--- <summary>
--- static CCTransitionRotoZoom* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionRotoZoom"></returns>
function CCTransitionRotoZoom:create() end

CCTransitionJumpZoom = class(CCScene)
--- <summary>
--- static CCTransitionJumpZoom* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionJumpZoom"></returns>
function CCTransitionJumpZoom:create() end

CCTransitionMoveInL = class(CCScene)
--- <summary>
--- static CCTransitionMoveInL* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionMoveInL"></returns>
function CCTransitionMoveInL:create() end

CCTransitionMoveInR = class(CCScene)
--- <summary>
--- static CCTransitionMoveInR* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionMoveInR"></returns>
function CCTransitionMoveInR:create() end

CCTransitionMoveInT = class(CCScene)
--- <summary>
--- static CCTransitionMoveInT* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionMoveInT"></returns>
function CCTransitionMoveInT:create() end

CCTransitionMoveInB = class(CCScene)
--- <summary>
--- static CCTransitionMoveInB* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionMoveInB"></returns>
function CCTransitionMoveInB:create() end

CCTransitionSlideInL = class(CCScene)
--- <summary>
--- static CCTransitionSlideInL* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionSlideInL"></returns>
function CCTransitionSlideInL:create() end

CCTransitionSlideInR = class(CCScene)
--- <summary>
--- static CCTransitionSlideInR* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionSlideInR"></returns>
function CCTransitionSlideInR:create() end

CCTransitionSlideInB = class(CCScene)
--- <summary>
--- static CCTransitionSlideInB* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionSlideInB"></returns>
function CCTransitionSlideInB:create() end

CCTransitionSlideInT = class(CCScene)
--- <summary>
--- static CCTransitionSlideInT* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionSlideInT"></returns>
function CCTransitionSlideInT:create() end

CCTransitionShrinkGrow = class(CCScene)
--- <summary>
--- static	CCTransitionShrinkGrow* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionShrinkGrow"></returns>
function CCTransitionShrinkGrow:create() end

CCTransitionFlipX = class(CCScene)
--- <summary>
--- static CCTransitionFlipX* create(float t, CCScene* s, tOrientation o = kCCTransitionOrientationRightOver);
--- </summary>
--- <returns type="CCTransitionFlipX"></returns>
function CCTransitionFlipX:create() end

CCTransitionFlipY = class(CCScene)
--- <summary>
--- static CCTransitionFlipY* create(float t, CCScene* s, tOrientation o = kCCTransitionOrientationUpOver);
--- </summary>
--- <returns type="CCTransitionFlipY"></returns>
function CCTransitionFlipY:create() end

CCTransitionFlipAngular = class(CCScene)
--- <summary>
--- static CCTransitionFlipAngular* create(float t, CCScene* s, tOrientation o = kCCTransitionOrientationRightOver);
--- </summary>
--- <returns type="CCTransitionFlipAngular"></returns>
function CCTransitionFlipAngular:create() end

CCTransitionZoomFlipX = class(CCScene)
--- <summary>
--- static CCTransitionZoomFlipX* create(float t, CCScene* s, tOrientation o = kCCTransitionOrientationRightOver);
--- </summary>
--- <returns type="CCTransitionZoomFlipX"></returns>
function CCTransitionZoomFlipX:create() end

CCTransitionZoomFlipY = class(CCScene)
--- <summary>
--- static CCTransitionZoomFlipY* create(float t, CCScene* s, tOrientation o = kCCTransitionOrientationUpOver);
--- </summary>
--- <returns type="CCTransitionZoomFlipY"></returns>
function CCTransitionZoomFlipY:create() end

CCTransitionZoomFlipAngular = class(CCScene)
--- <summary>
--- static CCTransitionZoomFlipAngular* create(float t, CCScene* s, tOrientation o = kCCTransitionOrientationRightOver);
--- </summary>
--- <returns type="CCTransitionZoomFlipAngular"></returns>
function CCTransitionZoomFlipAngular:create() end

CCTransitionFade = class(CCScene)
--- <summary>
--- //creates the transition with a duration and with an RGB color
--- //Example: FadeTransition::create(2, scene, ccc3(255,0,0); // red color
--- static CCTransitionFade* create(float duration,CCScene* scene, const ccColor3B&amp; color);
--- </summary>
--- <returns type="CCTransitionFade"></returns>
function CCTransitionFade:create() end

CCTransitionCrossFade = class(CCScene)
--- <summary>
--- static CCTransitionCrossFade* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionCrossFade"></returns>
function CCTransitionCrossFade:create() end

CCTransitionTurnOffTiles = class(CCScene)
--- <summary>
--- static CCTransitionTurnOffTiles* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionTurnOffTiles"></returns>
function CCTransitionTurnOffTiles:create() end

CCTransitionSplitCols = class(CCScene)
--- <summary>
--- static CCTransitionSplitCols* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionSplitCols"></returns>
function CCTransitionSplitCols:create() end

CCTransitionSplitRows = class(CCScene)
--- <summary>
--- static CCTransitionSplitRows* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionSplitRows"></returns>
function CCTransitionSplitRows:create() end

CCTransitionFadeTR = class(CCScene)
--- <summary>
--- static CCTransitionFadeTR* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionFadeTR"></returns>
function CCTransitionFadeTR:create() end

CCTransitionFadeBL = class(CCScene)
--- <summary>
--- static CCTransitionFadeBL* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionFadeBL"></returns>
function CCTransitionFadeBL:create() end

CCTransitionFadeUp = class(CCScene)
--- <summary>
--- static CCTransitionFadeUp* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionFadeUp"></returns>
function CCTransitionFadeUp:create() end

CCTransitionFadeDown = class(CCScene)
--- <summary>
--- static  CCTransitionFadeDown* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionFadeDown"></returns>
function CCTransitionFadeDown:create() end

CCTransitionProgressRadialCCW = class(CCScene)
--- <summary>
--- static CCTransitionProgressRadialCCW* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionProgressRadialCCW"></returns>
function CCTransitionProgressRadialCCW:create() end

CCTransitionProgressRadialCW = class(CCScene)
--- <summary>
--- static CCTransitionProgressRadialCW* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionProgressRadialCW"></returns>
function CCTransitionProgressRadialCW:create() end

CCTransitionPageTurn = class(CCScene)
--- <summary>
--- CCActionInterval* actionWithSize(CCSize vector);
--- </summary>
--- <returns type="CCActionInterval"></returns>
function CCTransitionPageTurn:actionWithSize() end
--- <summary>
--- //Creates a base transition with duration and incoming scene.
--- //If back is true then the effect is reversed to appear as if the incoming 
--- //scene is being turned from left over the outgoing scene.
--- static CCTransitionPageTurn* create(float t,CCScene* scene,bool backwards);
--- </summary>
--- <returns type="CCTransitionPageTurn"></returns>
function CCTransitionPageTurn:create() end

CCTransitionProgress = class(CCTransitionScene)
--- <summary>
--- static CCTransitionProgress* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionProgress"></returns>
function CCTransitionProgress:create() end

CCTransitionProgressHorizontal = class(CCTransitionProgress)
--- <summary>
--- static CCTransitionProgressHorizontal* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionProgressHorizontal"></returns>
function CCTransitionProgressHorizontal:create() end

CCTransitionProgressVertical = class(CCTransitionProgress)
--- <summary>
--- static CCTransitionProgressVertical* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionProgressVertical"></returns>
function CCTransitionProgressVertical:create() end

CCTransitionProgressInOut = class(CCTransitionProgress)
--- <summary>
--- static CCTransitionProgressInOut* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionProgressInOut"></returns>
function CCTransitionProgressInOut:create() end

CCTransitionProgressOutIn = class(CCTransitionProgress)
--- <summary>
--- static CCTransitionProgressOutIn* create(float t, CCScene* scene);
--- </summary>
--- <returns type="CCTransitionProgressOutIn"></returns>
function CCTransitionProgressOutIn:create() end

CCTween = class(CCProcessBase)
--- <summary>
--- CCTween(void);
--- </summary>
function CCTween:new() end
function CCTween:new_local() end
--- <summary>
--- //Create with a CCBone
--- //@param bone the CCBone CCTween will bind to
--- static CCTween *create(CCBone *bone);
--- </summary>
--- <returns type="CCTween"></returns>
function CCTween:create() end
--- <summary>
--- CCArmatureAnimation *getAnimation() const;
--- </summary>
--- <returns type="CCArmatureAnimation"></returns>
function CCTween:getAnimation() end
--- <summary>
--- virtual void gotoAndPause(int frameIndex);
--- </summary>
function CCTween:gotoAndPause() end
--- <summary>
--- virtual void gotoAndPlay(int frameIndex);
--- </summary>
function CCTween:gotoAndPlay() end
--- <summary>
--- //Init with a CCBone
--- //@param bone the CCBone CCTween will bind to
--- virtual bool init(CCBone *bone);
--- </summary>
function CCTween:init() end
--- <summary>
--- //Start the Process
--- //@param  movementBoneData  the CCMovementBoneData include all CCFrameData
--- //@param  durationTo the number of frames changing to this animation needs.
--- //@param  durationTween  the number of frames this animation actual last.
--- //@param  loop   whether the animation is loop
--- //loop &lt; 0 : use the value from CCMovementData get from Action Editor
--- //loop = 0 : this animation is not loop
--- //loop > 0 : this animation is loop
--- //@param  tweenEasing    tween easing is used for calculate easing effect
--- //TWEEN_EASING_MAX : use the value from CCMovementData get from Action Editor
--- //-1 : fade out
--- //0  : line
--- //1  : fade in
--- //2  : fade in and out
--- virtual void play(CCMovementBoneData *movementBoneData, int durationTo, int durationTween, int loop, int tweenEasing);
--- </summary>
function CCTween:play() end
--- <summary>
--- void setAnimation(CCArmatureAnimation *animation);
--- </summary>
function CCTween:setAnimation() end
--- <summary>
--- virtual ~CCTween(void);
--- </summary>
function CCTween:delete() end

CCUserDefault = {}
--- <summary>
--- //@brief Save content to xml file
--- void flush();
--- </summary>
function CCUserDefault:flush() end
--- <summary>
--- //@brief Get bool value by key, if the key doesn't exist, a default value will return.
--- //You can set the default value, or it is false.
--- bool getBoolForKey(const char* pKey);
--- </summary>
function CCUserDefault:getBoolForKey() end
--- <summary>
--- //@brief Get double value by key, if the key doesn't exist, a default value will return.
--- //You can set the default value, or it is 0.0.
--- double getDoubleForKey(const char* pKey);
--- </summary>
function CCUserDefault:getDoubleForKey() end
--- <summary>
--- //@brief Get float value by key, if the key doesn't exist, a default value will return.
--- //You can set the default value, or it is 0.0f.
--- float getFloatForKey(const char* pKey);
--- </summary>
function CCUserDefault:getFloatForKey() end
--- <summary>
--- //@brief Get integer value by key, if the key doesn't exist, a default value will return.
--- //You can set the default value, or it is 0.
--- int getIntegerForKey(const char* pKey);
--- </summary>
function CCUserDefault:getIntegerForKey() end
--- <summary>
--- //@brief Get string value by key, if the key doesn't exist, a default value will return.
--- //You can set the default value, or it is "".
--- std::string getStringForKey(const char* pKey);
--- </summary>
--- <returns type="std::string"></returns>
function CCUserDefault:getStringForKey() end
--- <summary>
--- const static std::string&amp; getXMLFilePath();
--- </summary>
--- <returns type="std::string"></returns>
function CCUserDefault:getXMLFilePath() end
--- <summary>
--- static void purgeSharedUserDefault();
--- </summary>
function CCUserDefault:purgeSharedUserDefault() end
--- <summary>
--- //@brief Set bool value by key.
--- void setBoolForKey(const char* pKey, bool value);
--- </summary>
function CCUserDefault:setBoolForKey() end
--- <summary>
--- //@brief Set double value by key.
--- void setDoubleForKey(const char* pKey, double value);
--- </summary>
function CCUserDefault:setDoubleForKey() end
--- <summary>
--- //@brief Set float value by key.
--- void setFloatForKey(const char* pKey, float value);
--- </summary>
function CCUserDefault:setFloatForKey() end
--- <summary>
--- //@brief Set integer value by key.
--- void setIntegerForKey(const char* pKey, int value);
--- </summary>
function CCUserDefault:setIntegerForKey() end
--- <summary>
--- //@brief Set string value by key.
--- void setStringForKey(const char* pKey, const std::string &amp; value);
--- </summary>
function CCUserDefault:setStringForKey() end
--- <summary>
--- static CCUserDefault* sharedUserDefault();
--- </summary>
--- <returns type="CCUserDefault"></returns>
function CCUserDefault:sharedUserDefault() end

GUIReader = class(CCObject)
--- <summary>
--- //@js ctor
--- GUIReader();
--- </summary>
function GUIReader:new() end
function GUIReader:new_local() end
--- <summary>
--- const CCSize getFileDesignSize(const char* fileName) const;
--- </summary>
--- <returns type="CCSize"></returns>
function GUIReader:getFileDesignSize() end
--- <summary>
--- const std::string&amp; getFilePath() const;
--- </summary>
--- <returns type="std::string"></returns>
function GUIReader:getFilePath() end
--- <summary>
--- int getVersionInteger(const char* str);
--- </summary>
function GUIReader:getVersionInteger() end
--- <summary>
--- //@js pure
--- static void purge();
--- </summary>
function GUIReader:purge() end
--- <summary>
--- //@js getInstance
--- static GUIReader* shareReader();
--- </summary>
--- <returns type="GUIReader"></returns>
function GUIReader:shareReader() end
--- <summary>
--- void storeFileDesignSize(const char* fileName, const CCSize &amp;size);
--- </summary>
function GUIReader:storeFileDesignSize() end
--- <summary>
--- Widget* widgetFromJsonFile(const char* fileName);
--- </summary>
--- <returns type="Widget"></returns>
function GUIReader:widgetFromJsonFile() end

SceneReader = {}
--- <summary>
--- SceneReader(void);
--- </summary>
function SceneReader:new() end
function SceneReader:new_local() end
--- <summary>
--- CCNode* createNodeWithSceneFile(const char *pszFileName);
--- </summary>
--- <returns type="CCNode"></returns>
function SceneReader:createNodeWithSceneFile() end
--- <summary>
--- CCNode* getNodeByTag(int nTag);
--- </summary>
--- <returns type="CCNode"></returns>
function SceneReader:getNodeByTag() end
--- <summary>
--- void purge();
--- </summary>
function SceneReader:purge() end
--- <summary>
--- static const char* sceneReaderVersion();
--- </summary>
function SceneReader:sceneReaderVersion() end
--- <summary>
--- static SceneReader* sharedSceneReader();
--- </summary>
--- <returns type="SceneReader"></returns>
function SceneReader:sharedSceneReader() end
--- <summary>
--- virtual ~SceneReader(void);
--- </summary>
function SceneReader:delete() end

SimpleAudioEngine = {}
--- <summary>
--- //@brief The volume of the background music max value is 1.0,the min value is 0.0
--- //@js getMusicVolume
--- float getBackgroundMusicVolume();
--- </summary>
function SimpleAudioEngine:getBackgroundMusicVolume() end
--- <summary>
--- //@brief The volume of the effects max value is 1.0,the min value is 0.0
--- float getEffectsVolume();
--- </summary>
function SimpleAudioEngine:getEffectsVolume() end
--- <summary>
--- //@brief Whether the background music is playing
--- //@return If is playing return true,or return false
--- //@js isMusicPlaying
--- bool isBackgroundMusicPlaying();
--- </summary>
function SimpleAudioEngine:isBackgroundMusicPlaying() end
--- <summary>
--- //@brief Pause all playing sound effect
--- //@param nSoundId The return value of function playEffect
--- void pauseAllEffects();
--- </summary>
function SimpleAudioEngine:pauseAllEffects() end
--- <summary>
--- //@brief Pause playing background music
--- //@js pauseMusic
--- void pauseBackgroundMusic();
--- </summary>
function SimpleAudioEngine:pauseBackgroundMusic() end
--- <summary>
--- //@brief Pause playing sound effect
--- //@param nSoundId The return value of function playEffect
--- void pauseEffect(unsigned int nSoundId);
--- </summary>
function SimpleAudioEngine:pauseEffect() end
--- <summary>
--- //@brief Play background music
--- //@param pszFilePath The path of the background music file,or the FileName of T_SoundResInfo
--- //@param bLoop Whether the background music loop or not
--- //@js playMusic
--- void playBackgroundMusic(const char* pszFilePath, bool bLoop);
--- 
--- //@js playMusic
--- void playBackgroundMusic(const char* pszFilePath);
--- </summary>
function SimpleAudioEngine:playBackgroundMusic() end
--- <summary>
--- //@brief Play sound effect
--- //@param pszFilePath The path of the effect file,or the FileName of T_SoundResInfo
--- //@bLoop Whether to loop the effect playing, default value is false
--- unsigned int playEffect(const char* pszFilePath, bool bLoop);
--- </summary>
function SimpleAudioEngine:playEffect() end
--- <summary>
--- //@brief Preload background music
--- //@param pszFilePath The path of the background music file,or the FileName of T_SoundResInfo
--- //@js preloadMusic
--- void preloadBackgroundMusic(const char* pszFilePath);
--- </summary>
function SimpleAudioEngine:preloadBackgroundMusic() end
--- <summary>
--- //@brief          preload a compressed audio file
--- //@details        the compressed audio will be decode to wave, then write into an 
--- //internal buffer in SimpleaudioEngine
--- void preloadEffect(const char* pszFilePath);
--- </summary>
function SimpleAudioEngine:preloadEffect() end
--- <summary>
--- //@brief Resume all playing sound effect
--- //@param nSoundId The return value of function playEffect
--- void resumeAllEffects();
--- </summary>
function SimpleAudioEngine:resumeAllEffects() end
--- <summary>
--- //@brief Resume playing background music
--- //@js resumeMusic
--- void resumeBackgroundMusic();
--- </summary>
function SimpleAudioEngine:resumeBackgroundMusic() end
--- <summary>
--- //@brief Resume playing sound effect
--- //@param nSoundId The return value of function playEffect
--- void resumeEffect(unsigned int nSoundId);
--- </summary>
function SimpleAudioEngine:resumeEffect() end
--- <summary>
--- //@brief Rewind playing background music
--- //@js rewindMusic
--- void rewindBackgroundMusic();
--- </summary>
function SimpleAudioEngine:rewindBackgroundMusic() end
--- <summary>
--- //@brief set the volume of background music
--- //@param volume must be in 0.0~1.0
--- //@js setMusicVolume
--- void setBackgroundMusicVolume(float volume);
--- </summary>
function SimpleAudioEngine:setBackgroundMusicVolume() end
--- <summary>
--- //@brief set the volume of sound effecs
--- //@param volume must be in 0.0~1.0
--- void setEffectsVolume(float volume);
--- </summary>
function SimpleAudioEngine:setEffectsVolume() end
--- <summary>
--- //@brief Get the shared Engine object,it will new one when first time be called
--- //@js getInstance
--- static SimpleAudioEngine* sharedEngine();
--- </summary>
--- <returns type="SimpleAudioEngine"></returns>
function SimpleAudioEngine:sharedEngine() end
--- <summary>
--- //@brief Stop all playing sound effects
--- void stopAllEffects();
--- </summary>
function SimpleAudioEngine:stopAllEffects() end
--- <summary>
--- //@brief Stop playing background music
--- //@param bReleaseData If release the background music data or not.As default value is false
--- //@js stopMusic
--- void stopBackgroundMusic(bool bReleaseData);
--- 
--- //@js stopMusic
--- void stopBackgroundMusic();
--- </summary>
function SimpleAudioEngine:stopBackgroundMusic() end
--- <summary>
--- //@brief Stop playing sound effect
--- //@param nSoundId The return value of function playEffect
--- void stopEffect(unsigned int nSoundId);
--- </summary>
function SimpleAudioEngine:stopEffect() end
--- <summary>
--- //@brief          unload the preloaded effect from internal buffer
--- //@param[in]        pszFilePath        The path of the effect file,or the FileName of T_SoundResInfo
--- void unloadEffect(const char* pszFilePath);
--- </summary>
function SimpleAudioEngine:unloadEffect() end
--- <summary>
--- //@js willPlayMusic
--- bool willPlayBackgroundMusic();
--- </summary>
function SimpleAudioEngine:willPlayBackgroundMusic() end

Button = class(Widget)
--- <summary>
--- //Default constructor
--- Button();
--- </summary>
function Button:new() end
function Button:new_local() end
--- <summary>
--- //Allocates and initializes.
--- static Button* create();
--- </summary>
--- <returns type="Button"></returns>
function Button:create() end
--- <summary>
--- const CCRect&amp; getCapInsetDisabledRenderer();
--- </summary>
--- <returns type="CCRect"></returns>
function Button:getCapInsetDisabledRenderer() end
--- <summary>
--- const CCRect&amp; getCapInsetNormalRenderer();
--- </summary>
--- <returns type="CCRect"></returns>
function Button:getCapInsetNormalRenderer() end
--- <summary>
--- const CCRect&amp; getCapInsetPressedRenderer();
--- </summary>
--- <returns type="CCRect"></returns>
function Button:getCapInsetPressedRenderer() end
--- <summary>
--- virtual const CCSize&amp; getContentSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function Button:getContentSize() end
--- <summary>
--- //Returns the "class name" of widget.
--- virtual std::string getDescription() const;
--- </summary>
--- <returns type="std::string"></returns>
function Button:getDescription() end
--- <summary>
--- const ccColor3B&amp; getTitleColor() const;
--- </summary>
--- <returns type="ccColor3B"></returns>
function Button:getTitleColor() end
--- <summary>
--- const char* getTitleFontName() const;
--- </summary>
function Button:getTitleFontName() end
--- <summary>
--- float getTitleFontSize() const;
--- </summary>
function Button:getTitleFontSize() end
--- <summary>
--- const char* getTitleText() const;
--- </summary>
function Button:getTitleText() end
--- <summary>
--- virtual CCNode* getVirtualRenderer();
--- </summary>
--- <returns type="CCNode"></returns>
function Button:getVirtualRenderer() end
--- <summary>
--- virtual void ignoreContentAdaptWithSize(bool ignore);
--- </summary>
function Button:ignoreContentAdaptWithSize() end
--- <summary>
--- bool isScale9Enabled();
--- </summary>
function Button:isScale9Enabled() end
--- <summary>
--- //Load dark state texture for button.
--- //@param disabled    dark state texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadTextureDisabled(const char* disabled, TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function Button:loadTextureDisabled() end
--- <summary>
--- //Load normal state texture for button.
--- //@param normal    normal state texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadTextureNormal(const char* normal, TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function Button:loadTextureNormal() end
--- <summary>
--- //Load selected state texture for button.
--- //@param selected    selected state texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadTexturePressed(const char* selected, TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function Button:loadTexturePressed() end
--- <summary>
--- //Load textures for button.
--- //@param normal    normal state texture.
--- //@param selected    selected state texture.
--- //@param disabled    dark state texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadTextures(const char* normal,const char* selected,const char* disabled,TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function Button:loadTextures() end
--- <summary>
--- virtual void setAnchorPoint(const CCPoint &amp;pt);
--- </summary>
function Button:setAnchorPoint() end
--- <summary>
--- //Sets capinsets for button, if button is using scale9 renderer.
--- //@param capInsets    capinsets for button
--- void setCapInsets(const CCRect &amp;capInsets);
--- </summary>
function Button:setCapInsets() end
--- <summary>
--- //Sets capinsets for button, if button is using scale9 renderer.
--- //@param capInsets    capinsets for button
--- void setCapInsetsDisabledRenderer(const CCRect &amp;capInsets);
--- </summary>
function Button:setCapInsetsDisabledRenderer() end
--- <summary>
--- //Sets capinsets for button, if button is using scale9 renderer.
--- //@param capInsets    capinsets for button
--- void setCapInsetsNormalRenderer(const CCRect &amp;capInsets);
--- </summary>
function Button:setCapInsetsNormalRenderer() end
--- <summary>
--- //Sets capinsets for button, if button is using scale9 renderer.
--- //@param capInsets    capinsets for button
--- void setCapInsetsPressedRenderer(const CCRect &amp;capInsets);
--- </summary>
function Button:setCapInsetsPressedRenderer() end
--- <summary>
--- //Changes if button can be clicked zoom effect.
--- //@param true that can be clicked zoom effect, false otherwise.
--- void setPressedActionEnabled(bool enabled);
--- </summary>
function Button:setPressedActionEnabled() end
--- <summary>
--- //Sets if button is using scale9 renderer.
--- //@param true that using scale9 renderer, false otherwise.
--- virtual void setScale9Enabled(bool able);
--- </summary>
function Button:setScale9Enabled() end
--- <summary>
--- void setTitleColor(const ccColor3B&amp; color);
--- </summary>
function Button:setTitleColor() end
--- <summary>
--- void setTitleFontName(const char* fontName);
--- </summary>
function Button:setTitleFontName() end
--- <summary>
--- void setTitleFontSize(float size);
--- </summary>
function Button:setTitleFontSize() end
--- <summary>
--- void setTitleText(const std::string&amp; text);
--- </summary>
function Button:setTitleText() end
--- <summary>
--- //Default destructor
--- virtual ~Button();
--- </summary>
function Button:delete() end

CheckBox = class(Widget)
--- <summary>
--- //Default constructor
--- CheckBox();
--- </summary>
function CheckBox:new() end
function CheckBox:new_local() end
--- <summary>
--- //Allocates and initializes.
--- static CheckBox* create();
--- </summary>
--- <returns type="CheckBox"></returns>
function CheckBox:create() end
--- <summary>
--- virtual const CCSize&amp; getContentSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function CheckBox:getContentSize() end
--- <summary>
--- //Returns the "class name" of widget.
--- virtual std::string getDescription() const;
--- </summary>
--- <returns type="std::string"></returns>
function CheckBox:getDescription() end
--- <summary>
--- //Gets selcted state of checkbox.
--- //@return selected    true that checkbox is selected, false otherwise.
--- bool getSelectedState();
--- </summary>
function CheckBox:getSelectedState() end
--- <summary>
--- virtual CCNode* getVirtualRenderer();
--- </summary>
--- <returns type="CCNode"></returns>
function CheckBox:getVirtualRenderer() end
--- <summary>
--- //Load backGround texture for checkbox.
--- //@param backGround    backGround texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadTextureBackGround(const char* backGround,TextureResType type = UI_TEX_TYPE_LOCAL);
--- </summary>
function CheckBox:loadTextureBackGround() end
--- <summary>
--- //Load backGroundDisabled texture for checkbox.
--- //@param backGroundDisabled    backGroundDisabled texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadTextureBackGroundDisabled(const char* backGroundDisabled,TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function CheckBox:loadTextureBackGroundDisabled() end
--- <summary>
--- //Load backGroundSelected texture for checkbox.
--- //@param backGroundSelected     backGround selected state texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadTextureBackGroundSelected(const char* backGroundSelected,TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function CheckBox:loadTextureBackGroundSelected() end
--- <summary>
--- //Load cross texture for checkbox.
--- //@param cross    cross texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadTextureFrontCross(const char* cross,TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function CheckBox:loadTextureFrontCross() end
--- <summary>
--- //Load frontCrossDisabled texture for checkbox.
--- //@param frontCrossDisabled    frontCrossDisabled texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadTextureFrontCrossDisabled(const char* frontCrossDisabled,TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function CheckBox:loadTextureFrontCrossDisabled() end
--- <summary>
--- //Load textures for checkbox.
--- //@param backGround    backGround texture.
--- //@param backGroundSelected    backGround selected state texture.
--- //@param cross    cross texture.
--- //@param frontCrossDisabled    cross dark state texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadTextures(const char* backGround,const char* backGroundSelected,const char* cross,const char* backGroundDisabled,const char* frontCrossDisabled,TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function CheckBox:loadTextures() end
--- <summary>
--- virtual void onTouchEnded(CCTouch *touch, CCEvent *unused_event);
--- </summary>
function CheckBox:onTouchEnded() end
--- <summary>
--- virtual void setAnchorPoint(const CCPoint &amp;pt);
--- </summary>
function CheckBox:setAnchorPoint() end
--- <summary>
--- //Sets selcted state for checkbox.
--- //@param selected    true that checkbox is selected, false otherwise.
--- void setSelectedState(bool selected);
--- </summary>
function CheckBox:setSelectedState() end
--- <summary>
--- //Default destructor
--- virtual ~CheckBox();
--- </summary>
function CheckBox:delete() end

UIHelper = {}
--- <summary>
--- static Widget* seekActionWidgetByActionTag(Widget* root, int tag);
--- </summary>
--- <returns type="Widget"></returns>
function UIHelper:seekActionWidgetByActionTag() end
--- <summary>
--- //Finds a widget whose name equals to param name from root widget.
--- //@param root      widget which will be seeked.
--- //@name             name value.
--- //@return finded result.
--- static Widget* seekWidgetByName(Widget* root, const char* name);
--- </summary>
--- <returns type="Widget"></returns>
function UIHelper:seekWidgetByName() end
--- <summary>
--- //Finds a widget whose name equals to param name from root widget.
--- //RelativeLayout will call this method to find the widget witch is needed.
--- //@param root      widget which will be seeked.
--- //@name             name value.
--- //@return finded result.
--- static Widget* seekWidgetByRelativeName(Widget* root, const char* name);
--- </summary>
--- <returns type="Widget"></returns>
function UIHelper:seekWidgetByRelativeName() end
--- <summary>
--- //Finds a widget whose tag equals to param tag from root widget.
--- //@param root      widget which will be seeked.
--- //@tag             tag value.
--- //@return finded result.
--- static Widget* seekWidgetByTag(Widget* root, int tag);
--- </summary>
--- <returns type="Widget"></returns>
function UIHelper:seekWidgetByTag() end

ImageView = class(Widget)
--- <summary>
--- //Default constructor
--- ImageView();
--- </summary>
function ImageView:new() end
function ImageView:new_local() end
--- <summary>
--- //Allocates and initializes.
--- static ImageView* create();
--- </summary>
--- <returns type="ImageView"></returns>
function ImageView:create() end
--- <summary>
--- virtual const CCSize&amp; getContentSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function ImageView:getContentSize() end
--- <summary>
--- //Returns the "class name" of widget.
--- virtual std::string getDescription() const;
--- </summary>
--- <returns type="std::string"></returns>
function ImageView:getDescription() end
--- <summary>
--- virtual CCNode* getVirtualRenderer();
--- </summary>
--- <returns type="CCNode"></returns>
function ImageView:getVirtualRenderer() end
--- <summary>
--- virtual void ignoreContentAdaptWithSize(bool ignore);
--- </summary>
function ImageView:ignoreContentAdaptWithSize() end
--- <summary>
--- virtual bool isFlipX();
--- </summary>
function ImageView:isFlipX() end
--- <summary>
--- virtual bool isFlipY();
--- </summary>
function ImageView:isFlipY() end
--- <summary>
--- //Load texture for imageview.
--- //@param fileName   file name of texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadTexture(const char* fileName,TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function ImageView:loadTexture() end
--- <summary>
--- virtual void setAnchorPoint(const CCPoint &amp;pt);
--- </summary>
function ImageView:setAnchorPoint() end
--- <summary>
--- //Sets capinsets for imageview, if imageview is using scale9 renderer.
--- //@param capInsets    capinsets for imageview
--- void setCapInsets(const CCRect &amp;capInsets);
--- </summary>
function ImageView:setCapInsets() end
--- <summary>
--- virtual void setFlipX(bool flipX);
--- </summary>
function ImageView:setFlipX() end
--- <summary>
--- virtual void setFlipY(bool flipY);
--- </summary>
function ImageView:setFlipY() end
--- <summary>
--- //Sets if imageview is using scale9 renderer.
--- //@param true that using scale9 renderer, false otherwise.
--- void setScale9Enabled(bool able);
--- </summary>
function ImageView:setScale9Enabled() end
--- <summary>
--- //Updates the texture rect of the ImageView in points.
--- //It will call setTextureRect:rotated:untrimmedSize with rotated = NO, and utrimmedSize = rect.size.
--- void setTextureRect(const CCRect&amp; rect);
--- </summary>
function ImageView:setTextureRect() end
--- <summary>
--- //Default destructor
--- virtual ~ImageView();
--- </summary>
function ImageView:delete() end

Label = class(Widget)
--- <summary>
--- //Default constructor
--- Label();
--- </summary>
function Label:new() end
function Label:new_local() end
--- <summary>
--- //Allocates and initializes.
--- static Label* create();
--- </summary>
--- <returns type="Label"></returns>
function Label:create() end
--- <summary>
--- virtual const CCSize&amp; getContentSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function Label:getContentSize() end
--- <summary>
--- //Returns the "class name" of widget.
--- virtual std::string getDescription() const;
--- </summary>
--- <returns type="std::string"></returns>
function Label:getDescription() end
--- <summary>
--- const char* getFontName();
--- </summary>
function Label:getFontName() end
--- <summary>
--- int getFontSize();
--- </summary>
function Label:getFontSize() end
--- <summary>
--- //Gets the string length of label.
--- //@return  string length.
--- int getStringLength();
--- </summary>
function Label:getStringLength() end
--- <summary>
--- //Gets the string value of label.
--- //@return text  string value.
--- const char* getStringValue();
--- </summary>
function Label:getStringValue() end
--- <summary>
--- CCSize getTextAreaSize();
--- </summary>
--- <returns type="CCSize"></returns>
function Label:getTextAreaSize() end
--- <summary>
--- CCTextAlignment getTextHorizontalAlignment();
--- </summary>
--- <returns type="CCTextAlignment"></returns>
function Label:getTextHorizontalAlignment() end
--- <summary>
--- CCVerticalTextAlignment getTextVerticalAlignment();
--- </summary>
--- <returns type="CCVerticalTextAlignment"></returns>
function Label:getTextVerticalAlignment() end
--- <summary>
--- virtual CCNode* getVirtualRenderer();
--- </summary>
--- <returns type="CCNode"></returns>
function Label:getVirtualRenderer() end
--- <summary>
--- //Gets the touch scale enabled of label.
--- //@return  touch scale enabled of label.
--- bool isTouchScaleChangeEnabled();
--- </summary>
function Label:isTouchScaleChangeEnabled() end
--- <summary>
--- virtual void setAnchorPoint(const CCPoint &amp;pt);
--- </summary>
function Label:setAnchorPoint() end
--- <summary>
--- //Sets the font name of label.
--- //@param  font name.
--- void setFontName(const std::string&amp; name);
--- </summary>
function Label:setFontName() end
--- <summary>
--- //Sets the font size of label.
--- //@param  font size.
--- void setFontSize(int size);
--- </summary>
function Label:setFontSize() end
--- <summary>
--- //Changes the string value of label.
--- //@param text  string value.
--- void setText(const std::string&amp; text);
--- </summary>
function Label:setText() end
--- <summary>
--- void setTextAreaSize(const CCSize &amp;size);
--- </summary>
function Label:setTextAreaSize() end
--- <summary>
--- void setTextHorizontalAlignment(CCTextAlignment alignment);
--- </summary>
function Label:setTextHorizontalAlignment() end
--- <summary>
--- void setTextVerticalAlignment(CCVerticalTextAlignment alignment);
--- </summary>
function Label:setTextVerticalAlignment() end
--- <summary>
--- //Sets the touch scale enabled of label.
--- //@param  touch scale enabled of label.
--- void setTouchScaleChangeEnabled(bool enabled);
--- </summary>
function Label:setTouchScaleChangeEnabled() end
--- <summary>
--- //Default destructor
--- virtual ~Label();
--- </summary>
function Label:delete() end

LabelAtlas = class(Widget)
--- <summary>
--- //Default constructor
--- LabelAtlas();
--- </summary>
function LabelAtlas:new() end
function LabelAtlas:new_local() end
--- <summary>
--- //Allocates and initializes.
--- static LabelAtlas* create();
--- </summary>
--- <returns type="LabelAtlas"></returns>
function LabelAtlas:create() end
--- <summary>
--- virtual const CCSize&amp; getContentSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function LabelAtlas:getContentSize() end
--- <summary>
--- //Returns the "class name" of widget.
--- virtual std::string getDescription() const;
--- </summary>
--- <returns type="std::string"></returns>
function LabelAtlas:getDescription() end
--- <summary>
--- const char* getStringValue() const;
--- </summary>
function LabelAtlas:getStringValue() end
--- <summary>
--- virtual CCNode* getVirtualRenderer();
--- </summary>
--- <returns type="CCNode"></returns>
function LabelAtlas:getVirtualRenderer() end
--- <summary>
--- virtual void setAnchorPoint(const CCPoint &amp;pt);
--- </summary>
function LabelAtlas:setAnchorPoint() end
--- <summary>
--- //initializes the LabelAtlas with a string, a char map file(the atlas), the width and height of each element and the starting char of the atlas 
--- void setProperty(const std::string&amp; stringValue,const std::string&amp; charMapFile, int itemWidth, int itemHeight, const std::string&amp; startCharMap);
--- </summary>
function LabelAtlas:setProperty() end
--- <summary>
--- void setStringValue(const std::string&amp; value);
--- </summary>
function LabelAtlas:setStringValue() end
--- <summary>
--- //Default destructor
--- virtual ~LabelAtlas();
--- </summary>
function LabelAtlas:delete() end

LabelBMFont = class(Widget)
--- <summary>
--- //Default constructor
--- LabelBMFont();
--- </summary>
function LabelBMFont:new() end
function LabelBMFont:new_local() end
--- <summary>
--- //Allocates and initializes.
--- static LabelBMFont* create();
--- </summary>
--- <returns type="LabelBMFont"></returns>
function LabelBMFont:create() end
--- <summary>
--- virtual const CCSize&amp; getContentSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function LabelBMFont:getContentSize() end
--- <summary>
--- //Returns the "class name" of widget.
--- virtual std::string getDescription() const;
--- </summary>
--- <returns type="std::string"></returns>
function LabelBMFont:getDescription() end
--- <summary>
--- //get string value for labelbmfont
--- const char* getStringValue();
--- </summary>
function LabelBMFont:getStringValue() end
--- <summary>
--- virtual CCNode* getVirtualRenderer();
--- </summary>
--- <returns type="CCNode"></returns>
function LabelBMFont:getVirtualRenderer() end
--- <summary>
--- virtual void setAnchorPoint(const CCPoint &amp;pt);
--- </summary>
function LabelBMFont:setAnchorPoint() end
--- <summary>
--- //init a bitmap font atlas with an initial string and the FNT file 
--- void setFntFile(const char* fileName);
--- </summary>
function LabelBMFont:setFntFile() end
--- <summary>
--- //set string value for labelbmfont
--- void setText(const char* value);
--- </summary>
function LabelBMFont:setText() end
--- <summary>
--- //Default destructor
--- virtual ~LabelBMFont();
--- </summary>
function LabelBMFont:delete() end

Layout = class(Widget)
--- <summary>
--- //Default constructor
--- Layout();
--- </summary>
function Layout:new() end
function Layout:new_local() end
--- <summary>
--- //Adds a child to the container with a z-order
--- //If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.
--- //@param child     A child node
--- //@param zOrder    Z order for drawing priority. Please refer to setZOrder(int)
--- virtual void addChild(CCNode * child, int zOrder);
--- 
--- //Adds a child to the container with z order and tag
--- //If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.
--- //@param child     A child node
--- //@param zOrder    Z order for drawing priority. Please refer to setZOrder(int)
--- //@param tag       A interger to identify the node easily. Please refer to setTag(int)
--- virtual void addChild(CCNode* child, int zOrder, int tag);
--- </summary>
function Layout:addChild() end
--- <summary>
--- //Allocates and initializes a layout.
--- static Layout* create();
--- </summary>
--- <returns type="Layout"></returns>
function Layout:create() end
--- <summary>
--- const ccColor3B&amp; getBackGroundColor();
--- </summary>
--- <returns type="ccColor3B"></returns>
function Layout:getBackGroundColor() end
--- <summary>
--- GLubyte getBackGroundColorOpacity();
--- </summary>
--- <returns type="GLubyte"></returns>
function Layout:getBackGroundColorOpacity() end
--- <summary>
--- LayoutBackGroundColorType getBackGroundColorType();
--- </summary>
--- <returns type="LayoutBackGroundColorType"></returns>
function Layout:getBackGroundColorType() end
--- <summary>
--- const CCPoint&amp; getBackGroundColorVector();
--- </summary>
--- <returns type="CCPoint"></returns>
function Layout:getBackGroundColorVector() end
--- <summary>
--- const ccColor3B&amp; getBackGroundEndColor();
--- </summary>
--- <returns type="ccColor3B"></returns>
function Layout:getBackGroundEndColor() end
--- <summary>
--- const CCRect&amp; getBackGroundImageCapInsets();
--- </summary>
--- <returns type="CCRect"></returns>
function Layout:getBackGroundImageCapInsets() end
--- <summary>
--- const ccColor3B&amp; getBackGroundImageColor();
--- </summary>
--- <returns type="ccColor3B"></returns>
function Layout:getBackGroundImageColor() end
--- <summary>
--- GLubyte getBackGroundImageOpacity();
--- </summary>
--- <returns type="GLubyte"></returns>
function Layout:getBackGroundImageOpacity() end
--- <summary>
--- //Gets background image texture size.
--- //@return background image texture size.
--- const CCSize&amp; getBackGroundImageTextureSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function Layout:getBackGroundImageTextureSize() end
--- <summary>
--- const ccColor3B&amp; getBackGroundStartColor();
--- </summary>
--- <returns type="ccColor3B"></returns>
function Layout:getBackGroundStartColor() end
--- <summary>
--- LayoutClippingType getClippingType();
--- </summary>
--- <returns type="LayoutClippingType"></returns>
function Layout:getClippingType() end
--- <summary>
--- //Returns the "class name" of widget.
--- virtual std::string getDescription() const;
--- </summary>
--- <returns type="std::string"></returns>
function Layout:getDescription() end
--- <summary>
--- //Gets LayoutType.
--- //@see LayoutType
--- //@return LayoutType
--- virtual LayoutType getLayoutType() const;
--- </summary>
--- <returns type="LayoutType"></returns>
function Layout:getLayoutType() end
--- <summary>
--- virtual bool hitTest(const CCPoint &amp;pt);
--- </summary>
function Layout:hitTest() end
--- <summary>
--- bool isBackGroundImageScale9Enabled();
--- </summary>
function Layout:isBackGroundImageScale9Enabled() end
--- <summary>
--- //Gets if layout is clipping enabled.
--- //@return if layout is clipping enabled.
--- virtual bool isClippingEnabled();
--- </summary>
function Layout:isClippingEnabled() end
--- <summary>
--- virtual void onEnter();
--- </summary>
function Layout:onEnter() end
--- <summary>
--- virtual void onExit();
--- </summary>
function Layout:onExit() end
--- <summary>
--- virtual void removeAllChildren();
--- </summary>
function Layout:removeAllChildren() end
--- <summary>
--- virtual void removeAllChildrenWithCleanup(bool cleanup);
--- </summary>
function Layout:removeAllChildrenWithCleanup() end
--- <summary>
--- //Remove the background image of layout.
--- void removeBackGroundImage();
--- </summary>
function Layout:removeBackGroundImage() end
--- <summary>
--- virtual void removeChild(CCNode* child);
--- virtual void removeChild(CCNode* widget, bool cleanup);
--- </summary>
function Layout:removeChild() end
--- <summary>
--- void requestDoLayout();
--- </summary>
function Layout:requestDoLayout() end
--- <summary>
--- //Sets background color for layout, if color type is LAYOUT_COLOR_SOLID
--- //@param color
--- void setBackGroundColor(const ccColor3B &amp;color);
--- 
--- //Sets background color for layout, if color type is LAYOUT_COLOR_GRADIENT
--- //@param start color
--- //@param end color
--- void setBackGroundColor(const ccColor3B &amp;startColor, const ccColor3B &amp;endColor);
--- </summary>
function Layout:setBackGroundColor() end
--- <summary>
--- //Sets background opacity layout.
--- //@param opacity
--- void setBackGroundColorOpacity(GLubyte opacity);
--- </summary>
function Layout:setBackGroundColorOpacity() end
--- <summary>
--- //Sets Color Type for layout.
--- //@param type   @see LayoutBackGroundColorType.
--- void setBackGroundColorType(LayoutBackGroundColorType type);
--- </summary>
function Layout:setBackGroundColorType() end
--- <summary>
--- //Sets background color vector for layout, if color type is LAYOUT_COLOR_GRADIENT
--- //@param vector
--- void setBackGroundColorVector(const CCPoint &amp;vector);
--- </summary>
function Layout:setBackGroundColorVector() end
--- <summary>
--- //Sets a background image for layout
--- //@param fileName image file path.
--- //@param texType @see TextureResType. UI_TEX_TYPE_LOCAL means local file, UI_TEX_TYPE_PLIST means sprite frame.
--- void setBackGroundImage(const char* fileName,TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function Layout:setBackGroundImage() end
--- <summary>
--- //Sets a background image capinsets for layout, if the background image is a scale9 render.
--- //@param capinsets of background image.
--- void setBackGroundImageCapInsets(const CCRect&amp; capInsets);
--- </summary>
function Layout:setBackGroundImageCapInsets() end
--- <summary>
--- void setBackGroundImageColor(const ccColor3B&amp; color);
--- </summary>
function Layout:setBackGroundImageColor() end
--- <summary>
--- void setBackGroundImageOpacity(GLubyte opacity);
--- </summary>
function Layout:setBackGroundImageOpacity() end
--- <summary>
--- //Sets background iamge use scale9 renderer.
--- //@param enabled   true that use scale9 renderer, false otherwise.
--- void setBackGroundImageScale9Enabled(bool enabled);
--- </summary>
function Layout:setBackGroundImageScale9Enabled() end
--- <summary>
--- //Changes if layout can clip it's content and child.
--- //If you really need this, please enable it. But it would reduce the rendering efficiency. 
--- //@param clipping enabled.
--- virtual void setClippingEnabled(bool enabled);
--- </summary>
function Layout:setClippingEnabled() end
--- <summary>
--- void setClippingType(LayoutClippingType type);
--- </summary>
function Layout:setClippingType() end
--- <summary>
--- //Sets LayoutType.
--- //@see LayoutType
--- //@param LayoutType
--- virtual void setLayoutType(LayoutType type);
--- </summary>
function Layout:setLayoutType() end
--- <summary>
--- virtual void sortAllChildren();
--- </summary>
function Layout:sortAllChildren() end
--- <summary>
--- virtual void visit();
--- </summary>
function Layout:visit() end
--- <summary>
--- //Default destructor
--- virtual ~Layout();
--- </summary>
function Layout:delete() end

LayoutParameter = class(CCObject)
--- <summary>
--- //Default constructor
--- LayoutParameter() : _margin(Margin());
--- </summary>
function LayoutParameter:new() end
function LayoutParameter:new_local() end
--- <summary>
--- //Allocates and initializes.
--- //@return A initialized LayoutParameter which is marked as "autorelease".
--- static LayoutParameter* create();
--- </summary>
--- <returns type="LayoutParameter"></returns>
function LayoutParameter:create() end
--- <summary>
--- //Gets LayoutParameterType of LayoutParameter.
--- //@see LayoutParameterType
--- //@return LayoutParameterType
--- LayoutParameterType getLayoutType() const;
--- </summary>
--- <returns type="LayoutParameterType"></returns>
function LayoutParameter:getLayoutType() end
--- <summary>
--- //Default destructor
--- virtual ~LayoutParameter();
--- </summary>
function LayoutParameter:delete() end

LinearLayoutParameter = class(LayoutParameter)
--- <summary>
--- //Default constructor
--- LinearLayoutParameter() : _linearGravity(LINEAR_GRAVITY_NONE);
--- </summary>
function LinearLayoutParameter:new() end
function LinearLayoutParameter:new_local() end
--- <summary>
--- //Allocates and initializes.
--- //@return A initialized LayoutParameter which is marked as "autorelease".
--- static LinearLayoutParameter* create();
--- </summary>
--- <returns type="LinearLayoutParameter"></returns>
function LinearLayoutParameter:create() end
--- <summary>
--- //Gets LinearGravity parameter for LayoutParameter.
--- //@see LinearGravity
--- //@return LinearGravity
--- LinearGravity getGravity() const;
--- </summary>
--- <returns type="LinearGravity"></returns>
function LinearLayoutParameter:getGravity() end
--- <summary>
--- //Sets LinearGravity parameter for LayoutParameter.
--- //@see LinearGravity
--- //@param LinearGravity
--- void setGravity(LinearGravity gravity);
--- </summary>
function LinearLayoutParameter:setGravity() end
--- <summary>
--- //Default destructor
--- virtual ~LinearLayoutParameter();
--- </summary>
function LinearLayoutParameter:delete() end

ListView = class(ScrollView)
--- <summary>
--- //Default constructor
--- ListView();
--- </summary>
function ListView:new() end
function ListView:new_local() end
--- <summary>
--- //Allocates and initializes.
--- static ListView* create();
--- </summary>
--- <returns type="ListView"></returns>
function ListView:create() end
--- <summary>
--- int getCurSelectedIndex() const;
--- </summary>
function ListView:getCurSelectedIndex() end
--- <summary>
--- virtual std::string getDescription() const;
--- </summary>
--- <returns type="std::string"></returns>
function ListView:getDescription() end
--- <summary>
--- //Returns the index of item.
--- //@param item  the item which need to be checked.
--- //@return the index of item.
--- unsigned int getIndex(Widget* item) const;
--- </summary>
function ListView:getIndex() end
--- <summary>
--- //Returns a item whose index is same as the parameter.
--- //@param index of item.
--- //@return the item widget.
--- Widget* getItem(unsigned int index);
--- </summary>
--- <returns type="Widget"></returns>
function ListView:getItem() end
--- <summary>
--- //Returns the item container.
--- CCArray* getItems();
--- </summary>
--- <returns type="CCArray"></returns>
function ListView:getItems() end
--- <summary>
--- //Insert custom item into listview.
--- void insertCustomItem(Widget* item, int index);
--- </summary>
function ListView:insertCustomItem() end
--- <summary>
--- //Insert a default item(create by a cloned model) into listview.
--- void insertDefaultItem(int index);
--- </summary>
function ListView:insertDefaultItem() end
--- <summary>
--- //Push back custom item into listview.
--- void pushBackCustomItem(Widget* item);
--- </summary>
function ListView:pushBackCustomItem() end
--- <summary>
--- //Push back a default item(create by a cloned model) into listview.
--- void pushBackDefaultItem();
--- </summary>
function ListView:pushBackDefaultItem() end
--- <summary>
--- void refreshView();
--- </summary>
function ListView:refreshView() end
--- <summary>
--- void removeAllItems();
--- </summary>
function ListView:removeAllItems() end
--- <summary>
--- //Removes a item whose index is same as the parameter.
--- //@param index of item.
--- void removeItem(int index);
--- </summary>
function ListView:removeItem() end
--- <summary>
--- //Removes the last item of listview.
--- void removeLastItem();
--- </summary>
function ListView:removeLastItem() end
--- <summary>
--- void requestRefreshView();
--- </summary>
function ListView:requestRefreshView() end
--- <summary>
--- //Changes scroll direction of scrollview.
--- //@see SCROLLVIEW_DIR      SCROLLVIEW_DIR_VERTICAL means vertical scroll, SCROLLVIEW_DIR_HORIZONTAL means horizontal scroll
--- //@param SCROLLVIEW_DIR
--- virtual void setDirection(SCROLLVIEW_DIR dir);
--- </summary>
function ListView:setDirection() end
--- <summary>
--- //Changes the gravity of listview.
--- //@see ListViewGravity
--- void setGravity(ListViewGravity gravity);
--- </summary>
function ListView:setGravity() end
--- <summary>
--- //Sets a item model for listview
--- //A model will be cloned for adding default item.
--- //@param model  item model for listview
--- void setItemModel(Widget* model);
--- </summary>
function ListView:setItemModel() end
--- <summary>
--- //Changes the margin between each item.
--- //@param margin
--- void setItemsMargin(float margin);
--- </summary>
function ListView:setItemsMargin() end
--- <summary>
--- virtual void sortAllChildren();
--- </summary>
function ListView:sortAllChildren() end
--- <summary>
--- //Default destructor
--- virtual ~ListView();
--- </summary>
function ListView:delete() end

LoadingBar = class(Widget)
--- <summary>
--- //Default constructor
--- LoadingBar();
--- </summary>
function LoadingBar:new() end
function LoadingBar:new_local() end
--- <summary>
--- //Allocates and initializes.
--- static LoadingBar* create();
--- </summary>
--- <returns type="LoadingBar"></returns>
function LoadingBar:create() end
--- <summary>
--- virtual const CCSize&amp; getContentSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function LoadingBar:getContentSize() end
--- <summary>
--- //Returns the "class name" of widget.
--- virtual std::string getDescription() const;
--- </summary>
--- <returns type="std::string"></returns>
function LoadingBar:getDescription() end
--- <summary>
--- //Gets the progress direction of loadingbar.
--- //@see LoadingBarType  LoadingBarTypeLeft means progress left to right, LoadingBarTypeRight otherwise.
--- //@param LoadingBarType
--- int getDirection();
--- </summary>
function LoadingBar:getDirection() end
--- <summary>
--- //Gets the progress direction of loadingbar.
--- //@return percent    percent value from 1 to 100.
--- int getPercent();
--- </summary>
function LoadingBar:getPercent() end
--- <summary>
--- virtual CCNode* getVirtualRenderer();
--- </summary>
--- <returns type="CCNode"></returns>
function LoadingBar:getVirtualRenderer() end
--- <summary>
--- virtual void ignoreContentAdaptWithSize(bool ignore);
--- </summary>
function LoadingBar:ignoreContentAdaptWithSize() end
--- <summary>
--- //Load texture for loadingbar.
--- //@param fileName   file name of texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadTexture(const char* texture,TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function LoadingBar:loadTexture() end
--- <summary>
--- //Sets capinsets for loadingbar, if loadingbar is using scale9 renderer.
--- //@param capInsets    capinsets for loadingbar
--- void setCapInsets(const CCRect &amp;capInsets);
--- </summary>
function LoadingBar:setCapInsets() end
--- <summary>
--- //Changes the progress direction of loadingbar.
--- //@see LoadingBarType  LoadingBarTypeLeft means progress left to right, LoadingBarTypeRight otherwise.
--- //@param LoadingBarType
--- void setDirection(LoadingBarType dir);
--- </summary>
function LoadingBar:setDirection() end
--- <summary>
--- //Changes the progress direction of loadingbar.
--- //@param percent    percent value from 1 to 100.
--- void setPercent(int percent);
--- </summary>
function LoadingBar:setPercent() end
--- <summary>
--- //Sets if loadingbar is using scale9 renderer.
--- //@param true that using scale9 renderer, false otherwise.
--- void setScale9Enabled(bool enabled);
--- </summary>
function LoadingBar:setScale9Enabled() end
--- <summary>
--- //Default destructor
--- virtual ~LoadingBar();
--- </summary>
function LoadingBar:delete() end

PageView = class(Layout)
--- <summary>
--- //Default constructor
--- PageView();
--- </summary>
function PageView:new() end
function PageView:new_local() end
--- <summary>
--- //Push back a page to pageview.
--- //@param page    page to be added to pageview.
--- void addPage(Layout* page);
--- </summary>
function PageView:addPage() end
--- <summary>
--- //Add a widget to a page of pageview.
--- //@param widget    widget to be added to pageview.
--- //@param pageIdx   index of page.
--- //@param forceCreate   if force create and there is no page exsit, pageview would create a default page for adding widget.
--- void addWidgetToPage(Widget* widget, int pageIdx, bool forceCreate);
--- </summary>
function PageView:addWidgetToPage() end
--- <summary>
--- //Allocates and initializes.
--- static PageView* create();
--- </summary>
--- <returns type="PageView"></returns>
function PageView:create() end
--- <summary>
--- //Gets current page index.
--- //@return current page index.
--- int getCurPageIndex() const;
--- </summary>
function PageView:getCurPageIndex() end
--- <summary>
--- //Returns the "class name" of widget.
--- virtual std::string getDescription() const;
--- </summary>
--- <returns type="std::string"></returns>
function PageView:getDescription() end
--- <summary>
--- //Gets LayoutType.
--- //@see LayoutType
--- //@return LayoutType
--- virtual LayoutType getLayoutType() const;
--- </summary>
--- <returns type="LayoutType"></returns>
function PageView:getLayoutType() end
--- <summary>
--- Layout* getPage(int index);
--- </summary>
--- <returns type="Layout"></returns>
function PageView:getPage() end
--- <summary>
--- CCArray* getPages();
--- </summary>
--- <returns type="CCArray"></returns>
function PageView:getPages() end
--- <summary>
--- //Inert a page to pageview.
--- //@param page    page to be added to pageview.
--- void insertPage(Layout* page, int idx);
--- </summary>
function PageView:insertPage() end
--- <summary>
--- virtual bool onTouchBegan(CCTouch *touch, CCEvent *unusedEvent);
--- </summary>
function PageView:onTouchBegan() end
--- <summary>
--- virtual void onTouchCancelled(CCTouch *touch, CCEvent *unusedEvent);
--- </summary>
function PageView:onTouchCancelled() end
--- <summary>
--- virtual void onTouchEnded(CCTouch *touch, CCEvent *unusedEvent);
--- </summary>
function PageView:onTouchEnded() end
--- <summary>
--- virtual void onTouchMoved(CCTouch *touch, CCEvent *unusedEvent);
--- </summary>
function PageView:onTouchMoved() end
--- <summary>
--- void removeAllPages();
--- </summary>
function PageView:removeAllPages() end
--- <summary>
--- //Remove a page of pageview.
--- //@param page    page which will be removed.
--- void removePage(Layout* page);
--- </summary>
function PageView:removePage() end
--- <summary>
--- //Remove a page at index of pageview.
--- //@param index    index of page.
--- void removePageAtIndex(int index);
--- </summary>
function PageView:removePageAtIndex() end
--- <summary>
--- //scroll pageview to index.
--- //@param idx    index of page.
--- void scrollToPage(int idx);
--- </summary>
function PageView:scrollToPage() end
--- <summary>
--- //Sets LayoutType.
--- //@see LayoutType
--- //@param LayoutType
--- virtual void setLayoutType(LayoutType type);
--- </summary>
function PageView:setLayoutType() end
--- <summary>
--- virtual void update(float dt);
--- </summary>
function PageView:update() end
--- <summary>
--- //Default destructor
--- virtual ~PageView();
--- </summary>
function PageView:delete() end

UIRelativeLayoutParameter = class(UILayoutParameter)
--- <summary>
--- UIRelativeLayoutParameter();
--- </summary>
function UIRelativeLayoutParameter:new() end
function UIRelativeLayoutParameter:new_local() end
--- <summary>
--- static UIRelativeLayoutParameter* create();
--- </summary>
--- <returns type="UIRelativeLayoutParameter"></returns>
function UIRelativeLayoutParameter:create() end
--- <summary>
--- UIRelativeAlign getAlign() const;
--- </summary>
--- <returns type="UIRelativeAlign"></returns>
function UIRelativeLayoutParameter:getAlign() end
--- <summary>
--- const char* getRelativeName() const;
--- </summary>
function UIRelativeLayoutParameter:getRelativeName() end
--- <summary>
--- const char* getRelativeToWidgetName() const;
--- </summary>
function UIRelativeLayoutParameter:getRelativeToWidgetName() end
--- <summary>
--- void setAlign(UIRelativeAlign align);
--- </summary>
function UIRelativeLayoutParameter:setAlign() end
--- <summary>
--- void setRelativeName(const char* name);
--- </summary>
function UIRelativeLayoutParameter:setRelativeName() end
--- <summary>
--- void setRelativeToWidgetName(const char* name);
--- </summary>
function UIRelativeLayoutParameter:setRelativeToWidgetName() end
--- <summary>
--- virtual ~UIRelativeLayoutParameter();
--- </summary>
function UIRelativeLayoutParameter:delete() end

RichElement = class(CCObject)
--- <summary>
--- RichElement(){};
--- </summary>
function RichElement:new() end
function RichElement:new_local() end
--- <summary>
--- virtual bool init(int tag, const ccColor3B&amp; color, GLubyte opacity);
--- </summary>
function RichElement:init() end
--- <summary>
--- virtual ~RichElement(){};
--- </summary>
function RichElement:delete() end

RichElementText = class(RichElement)
--- <summary>
--- RichElementText();
--- </summary>
function RichElementText:new() end
function RichElementText:new_local() end
--- <summary>
--- static RichElementText* create(int tag, const ccColor3B&amp; color, GLubyte opacity, const char* text, const char* fontName, float fontSize);
--- </summary>
--- <returns type="RichElementText"></returns>
function RichElementText:create() end
--- <summary>
--- virtual bool init(int tag, const ccColor3B&amp; color, GLubyte opacity, const char* text, const char* fontName, float fontSize);
--- </summary>
function RichElementText:init() end
--- <summary>
--- virtual ~RichElementText();
--- </summary>
function RichElementText:delete() end

RichElementImage = class(RichElement)
--- <summary>
--- RichElementImage();
--- </summary>
function RichElementImage:new() end
function RichElementImage:new_local() end
--- <summary>
--- static RichElementImage* create(int tag, const ccColor3B&amp; color, GLubyte opacity, const char* filePath);
--- </summary>
--- <returns type="RichElementImage"></returns>
function RichElementImage:create() end
--- <summary>
--- virtual bool init(int tag, const ccColor3B&amp; color, GLubyte opacity, const char* filePath);
--- </summary>
function RichElementImage:init() end
--- <summary>
--- virtual ~RichElementImage();
--- </summary>
function RichElementImage:delete() end

RichElementCustomNode = class(RichElement)
--- <summary>
--- RichElementCustomNode();
--- </summary>
function RichElementCustomNode:new() end
function RichElementCustomNode:new_local() end
--- <summary>
--- static RichElementCustomNode* create(int tag, const ccColor3B&amp; color, GLubyte opacity, CCNode* customNode);
--- </summary>
--- <returns type="RichElementCustomNode"></returns>
function RichElementCustomNode:create() end
--- <summary>
--- virtual bool init(int tag, const ccColor3B&amp; color, GLubyte opacity, CCNode* customNode);
--- </summary>
function RichElementCustomNode:init() end
--- <summary>
--- virtual ~RichElementCustomNode();
--- </summary>
function RichElementCustomNode:delete() end

RichText = class(Widget)
--- <summary>
--- RichText();
--- </summary>
function RichText:new() end
function RichText:new_local() end
--- <summary>
--- static RichText* create();
--- </summary>
--- <returns type="RichText"></returns>
function RichText:create() end
--- <summary>
--- void formatText();
--- </summary>
function RichText:formatText() end
--- <summary>
--- virtual const CCSize&amp; getContentSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function RichText:getContentSize() end
--- <summary>
--- virtual void ignoreContentAdaptWithSize(bool ignore);
--- </summary>
function RichText:ignoreContentAdaptWithSize() end
--- <summary>
--- void insertElement(RichElement* element, int index);
--- </summary>
function RichText:insertElement() end
--- <summary>
--- void pushBackElement(RichElement* element);
--- </summary>
function RichText:pushBackElement() end
--- <summary>
--- void removeElement(int index);
--- void removeElement(RichElement* element);
--- </summary>
function RichText:removeElement() end
--- <summary>
--- virtual void setAnchorPoint(const CCPoint &amp;pt);
--- </summary>
function RichText:setAnchorPoint() end
--- <summary>
--- void setVerticalSpace(float space);
--- </summary>
function RichText:setVerticalSpace() end
--- <summary>
--- virtual void visit();
--- </summary>
function RichText:visit() end
--- <summary>
--- virtual ~RichText();
--- </summary>
function RichText:delete() end

UIRootWidget = class(UILayout)
--- <summary>
--- UIRootWidget();
--- </summary>
function UIRootWidget:new() end
function UIRootWidget:new_local() end
--- <summary>
--- static UIRootWidget* create();
--- </summary>
--- <returns type="UIRootWidget"></returns>
function UIRootWidget:create() end
--- <summary>
--- virtual const char* getDescription() const;
--- </summary>
function UIRootWidget:getDescription() end
--- <summary>
--- virtual ~UIRootWidget();
--- </summary>
function UIRootWidget:delete() end

ScrollView = class(Layout)
--- <summary>
--- //Default constructor
--- ScrollView();
--- </summary>
function ScrollView:new() end
function ScrollView:new_local() end
--- <summary>
--- //Adds a child to the container with a z-order
--- //If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.
--- //@param child     A child node
--- //@param zOrder    Z order for drawing priority. Please refer to setZOrder(int)
--- virtual void addChild(CCNode * child, int zOrder);
--- 
--- //Adds a child to the container with z order and tag
--- //If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.
--- //@param child     A child node
--- //@param zOrder    Z order for drawing priority. Please refer to setZOrder(int)
--- //@param tag       A interger to identify the node easily. Please refer to setTag(int)
--- virtual void addChild(CCNode* child, int zOrder, int tag);
--- </summary>
function ScrollView:addChild() end
--- <summary>
--- virtual void addNode(CCNode* node);
--- virtual void addNode(CCNode * node, int zOrder);
--- virtual void addNode(CCNode* node, int zOrder, int tag);
--- </summary>
function ScrollView:addNode() end
--- <summary>
--- //Allocates and initializes.
--- static ScrollView* create();
--- </summary>
--- <returns type="ScrollView"></returns>
function ScrollView:create() end
--- <summary>
--- virtual Widget* getChildByName(const char* name);
--- </summary>
--- <returns type="Widget"></returns>
function ScrollView:getChildByName() end
--- <summary>
--- virtual CCNode * getChildByTag(int tag);
--- </summary>
--- <returns type="CCNode"></returns>
function ScrollView:getChildByTag() end
--- <summary>
--- virtual CCArray* getChildren();
--- </summary>
--- <returns type="CCArray"></returns>
function ScrollView:getChildren() end
--- <summary>
--- virtual unsigned int getChildrenCount() const;
--- </summary>
function ScrollView:getChildrenCount() end
--- <summary>
--- //Returns the "class name" of widget.
--- virtual std::string getDescription() const;
--- </summary>
--- <returns type="std::string"></returns>
function ScrollView:getDescription() end
--- <summary>
--- //Gets scroll direction of scrollview.
--- //@see SCROLLVIEW_DIR      SCROLLVIEW_DIR_VERTICAL means vertical scroll, SCROLLVIEW_DIR_HORIZONTAL means horizontal scroll
--- //@return SCROLLVIEW_DIR
--- SCROLLVIEW_DIR getDirection();
--- </summary>
--- <returns type="SCROLLVIEW_DIR"></returns>
function ScrollView:getDirection() end
--- <summary>
--- //Gets inner container of scrollview.
--- //Inner container is the container of scrollview's children.
--- //@return inner container.
--- Layout* getInnerContainer();
--- </summary>
--- <returns type="Layout"></returns>
function ScrollView:getInnerContainer() end
--- <summary>
--- //Gets inner container size of scrollview.
--- //Inner container size must be larger than or equal scrollview's size.
--- //@return inner container size.
--- const CCSize&amp; getInnerContainerSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function ScrollView:getInnerContainerSize() end
--- <summary>
--- //Gets LayoutType.
--- //@see LayoutType
--- //@return LayoutType
--- virtual LayoutType getLayoutType() const;
--- </summary>
--- <returns type="LayoutType"></returns>
function ScrollView:getLayoutType() end
--- <summary>
--- virtual CCNode * getNodeByTag(int tag);
--- </summary>
--- <returns type="CCNode"></returns>
function ScrollView:getNodeByTag() end
--- <summary>
--- virtual CCArray* getNodes();
--- </summary>
--- <returns type="CCArray"></returns>
function ScrollView:getNodes() end
--- <summary>
--- bool isBounceEnabled() const;
--- </summary>
function ScrollView:isBounceEnabled() end
--- <summary>
--- bool isInertiaScrollEnabled() const;
--- </summary>
function ScrollView:isInertiaScrollEnabled() end
--- <summary>
--- //Move inner container to bottom boundary of scrollview.
--- void jumpToBottom();
--- </summary>
function ScrollView:jumpToBottom() end
--- <summary>
--- //Move inner container to bottom and left boundary of scrollview.
--- void jumpToBottomLeft();
--- </summary>
function ScrollView:jumpToBottomLeft() end
--- <summary>
--- //Move inner container to bottom and right boundary of scrollview.
--- void jumpToBottomRight();
--- </summary>
function ScrollView:jumpToBottomRight() end
--- <summary>
--- //Move inner container to left boundary of scrollview.
--- void jumpToLeft();
--- </summary>
function ScrollView:jumpToLeft() end
--- <summary>
--- //Move inner container to both direction percent position of scrollview.
--- void jumpToPercentBothDirection(const CCPoint&amp; percent);
--- </summary>
function ScrollView:jumpToPercentBothDirection() end
--- <summary>
--- //Move inner container to horizontal percent position of scrollview.
--- void jumpToPercentHorizontal(float percent);
--- </summary>
function ScrollView:jumpToPercentHorizontal() end
--- <summary>
--- //Move inner container to vertical percent position of scrollview.
--- void jumpToPercentVertical(float percent);
--- </summary>
function ScrollView:jumpToPercentVertical() end
--- <summary>
--- //Move inner container to right boundary of scrollview.
--- void jumpToRight();
--- </summary>
function ScrollView:jumpToRight() end
--- <summary>
--- //Move inner container to top boundary of scrollview.
--- void jumpToTop();
--- </summary>
function ScrollView:jumpToTop() end
--- <summary>
--- //Move inner container to top and left boundary of scrollview.
--- void jumpToTopLeft();
--- </summary>
function ScrollView:jumpToTopLeft() end
--- <summary>
--- //Move inner container to top and right boundary of scrollview.
--- void jumpToTopRight();
--- </summary>
function ScrollView:jumpToTopRight() end
--- <summary>
--- virtual void removeAllChildren();
--- </summary>
function ScrollView:removeAllChildren() end
--- <summary>
--- virtual void removeAllChildrenWithCleanup(bool cleanup);
--- </summary>
function ScrollView:removeAllChildrenWithCleanup() end
--- <summary>
--- virtual void removeAllNodes();
--- </summary>
function ScrollView:removeAllNodes() end
--- <summary>
--- virtual void removeChild(CCNode* child); 
--- virtual void removeChild(CCNode* child, bool cleaup);
--- </summary>
function ScrollView:removeChild() end
--- <summary>
--- virtual void removeNode(CCNode* node);
--- </summary>
function ScrollView:removeNode() end
--- <summary>
--- virtual void removeNodeByTag(int tag);
--- </summary>
function ScrollView:removeNodeByTag() end
--- <summary>
--- //Scroll inner container to bottom boundary of scrollview.
--- void scrollToBottom(float time, bool attenuated);
--- </summary>
function ScrollView:scrollToBottom() end
--- <summary>
--- //Scroll inner container to bottom and left boundary of scrollview.
--- void scrollToBottomLeft(float time, bool attenuated);
--- </summary>
function ScrollView:scrollToBottomLeft() end
--- <summary>
--- //Scroll inner container to bottom and right boundary of scrollview.
--- void scrollToBottomRight(float time, bool attenuated);
--- </summary>
function ScrollView:scrollToBottomRight() end
--- <summary>
--- //Scroll inner container to left boundary of scrollview.
--- void scrollToLeft(float time, bool attenuated);
--- </summary>
function ScrollView:scrollToLeft() end
--- <summary>
--- //Scroll inner container to both direction percent position of scrollview.
--- void scrollToPercentBothDirection(const CCPoint&amp; percent, float time, bool attenuated);
--- </summary>
function ScrollView:scrollToPercentBothDirection() end
--- <summary>
--- //Scroll inner container to horizontal percent position of scrollview.
--- void scrollToPercentHorizontal(float percent, float time, bool attenuated);
--- </summary>
function ScrollView:scrollToPercentHorizontal() end
--- <summary>
--- //Scroll inner container to vertical percent position of scrollview.
--- void scrollToPercentVertical(float percent, float time, bool attenuated);
--- </summary>
function ScrollView:scrollToPercentVertical() end
--- <summary>
--- //Scroll inner container to right boundary of scrollview.
--- void scrollToRight(float time, bool attenuated);
--- </summary>
function ScrollView:scrollToRight() end
--- <summary>
--- //Scroll inner container to top boundary of scrollview.
--- void scrollToTop(float time, bool attenuated);
--- </summary>
function ScrollView:scrollToTop() end
--- <summary>
--- //Scroll inner container to top and left boundary of scrollview.
--- void scrollToTopLeft(float time, bool attenuated);
--- </summary>
function ScrollView:scrollToTopLeft() end
--- <summary>
--- //Scroll inner container to top and right boundary of scrollview.
--- void scrollToTopRight(float time, bool attenuated);
--- </summary>
function ScrollView:scrollToTopRight() end
--- <summary>
--- void setBounceEnabled(bool enabled);
--- </summary>
function ScrollView:setBounceEnabled() end
--- <summary>
--- //Changes scroll direction of scrollview.
--- //@see SCROLLVIEW_DIR      SCROLLVIEW_DIR_VERTICAL means vertical scroll, SCROLLVIEW_DIR_HORIZONTAL means horizontal scroll
--- //@param SCROLLVIEW_DIR
--- virtual void setDirection(SCROLLVIEW_DIR dir);
--- </summary>
function ScrollView:setDirection() end
--- <summary>
--- void setInertiaScrollEnabled(bool enabled);
--- </summary>
function ScrollView:setInertiaScrollEnabled() end
--- <summary>
--- //Changes inner container size of scrollview.
--- //Inner container size must be larger than or equal scrollview's size.
--- //@param inner container size.
--- void setInnerContainerSize(const CCSize &amp;size);
--- </summary>
function ScrollView:setInnerContainerSize() end
--- <summary>
--- //Sets LayoutType.
--- //@see LayoutType
--- //@param LayoutType
--- virtual void setLayoutType(LayoutType type);
--- </summary>
function ScrollView:setLayoutType() end
--- <summary>
--- virtual void update(float dt);
--- </summary>
function ScrollView:update() end
--- <summary>
--- //Default destructor
--- virtual ~ScrollView();
--- </summary>
function ScrollView:delete() end

Slider = class(Widget)
--- <summary>
--- //Default constructor
--- Slider();
--- </summary>
function Slider:new() end
function Slider:new_local() end
--- <summary>
--- //Allocates and initializes.
--- static Slider* create();
--- </summary>
--- <returns type="Slider"></returns>
function Slider:create() end
--- <summary>
--- const CCRect&amp; getCapInsetBarRenderer();
--- </summary>
--- <returns type="CCRect"></returns>
function Slider:getCapInsetBarRenderer() end
--- <summary>
--- const CCRect&amp; getCapInsetProgressBarRebderer();
--- </summary>
--- <returns type="CCRect"></returns>
function Slider:getCapInsetProgressBarRebderer() end
--- <summary>
--- virtual const CCSize&amp; getContentSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function Slider:getContentSize() end
--- <summary>
--- //Returns the "class name" of widget.
--- virtual std::string getDescription() const;
--- </summary>
--- <returns type="std::string"></returns>
function Slider:getDescription() end
--- <summary>
--- //Gets the progress direction of slider.
--- //@return percent    percent value from 1 to 100.
--- int getPercent();
--- </summary>
function Slider:getPercent() end
--- <summary>
--- virtual CCNode* getVirtualRenderer();
--- </summary>
--- <returns type="CCNode"></returns>
function Slider:getVirtualRenderer() end
--- <summary>
--- virtual void ignoreContentAdaptWithSize(bool ignore);
--- </summary>
function Slider:ignoreContentAdaptWithSize() end
--- <summary>
--- bool isScale9Enabled();
--- </summary>
function Slider:isScale9Enabled() end
--- <summary>
--- //Load texture for slider bar.
--- //@param fileName   file name of texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadBarTexture(const char* fileName,TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function Slider:loadBarTexture() end
--- <summary>
--- //Load dark state texture for slider progress bar.
--- //@param fileName    file path of texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadProgressBarTexture(const char* fileName, TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function Slider:loadProgressBarTexture() end
--- <summary>
--- //Load dark state texture for slider ball.
--- //@param disabled    dark state texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadSlidBallTextureDisabled(const char* disabled,TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function Slider:loadSlidBallTextureDisabled() end
--- <summary>
--- //Load normal state texture for slider ball.
--- //@param normal    normal state texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadSlidBallTextureNormal(const char* normal,TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function Slider:loadSlidBallTextureNormal() end
--- <summary>
--- //Load selected state texture for slider ball.
--- //@param selected    selected state texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadSlidBallTexturePressed(const char* pressed,TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function Slider:loadSlidBallTexturePressed() end
--- <summary>
--- //Load textures for slider ball.
--- //@param slider ball normal    normal state texture.
--- //@param slider ball selected    selected state texture.
--- //@param slider ball disabled    dark state texture.
--- //@param texType    @see UI_TEX_TYPE_LOCAL
--- void loadSlidBallTextures(const char* normal,const char* pressed,const char* disabled,TextureResType texType = UI_TEX_TYPE_LOCAL);
--- </summary>
function Slider:loadSlidBallTextures() end
--- <summary>
--- virtual bool onTouchBegan(CCTouch *touch, CCEvent *unused_event);
--- </summary>
function Slider:onTouchBegan() end
--- <summary>
--- virtual void onTouchCancelled(CCTouch *touch, CCEvent *unused_event);
--- </summary>
function Slider:onTouchCancelled() end
--- <summary>
--- virtual void onTouchEnded(CCTouch *touch, CCEvent *unused_event);
--- </summary>
function Slider:onTouchEnded() end
--- <summary>
--- virtual void onTouchMoved(CCTouch *touch, CCEvent *unused_event);
--- </summary>
function Slider:onTouchMoved() end
--- <summary>
--- //Sets capinsets for slider, if slider is using scale9 renderer.
--- //@param capInsets    capinsets for slider
--- void setCapInsetProgressBarRebderer(const CCRect &amp;capInsets);
--- </summary>
function Slider:setCapInsetProgressBarRebderer() end
--- <summary>
--- //Sets capinsets for slider, if slider is using scale9 renderer.
--- //@param capInsets    capinsets for slider
--- void setCapInsets(const CCRect &amp;capInsets);
--- </summary>
function Slider:setCapInsets() end
--- <summary>
--- //Sets capinsets for slider, if slider is using scale9 renderer.
--- //@param capInsets    capinsets for slider
--- void setCapInsetsBarRenderer(const CCRect &amp;capInsets);
--- </summary>
function Slider:setCapInsetsBarRenderer() end
--- <summary>
--- //Changes the progress direction of slider.
--- //@param percent    percent value from 1 to 100.
--- void setPercent(int percent);
--- </summary>
function Slider:setPercent() end
--- <summary>
--- //Sets if slider is using scale9 renderer.
--- //@param true that using scale9 renderer, false otherwise.
--- void setScale9Enabled(bool able);
--- </summary>
function Slider:setScale9Enabled() end
--- <summary>
--- //Default destructor
--- virtual ~Slider();
--- </summary>
function Slider:delete() end

TextField = class(Widget)
--- <summary>
--- TextField();
--- </summary>
function TextField:new() end
function TextField:new_local() end
--- <summary>
--- void attachWithIME();
--- </summary>
function TextField:attachWithIME() end
--- <summary>
--- static TextField* create();
--- </summary>
--- <returns type="TextField"></returns>
function TextField:create() end
--- <summary>
--- virtual void didNotSelectSelf();
--- </summary>
function TextField:didNotSelectSelf() end
--- <summary>
--- bool getAttachWithIME();
--- </summary>
function TextField:getAttachWithIME() end
--- <summary>
--- virtual const CCSize&amp; getContentSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function TextField:getContentSize() end
--- <summary>
--- bool getDeleteBackward();
--- </summary>
function TextField:getDeleteBackward() end
--- <summary>
--- //Returns the "class name" of widget.
--- virtual std::string getDescription() const;
--- </summary>
--- <returns type="std::string"></returns>
function TextField:getDescription() end
--- <summary>
--- bool getDetachWithIME();
--- </summary>
function TextField:getDetachWithIME() end
--- <summary>
--- const char* getFontName();
--- </summary>
function TextField:getFontName() end
--- <summary>
--- int getFontSize();
--- </summary>
function TextField:getFontSize() end
--- <summary>
--- bool getInsertText();
--- </summary>
function TextField:getInsertText() end
--- <summary>
--- int getMaxLength();
--- </summary>
function TextField:getMaxLength() end
--- <summary>
--- const char* getPasswordStyleText();
--- </summary>
function TextField:getPasswordStyleText() end
--- <summary>
--- const char* getPlaceHolder();
--- </summary>
function TextField:getPlaceHolder() end
--- <summary>
--- const char* getStringValue();
--- </summary>
function TextField:getStringValue() end
--- <summary>
--- CCSize getTouchSize();
--- </summary>
--- <returns type="CCSize"></returns>
function TextField:getTouchSize() end
--- <summary>
--- virtual CCNode* getVirtualRenderer();
--- </summary>
--- <returns type="CCNode"></returns>
function TextField:getVirtualRenderer() end
--- <summary>
--- virtual bool hitTest(const CCPoint &amp;pt);
--- </summary>
function TextField:hitTest() end
--- <summary>
--- bool isMaxLengthEnabled();
--- </summary>
function TextField:isMaxLengthEnabled() end
--- <summary>
--- bool isPasswordEnabled();
--- </summary>
function TextField:isPasswordEnabled() end
--- <summary>
--- virtual void onEnter();
--- </summary>
function TextField:onEnter() end
--- <summary>
--- virtual bool onTouchBegan(CCTouch *touch, CCEvent *unused_event);
--- </summary>
function TextField:onTouchBegan() end
--- <summary>
--- virtual void setAnchorPoint(const CCPoint &amp;pt);
--- </summary>
function TextField:setAnchorPoint() end
--- <summary>
--- void setAttachWithIME(bool attach);
--- </summary>
function TextField:setAttachWithIME() end
--- <summary>
--- void setDeleteBackward(bool deleteBackward);
--- </summary>
function TextField:setDeleteBackward() end
--- <summary>
--- void setDetachWithIME(bool detach);
--- </summary>
function TextField:setDetachWithIME() end
--- <summary>
--- void setFontName(const std::string&amp; name);
--- </summary>
function TextField:setFontName() end
--- <summary>
--- void setFontSize(int size);
--- </summary>
function TextField:setFontSize() end
--- <summary>
--- void setInsertText(bool insertText);
--- </summary>
function TextField:setInsertText() end
--- <summary>
--- void setMaxLength(int length);
--- </summary>
function TextField:setMaxLength() end
--- <summary>
--- void setMaxLengthEnabled(bool enable);
--- </summary>
function TextField:setMaxLengthEnabled() end
--- <summary>
--- void setPasswordEnabled(bool enable);
--- </summary>
function TextField:setPasswordEnabled() end
--- <summary>
--- void setPasswordStyleText(const char* styleText);
--- </summary>
function TextField:setPasswordStyleText() end
--- <summary>
--- void setPlaceHolder(const std::string&amp; value);
--- </summary>
function TextField:setPlaceHolder() end
--- <summary>
--- void setText(const std::string&amp; text);
--- </summary>
function TextField:setText() end
--- <summary>
--- void setTextAreaSize(const CCSize &amp;size);
--- </summary>
function TextField:setTextAreaSize() end
--- <summary>
--- void setTextHorizontalAlignment(CCTextAlignment alignment);
--- </summary>
function TextField:setTextHorizontalAlignment() end
--- <summary>
--- void setTextVerticalAlignment(CCVerticalTextAlignment alignment);
--- </summary>
function TextField:setTextVerticalAlignment() end
--- <summary>
--- void setTouchAreaEnabled(bool enable);
--- </summary>
function TextField:setTouchAreaEnabled() end
--- <summary>
--- void setTouchSize(const CCSize &amp;size);
--- </summary>
function TextField:setTouchSize() end
--- <summary>
--- virtual void update(float dt);
--- </summary>
function TextField:update() end
--- <summary>
--- virtual ~TextField();
--- </summary>
function TextField:delete() end

TouchGroup = class(CCLayer)
--- <summary>
--- //Default constructor
--- //@js ctor
--- TouchGroup();
--- </summary>
function TouchGroup:new() end
function TouchGroup:new_local() end
--- <summary>
--- //Add a widget to UILayer, for drawing.
--- //@param widget.
--- void addWidget(Widget* widget);
--- </summary>
function TouchGroup:addWidget() end
--- <summary>
--- virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function TouchGroup:ccTouchBegan() end
--- <summary>
--- virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function TouchGroup:ccTouchCancelled() end
--- <summary>
--- virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function TouchGroup:ccTouchEnded() end
--- <summary>
--- virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
--- </summary>
function TouchGroup:ccTouchMoved() end
--- <summary>
--- //Remove and clean up all of UILayer's widget.
--- virtual void clear();
--- </summary>
function TouchGroup:clear() end
--- <summary>
--- //Allocates and initializes a widget.
--- static TouchGroup *create(void);
--- </summary>
--- <returns type="TouchGroup"></returns>
function TouchGroup:create() end
--- <summary>
--- //Gets root widget of UILayer.
--- //@return UIRootWidget, "UIRootWidget" is the root widget of UILayer.
--- Widget* getRootWidget();
--- </summary>
--- <returns type="Widget"></returns>
function TouchGroup:getRootWidget() end
--- <summary>
--- //Seek a widget whose name is equal name param from widget tree.
--- //@param name.
--- Widget* getWidgetByName(const char* name);
--- </summary>
--- <returns type="Widget"></returns>
function TouchGroup:getWidgetByName() end
--- <summary>
--- //Finds a widget whose tag is equal tag param from widget tree.
--- //@param tag.
--- Widget* getWidgetByTag(int tag);
--- </summary>
--- <returns type="Widget"></returns>
function TouchGroup:getWidgetByTag() end
--- <summary>
--- virtual bool init();
--- </summary>
function TouchGroup:init() end
--- <summary>
--- virtual void onEnter();
--- </summary>
function TouchGroup:onEnter() end
--- <summary>
--- virtual void onEnterTransitionDidFinish();
--- </summary>
function TouchGroup:onEnterTransitionDidFinish() end
--- <summary>
--- virtual void onExit();
--- </summary>
function TouchGroup:onExit() end
--- <summary>
--- //Remove a widget from UILayer.
--- //@param widget.
--- //@param cleanup true if all running actions on all children widgets should be cleanup, false otherwise.
--- void removeWidget(Widget* widget);
--- </summary>
function TouchGroup:removeWidget() end
--- <summary>
--- //Default destructor
--- //@js NA
--- virtual ~TouchGroup();
--- </summary>
function TouchGroup:delete() end

Widget = class(CCNode)
--- <summary>
--- //Default constructor
--- Widget(void);
--- </summary>
function Widget:new() end
function Widget:new_local() end
--- <summary>
--- //Adds a child to the container with z-order as 0.
--- //If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.
--- //@param child A child node
--- virtual void addChild(CCNode * child);
--- 
--- //Adds a child to the container with a z-order
--- //If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.
--- //@param child     A child node
--- //@param zOrder    Z order for drawing priority. Please refer to setZOrder(int)
--- virtual void addChild(CCNode * child, int zOrder);
--- 
--- //Adds a child to the container with z order and tag
--- //If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.
--- //@param child     A child node
--- //@param zOrder    Z order for drawing priority. Please refer to setZOrder(int)
--- //@param tag       A interger to identify the node easily. Please refer to setTag(int)
--- virtual void addChild(CCNode* child, int zOrder, int tag);
--- </summary>
function Widget:addChild() end
--- <summary>
--- virtual void addNode(CCNode* node);
--- virtual void addNode(CCNode * node, int zOrder);
--- virtual void addNode(CCNode* node, int zOrder, int tag);
--- </summary>
function Widget:addNode() end
--- <summary>
--- virtual void checkChildInfo(int handleState,Widget* sender,const CCPoint &amp;touchPoint);
--- </summary>
function Widget:checkChildInfo() end
--- <summary>
--- bool clippingParentAreaContainPoint(const CCPoint &amp;pt);
--- </summary>
function Widget:clippingParentAreaContainPoint() end
--- <summary>
--- Widget* clone();
--- </summary>
--- <returns type="Widget"></returns>
function Widget:clone() end
--- <summary>
--- //Allocates and initializes a widget.
--- static Widget* create();
--- </summary>
--- <returns type="Widget"></returns>
function Widget:create() end
--- <summary>
--- //A call back function when widget lost of focus.
--- void didNotSelectSelf();
--- </summary>
function Widget:didNotSelectSelf() end
--- <summary>
--- int getActionTag();
--- </summary>
function Widget:getActionTag() end
--- <summary>
--- //Gets the bottom boundary position of this widget.
--- //@return The bottom boundary position of this widget.
--- float getBottomInParent();
--- </summary>
function Widget:getBottomInParent() end
--- <summary>
--- //Gets a child from the container with its name
--- //@param name   An key to find the child widget.
--- //@return a Widget object whose name equals to the input parameter
--- virtual Widget* getChildByName(const char* name);
--- </summary>
--- <returns type="Widget"></returns>
function Widget:getChildByName() end
--- <summary>
--- //Gets a child from the container with its tag
--- //@param tag   An identifier to find the child node.
--- //@return a Node object whose tag equals to the input parameter
--- virtual CCNode * getChildByTag(int tag);
--- </summary>
--- <returns type="CCNode"></returns>
function Widget:getChildByTag() end
--- <summary>
--- //Return an array of children
--- //Composing a "tree" structure is a very important feature of Node
--- //Here's a sample code of traversing children array:
--- //@code
--- //Node* node = NULL;
--- //CCARRAY_FOREACH(parent->getChildren(), node)
--- //{
--- //node->setPosition(0,0);
--- //}
--- //@endcode
--- //This sample code traverses all children nodes, and set their position to (0,0)
--- //@return An array of children
--- virtual CCArray* getChildren();
--- </summary>
--- <returns type="CCArray"></returns>
function Widget:getChildren() end
--- <summary>
--- //Get the amount of children.
--- //@return The amount of children.
--- virtual unsigned int getChildrenCount() const;
--- </summary>
function Widget:getChildrenCount() end
--- <summary>
--- const ccColor3B&amp; getColor();
--- </summary>
--- <returns type="ccColor3B"></returns>
function Widget:getColor() end
--- <summary>
--- //Gets the content size of widget.
--- //Content size is widget's texture size.
--- virtual const CCSize&amp; getContentSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function Widget:getContentSize() end
--- <summary>
--- const CCSize&amp; getCustomSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function Widget:getCustomSize() end
--- <summary>
--- //Returns the "class name" of widget.
--- virtual std::string getDescription() const;
--- </summary>
--- <returns type="std::string"></returns>
function Widget:getDescription() end
--- <summary>
--- //Gets LayoutParameter of widget.
--- //@see LayoutParameter
--- //@param type  Relative or Linear
--- //@return LayoutParameter
--- LayoutParameter* getLayoutParameter(LayoutParameterType type);
--- </summary>
--- <returns type="LayoutParameter"></returns>
function Widget:getLayoutParameter() end
--- <summary>
--- virtual const CCSize&amp; getLayoutSize();
--- </summary>
--- <returns type="CCSize"></returns>
function Widget:getLayoutSize() end
--- <summary>
--- //Gets the left boundary position of this widget.
--- //@return The left boundary position of this widget.
--- float getLeftInParent();
--- </summary>
function Widget:getLeftInParent() end
--- <summary>
--- //Returns a name that is used to identify the widget easily.
--- //You can set tags to widget then identify them easily.
--- //@return A const char* that identifies the widget.
--- const char* getName() const;
--- </summary>
function Widget:getName() end
--- <summary>
--- virtual CCNode * getNodeByTag(int tag);
--- </summary>
--- <returns type="CCNode"></returns>
function Widget:getNodeByTag() end
--- <summary>
--- virtual CCArray* getNodes();
--- </summary>
--- <returns type="CCArray"></returns>
function Widget:getNodes() end
--- <summary>
--- GLubyte getOpacity();
--- </summary>
--- <returns type="GLubyte"></returns>
function Widget:getOpacity() end
--- <summary>
--- //Gets the percent (x,y) of the widget in OpenGL coordinates
--- //@see setPosition(const Point&amp;)
--- //@return The percent (x,y) of the widget in OpenGL coordinates
--- const CCPoint&amp; getPositionPercent();
--- </summary>
--- <returns type="CCPoint"></returns>
function Widget:getPositionPercent() end
--- <summary>
--- //Gets the position type of the widget
--- //@see PositionType
--- //@return type  the position type of widget
--- PositionType getPositionType() const;
--- </summary>
--- <returns type="PositionType"></returns>
function Widget:getPositionType() end
--- <summary>
--- //Gets the right boundary position of this widget.
--- //@return The right boundary position of this widget.
--- float getRightInParent();
--- </summary>
function Widget:getRightInParent() end
--- <summary>
--- //Returns size of widget
--- //@return size
--- const CCSize&amp; getSize() const;
--- </summary>
--- <returns type="CCSize"></returns>
function Widget:getSize() end
--- <summary>
--- //Returns size percent of widget
--- //@return size percent
--- const CCPoint&amp; getSizePercent() const;
--- </summary>
--- <returns type="CCPoint"></returns>
function Widget:getSizePercent() end
--- <summary>
--- //Gets the size type of widget.
--- //@see SizeType
--- //@param type that is widget's size type
--- SizeType getSizeType() const;
--- </summary>
--- <returns type="SizeType"></returns>
function Widget:getSizeType() end
--- <summary>
--- //Gets the top boundary position of this widget.
--- //@return The top boundary position of this widget.
--- float getTopInParent();
--- </summary>
function Widget:getTopInParent() end
--- <summary>
--- const CCPoint&amp; getTouchEndPos();
--- </summary>
--- <returns type="CCPoint"></returns>
function Widget:getTouchEndPos() end
--- <summary>
--- const CCPoint&amp; getTouchMovePos();
--- </summary>
--- <returns type="CCPoint"></returns>
function Widget:getTouchMovePos() end
--- <summary>
--- const CCPoint&amp; getTouchStartPos();
--- </summary>
--- <returns type="CCPoint"></returns>
function Widget:getTouchStartPos() end
--- <summary>
--- //Gets the Virtual Renderer of widget.
--- //For example, a button's Virtual Renderer is it's texture renderer.
--- //@return Node pointer.
--- virtual CCNode* getVirtualRenderer();
--- </summary>
--- <returns type="CCNode"></returns>
function Widget:getVirtualRenderer() end
--- <summary>
--- //Returns a type that is widget's type
--- //@see WidgetType
--- //@return A WidgetType
--- WidgetType getWidgetType() const;
--- </summary>
--- <returns type="WidgetType"></returns>
function Widget:getWidgetType() end
--- <summary>
--- //Gets world position of widget.
--- //@return world position of widget.
--- CCPoint getWorldPosition();
--- </summary>
--- <returns type="CCPoint"></returns>
function Widget:getWorldPosition() end
--- <summary>
--- //Checks a point if is in widget's space
--- //@param point
--- //@return true if the point is in widget's space, flase otherwise.
--- virtual bool hitTest(const CCPoint &amp;pt);
--- </summary>
function Widget:hitTest() end
--- <summary>
--- //Ignore the widget size
--- //@param ignore, true that widget will ignore it's size, use texture size, false otherwise. Default value is true.
--- virtual void ignoreContentAdaptWithSize(bool ignore);
--- </summary>
function Widget:ignoreContentAdaptWithSize() end
--- <summary>
--- //Determines if the widget is bright
--- //@return true if the widget is bright, false if the widget is dark.
--- bool isBright() const;
--- </summary>
function Widget:isBright() end
--- <summary>
--- //Determines if the widget is enabled
--- //@return true if the widget is enabled, false if the widget is disabled.
--- bool isEnabled() const;
--- </summary>
function Widget:isEnabled() end
--- <summary>
--- //Returns the flag which indicates whether the widget is flipped horizontally or not.
--- //It only flips the texture of the widget, and not the texture of the widget's children.
--- //Also, flipping the texture doesn't alter the anchorPoint.
--- //If you want to flip the anchorPoint too, and/or to flip the children too use:
--- //widget->setScaleX(sprite->getScaleX() * -1);
--- //@return true if the widget is flipped horizaontally, false otherwise.
--- virtual bool isFlipX();
--- </summary>
function Widget:isFlipX() end
--- <summary>
--- //Return the flag which indicates whether the widget is flipped vertically or not.
--- //It only flips the texture of the widget, and not the texture of the widget's children.
--- //Also, flipping the texture doesn't alter the anchorPoint.
--- //If you want to flip the anchorPoint too, and/or to flip the children too use:
--- //widget->setScaleY(widget->getScaleY() * -1);
--- //@return true if the widget is flipped vertically, flase otherwise.
--- virtual bool isFlipY();
--- </summary>
function Widget:isFlipY() end
--- <summary>
--- //Determines if the widget is on focused
--- //@return true if the widget is on focused, false if the widget is not on focused.
--- bool isFocused() const;
--- </summary>
function Widget:isFocused() end
--- <summary>
--- //Gets the widget if is ignore it's size.
--- //@param ignore, true that widget will ignore it's size, use texture size, false otherwise. Default value is true.
--- bool isIgnoreContentAdaptWithSize() const;
--- </summary>
function Widget:isIgnoreContentAdaptWithSize() end
--- <summary>
--- //Determines if the widget is touch enabled
--- //@return true if the widget is touch enabled, false if the widget is touch disabled.
--- bool isTouchEnabled() const;
--- </summary>
function Widget:isTouchEnabled() end
--- <summary>
--- virtual void onEnter();
--- </summary>
function Widget:onEnter() end
--- <summary>
--- virtual void onExit();
--- </summary>
function Widget:onExit() end
--- <summary>
--- virtual bool onTouchBegan(CCTouch *touch, CCEvent *unused_event);
--- </summary>
function Widget:onTouchBegan() end
--- <summary>
--- virtual void onTouchCancelled(CCTouch *touch, CCEvent *unused_event);    
--- </summary>
function Widget:onTouchCancelled() end
--- <summary>
--- virtual void onTouchEnded(CCTouch *touch, CCEvent *unused_event);
--- </summary>
function Widget:onTouchEnded() end
--- <summary>
--- virtual void onTouchMoved(CCTouch *touch, CCEvent *unused_event);
--- </summary>
function Widget:onTouchMoved() end
--- <summary>
--- //Removes all children from the container with a cleanup.
--- //@see `removeAllChildrenWithCleanup(bool)`
--- virtual void removeAllChildren();
--- </summary>
function Widget:removeAllChildren() end
--- <summary>
--- //Removes all children from the container, and do a cleanup to all running actions depending on the cleanup parameter.
--- //@param cleanup   true if all running actions on all children nodes should be cleanup, false oterwise.
--- //@js removeAllChildren
--- //@lua removeAllChildren
--- virtual void removeAllChildrenWithCleanup(bool cleanup);
--- </summary>
function Widget:removeAllChildrenWithCleanup() end
--- <summary>
--- virtual void removeAllNodes();
--- </summary>
function Widget:removeAllNodes() end
--- <summary>
--- //Removes a child from the container. It will also cleanup all running actions depending on the cleanup parameter.
--- //@param child     The child node which will be removed.
--- //@param cleanup   true if all running actions and callbacks on the child node will be cleanup, false otherwise.
--- virtual void removeChild(CCNode* child, bool cleanup);
--- </summary>
function Widget:removeChild() end
--- <summary>
--- //Removes a child from the container by tag value. It will also cleanup all running actions depending on the cleanup parameter
--- //@param tag       An interger number that identifies a child node
--- //@param cleanup   true if all running actions and callbacks on the child node will be cleanup, false otherwise.
--- virtual void removeChildByTag(int tag, bool cleanup);
--- </summary>
function Widget:removeChildByTag() end
--- <summary>
--- //Removes this node itself from its parent node with a cleanup.
--- //If the node orphan, then nothing happens.
--- //@see `removeFromParentAndCleanup(bool)`
--- virtual void removeFromParent();
--- </summary>
function Widget:removeFromParent() end
--- <summary>
--- //Removes this node itself from its parent node.
--- //If the node orphan, then nothing happens.
--- //@param cleanup   true if all actions and callbacks on this node should be removed, false otherwise.
--- //@js removeFromParent
--- //@lua removeFromParent
--- virtual void removeFromParentAndCleanup(bool cleanup);
--- </summary>
function Widget:removeFromParentAndCleanup() end
--- <summary>
--- virtual void removeNode(CCNode* node);
--- </summary>
function Widget:removeNode() end
--- <summary>
--- virtual void removeNodeByTag(int tag);
--- </summary>
function Widget:removeNodeByTag() end
--- <summary>
--- void setActionTag(int tag);
--- </summary>
function Widget:setActionTag() end
--- <summary>
--- //Sets whether the widget is bright
--- //The default value is true, a widget is default to bright
--- //@param visible   true if the widget is bright, false if the widget is dark.
--- void setBright(bool bright);
--- </summary>
function Widget:setBright() end
--- <summary>
--- //To set the bright style of widget.
--- //@see BrightStyle
--- //@param style   BRIGHT_NORMAL the widget is normal state, BRIGHT_HIGHLIGHT the widget is height light state.
--- void setBrightStyle(BrightStyle style);
--- </summary>
function Widget:setBrightStyle() end
--- <summary>
--- virtual void setColor(const ccColor3B&amp; color);
--- </summary>
function Widget:setColor() end
--- <summary>
--- //Sets whether the widget is enabled
--- //Highest control of widget.
--- //The default value is true, a widget is default to enabled
--- //@param enabled   true if the widget is enabled, widget may be touched and visible, false if the widget is disabled, widget cannot be touched and hidden.
--- virtual void setEnabled(bool enabled);
--- </summary>
function Widget:setEnabled() end
--- <summary>
--- //Sets whether the widget should be flipped horizontally or not.
--- //@param bFlipX true if the widget should be flipped horizaontally, false otherwise.
--- virtual void setFlipX(bool flipX);
--- </summary>
function Widget:setFlipX() end
--- <summary>
--- //Sets whether the widget should be flipped vertically or not.
--- //@param bFlipY true if the widget should be flipped vertically, flase otherwise.
--- virtual void setFlipY(bool flipY);
--- </summary>
function Widget:setFlipY() end
--- <summary>
--- //Sets whether the widget is on focused
--- //The default value is false, a widget is default to not on focused
--- //@param fucosed   true if the widget is on focused, false if the widget is not on focused.
--- void setFocused(bool fucosed);
--- </summary>
function Widget:setFocused() end
--- <summary>
--- //Sets a LayoutParameter to widget. 
--- //@see LayoutParameter
--- //@param LayoutParameter pointer
--- //@param type  Relative or Linear
--- void setLayoutParameter(LayoutParameter* parameter);
--- </summary>
function Widget:setLayoutParameter() end
--- <summary>
--- //Changes the name that is used to identify the widget easily.
--- //@param A const char* that indentifies the widget.
--- void setName(const char* name);
--- </summary>
function Widget:setName() end
--- <summary>
--- virtual void setOpacity(GLubyte opacity);
--- </summary>
function Widget:setOpacity() end
--- <summary>
--- //Changes the position (x,y) of the widget in OpenGL coordinates
--- //Usually we use p(x,y) to compose Point object.
--- //The original point (0,0) is at the left-bottom corner of screen.
--- //@param position  The position (x,y) of the widget in OpenGL coordinates
--- void setPosition(const CCPoint &amp;pos);
--- </summary>
function Widget:setPosition() end
--- <summary>
--- //Changes the position (x,y) of the widget in OpenGL coordinates
--- //Usually we use p(x,y) to compose Point object.
--- //The original point (0,0) is at the left-bottom corner of screen.
--- //@param percent  The percent (x,y) of the widget in OpenGL coordinates
--- void setPositionPercent(const CCPoint &amp;percent);
--- </summary>
function Widget:setPositionPercent() end
--- <summary>
--- //Changes the position type of the widget
--- //@see PositionType
--- //@param type  the position type of widget
--- void setPositionType(PositionType type);
--- </summary>
function Widget:setPositionType() end
--- <summary>
--- //Changes the size that is widget's size
--- //@param size that is widget's size
--- virtual void setSize(const CCSize &amp;size);
--- </summary>
function Widget:setSize() end
--- <summary>
--- //Changes the percent that is widget's percent size
--- //@param percent that is widget's percent size
--- virtual void setSizePercent(const CCPoint &amp;percent);
--- </summary>
function Widget:setSizePercent() end
--- <summary>
--- //Changes the size type of widget.
--- //@see SizeType
--- //@param type that is widget's size type
--- void setSizeType(SizeType type);
--- </summary>
function Widget:setSizeType() end
--- <summary>
--- //Sets whether the widget is touch enabled
--- //The default value is false, a widget is default to touch disabled
--- //@param visible   true if the widget is touch enabled, false if the widget is touch disabled.
--- virtual void setTouchEnabled(bool enabled);
--- </summary>
function Widget:setTouchEnabled() end
--- <summary>
--- virtual void sortAllChildren();
--- </summary>
function Widget:sortAllChildren() end
--- <summary>
--- void updateSizeAndPosition();
--- void updateSizeAndPosition(const CCSize&amp; parentSize);
--- </summary>
function Widget:updateSizeAndPosition() end
--- <summary>
--- virtual void visit();
--- </summary>
function Widget:visit() end
--- <summary>
--- //Default destructor
--- virtual ~Widget();
--- </summary>
function Widget:delete() end

ccColor3B = {}
--- <summary>
--- ccColor3B(void);
--- </summary>
function ccColor3B:new() end
function ccColor3B:new_local() end

ccColor4B = {}
--- <summary>
--- ccColor4B(void);
--- </summary>
function ccColor4B:new() end
function ccColor4B:new_local() end

ccColor4F = {}
--- <summary>
--- ccColor4F(void);
--- </summary>
function ccColor4F:new() end
function ccColor4F:new_local() end

ccVertex2F = {}
--- <summary>
--- ccVertex2F(void);
--- </summary>
function ccVertex2F:new() end
function ccVertex2F:new_local() end

ccVertex3F = {}
--- <summary>
--- ccVertex3F(void);
--- </summary>
function ccVertex3F:new() end
function ccVertex3F:new_local() end

ccTex2F = {}
--- <summary>
--- ccTex2F(void);
--- </summary>
function ccTex2F:new() end
function ccTex2F:new_local() end

ccPointSprite = {}
--- <summary>
--- ccPointSprite(void);
--- </summary>
function ccPointSprite:new() end
function ccPointSprite:new_local() end

ccQuad2 = {}
--- <summary>
--- ccQuad2(void);
--- </summary>
function ccQuad2:new() end
function ccQuad2:new_local() end

ccQuad3 = {}
--- <summary>
--- ccQuad3(void);
--- </summary>
function ccQuad3:new() end
function ccQuad3:new_local() end

ccV2F_C4B_T2F = {}
--- <summary>
--- ccV2F_C4B_T2F(void);
--- </summary>
function ccV2F_C4B_T2F:new() end
function ccV2F_C4B_T2F:new_local() end

ccV2F_C4F_T2F = {}
--- <summary>
--- ccV2F_C4F_T2F(void);
--- </summary>
function ccV2F_C4F_T2F:new() end
function ccV2F_C4F_T2F:new_local() end

ccV3F_C4B_T2F = {}
--- <summary>
--- ccV3F_C4B_T2F(void);
--- </summary>
function ccV3F_C4B_T2F:new() end
function ccV3F_C4B_T2F:new_local() end

ccV2F_C4B_T2F_Quad = {}
--- <summary>
--- ccV2F_C4B_T2F_Quad(void);
--- </summary>
function ccV2F_C4B_T2F_Quad:new() end
function ccV2F_C4B_T2F_Quad:new_local() end

ccV3F_C4B_T2F_Quad = {}
--- <summary>
--- ccV3F_C4B_T2F_Quad(void);
--- </summary>
function ccV3F_C4B_T2F_Quad:new() end
function ccV3F_C4B_T2F_Quad:new_local() end

ccV2F_C4F_T2F_Quad = {}
--- <summary>
--- ccV2F_C4F_T2F_Quad(void);
--- </summary>
function ccV2F_C4F_T2F_Quad:new() end
function ccV2F_C4F_T2F_Quad:new_local() end

ccBlendFunc = {}
--- <summary>
--- ccBlendFunc(void);
--- </summary>
function ccBlendFunc:new() end
function ccBlendFunc:new_local() end

ccT2F_Quad = {}
--- <summary>
--- ccT2F_Quad(void);
--- </summary>
function ccT2F_Quad:new() end
function ccT2F_Quad:new_local() end

ccAnimationFrameData = {}
--- <summary>
--- ccAnimationFrameData(void);
--- </summary>
function ccAnimationFrameData:new() end
function ccAnimationFrameData:new_local() end

kmMat4 = {}

